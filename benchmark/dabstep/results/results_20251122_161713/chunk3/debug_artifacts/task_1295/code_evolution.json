[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 3062,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\nimport json\n\n# Define file paths\npayments_path = '/output/chunk3/data/context/payments.csv'\nfees_path = '/output/chunk3/data/context/fees.json'\nmerchant_data_path = '/output/chunk3/data/context/merchant_data.json'\n\n# 1. Load payments data\nprint(\"Loading payments.csv...\")\ndf_payments = pd.read_csv(payments_path)\n\n# 2. Filter for transactions where card_scheme is 'SwiftCharge' and is_credit is True\n# Note: The schema indicates is_credit is boolean.\nprint(\"Filtering for SwiftCharge Credit transactions...\")\ndf_filtered = df_payments[\n    (df_payments['card_scheme'] == 'SwiftCharge') & \n    (df_payments['is_credit'] == True)\n].copy()\n\n# 3. Load fees and merchant data for context in subsequent steps\nprint(\"Loading fees.json and merchant_data.json...\")\nwith open(fees_path, 'r') as f:\n    fees_data = json.load(f)\n\nwith open(merchant_data_path, 'r') as f:\n    merchant_data = json.load(f)\n\n# 4. Output summary to verify the step\nprint(\"-\" * 30)\nprint(f\"Total payments rows: {len(df_payments)}\")\nprint(f\"Filtered SwiftCharge Credit rows: {len(df_filtered)}\")\nprint(f\"Loaded {len(fees_data)} fee rules\")\nprint(f\"Loaded {len(merchant_data)} merchant records\")\nprint(\"-\" * 30)\n\n# Display first few rows of the filtered dataframe to confirm structure\nprint(\"First 5 rows of filtered data:\")\nprint(df_filtered[['psp_reference', 'merchant', 'card_scheme', 'is_credit', 'aci', 'eur_amount']].head())",
    "execution_output": "Loading payments.csv...\nFiltering for SwiftCharge Credit transactions...\nLoading fees.json and merchant_data.json...\n------------------------------\nTotal payments rows: 138236\nFiltered SwiftCharge Credit rows: 10128\nLoaded 1000 fee rules\nLoaded 30 merchant records\n------------------------------\nFirst 5 rows of filtered data:\n    psp_reference               merchant  ... aci  eur_amount\n5     74453982452         Crossfit_Hanna  ...   G       14.96\n12    55566636527         Crossfit_Hanna  ...   D      117.98\n20    33180657672         Crossfit_Hanna  ...   D       28.12\n21    89410650089   Golfclub_Baron_Friso  ...   D        7.86\n23    79488939497  Belles_cookbook_store  ...   D      374.37\n\n[5 rows x 6 columns]\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter for transactions where `card_scheme` is 'SwiftCharge' and `is_credit` is True, while also loading `fees.json` and `merchant_data.json` to prepare for linking fee rules."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 9681,
    "code": "import pandas as pd\nimport json\nimport numpy as np\nfrom datetime import datetime, timedelta\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if pd.isna(value) or value is None:\n        return 0.0\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except ValueError:\n            return 0.0\n    return float(value)\n\ndef parse_range_check(value, range_str):\n    \"\"\"\n    Checks if a numeric value fits within a range string (e.g., '100k-1m', '>5', '<3%').\n    \"\"\"\n    if range_str is None:\n        return True\n    \n    # Handle percentages in range string\n    is_percent = '%' in range_str\n    clean_range = range_str.replace('%', '').replace(',', '')\n    \n    # Handle k/m suffixes for volume\n    if 'k' in clean_range.lower() or 'm' in clean_range.lower():\n        def parse_suffix(s):\n            s = s.lower().strip()\n            if 'k' in s: return float(s.replace('k', '')) * 1000\n            if 'm' in s: return float(s.replace('m', '')) * 1000000\n            return float(s)\n    else:\n        def parse_suffix(s): return float(s)\n\n    try:\n        if '-' in clean_range:\n            low, high = clean_range.split('-')\n            low_val = parse_suffix(low)\n            high_val = parse_suffix(high)\n            if is_percent:\n                low_val /= 100\n                high_val /= 100\n            return low_val <= value <= high_val\n        \n        if clean_range.startswith('>'):\n            limit = parse_suffix(clean_range[1:])\n            if is_percent: limit /= 100\n            return value > limit\n            \n        if clean_range.startswith('<'):\n            limit = parse_suffix(clean_range[1:])\n            if is_percent: limit /= 100\n            return value < limit\n            \n        # Exact match (rare for ranges but possible)\n        val_check = parse_suffix(clean_range)\n        if is_percent: val_check /= 100\n        return value == val_check\n        \n    except Exception:\n        return False\n\ndef match_fee_rule(tx_ctx, rule):\n    \"\"\"\n    Determines if a fee rule applies to a specific transaction context.\n    tx_ctx: dict containing transaction details (merchant stats, tx props)\n    rule: dict from fees.json\n    \"\"\"\n    # 1. Card Scheme\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_ctx.get('card_scheme'):\n        return False\n        \n    # 2. Is Credit (Boolean or None/Wildcard)\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != tx_ctx.get('is_credit'):\n            return False\n            \n    # 3. Merchant Category Code (List of ints)\n    if rule.get('merchant_category_code'):\n        if tx_ctx.get('mcc') not in rule['merchant_category_code']:\n            return False\n            \n    # 4. Account Type (List of strings)\n    if rule.get('account_type'):\n        if tx_ctx.get('account_type') not in rule['account_type']:\n            return False\n            \n    # 5. ACI (List of strings)\n    if rule.get('aci'):\n        if tx_ctx.get('aci') not in rule['aci']:\n            return False\n            \n    # 6. Intracountry (Boolean or None)\n    if rule.get('intracountry') is not None:\n        # Convert 0.0/1.0 to bool if necessary\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != tx_ctx.get('intracountry'):\n            return False\n            \n    # 7. Monthly Volume (Range string)\n    if rule.get('monthly_volume'):\n        if not parse_range_check(tx_ctx.get('monthly_volume', 0), rule['monthly_volume']):\n            return False\n            \n    # 8. Monthly Fraud Level (Range string)\n    if rule.get('monthly_fraud_level'):\n        if not parse_range_check(tx_ctx.get('monthly_fraud_level', 0), rule['monthly_fraud_level']):\n            return False\n            \n    # 9. Capture Delay (String match or range)\n    if rule.get('capture_delay'):\n        # Simple string match for now as per data samples (e.g., 'manual', 'immediate')\n        # If rule has range like '>5', we need to parse. \n        # Merchant data has 'manual', 'immediate', '1', '7'.\n        rule_cd = rule['capture_delay']\n        merch_cd = str(tx_ctx.get('capture_delay', ''))\n        \n        if rule_cd.startswith('>'):\n            try:\n                limit = float(rule_cd[1:])\n                val = float(merch_cd) if merch_cd.replace('.','').isdigit() else 0\n                if val <= limit: return False\n            except:\n                if merch_cd not in ['manual']: # manual is usually long\n                    return False\n        elif rule_cd.startswith('<'):\n            try:\n                limit = float(rule_cd[1:])\n                val = float(merch_cd) if merch_cd.replace('.','').isdigit() else 0\n                if val >= limit: return False\n            except:\n                pass\n        elif rule_cd != merch_cd:\n            return False\n\n    return True\n\n# ---------------------------------------------------------\n# MAIN SCRIPT\n# ---------------------------------------------------------\n\n# Define file paths\npayments_path = '/output/chunk3/data/context/payments.csv'\nfees_path = '/output/chunk3/data/context/fees.json'\nmerchant_data_path = '/output/chunk3/data/context/merchant_data.json'\n\n# 1. Load Data\nprint(\"Loading data...\")\ndf_payments = pd.read_csv(payments_path)\nwith open(fees_path, 'r') as f:\n    fees_data = json.load(f)\nwith open(merchant_data_path, 'r') as f:\n    merchant_data_list = json.load(f)\n\n# Convert merchant data to dict for fast lookup\nmerchant_lookup = {m['merchant']: m for m in merchant_data_list}\n\n# 2. Pre-calculate Monthly Stats (Volume and Fraud)\n# Convert day_of_year to month\n# 2023 is not a leap year\ndef get_month(day_of_year):\n    date = datetime(2023, 1, 1) + timedelta(days=int(day_of_year) - 1)\n    return date.month\n\ndf_payments['month'] = df_payments['day_of_year'].apply(get_month)\n\n# Calculate stats per merchant per month\nprint(\"Calculating monthly stats...\")\nmonthly_stats = df_payments.groupby(['merchant', 'month']).agg(\n    total_volume=('eur_amount', 'sum'),\n    fraud_count=('has_fraudulent_dispute', 'sum'),\n    tx_count=('psp_reference', 'count')\n).reset_index()\n\nmonthly_stats['fraud_rate'] = monthly_stats['fraud_count'] / monthly_stats['tx_count']\n\n# Create a lookup for stats: (merchant, month) -> {vol, fraud}\nstats_lookup = {}\nfor _, row in monthly_stats.iterrows():\n    stats_lookup[(row['merchant'], row['month'])] = {\n        'volume': row['total_volume'],\n        'fraud_rate': row['fraud_rate']\n    }\n\n# 3. Filter Target Transactions\n# Question: \"For credit transactions, what would be the average fee... SwiftCharge... 5000 EUR?\"\n# We filter for SwiftCharge + Credit to get the distribution of transaction contexts (ACI, Merchant, Country, etc.)\nprint(\"Filtering SwiftCharge Credit transactions...\")\ndf_target = df_payments[\n    (df_payments['card_scheme'] == 'SwiftCharge') & \n    (df_payments['is_credit'] == True)\n].copy()\n\nprint(f\"Found {len(df_target)} matching transactions.\")\n\n# 4. Calculate Fees\nfees_calculated = []\ntarget_amount = 5000.0\n\nfor idx, row in df_target.iterrows():\n    merchant_name = row['merchant']\n    month = row['month']\n    \n    # Get Merchant Metadata\n    m_data = merchant_lookup.get(merchant_name)\n    if not m_data:\n        continue\n        \n    # Get Monthly Stats\n    stats = stats_lookup.get((merchant_name, month))\n    if not stats:\n        continue\n        \n    # Determine Intracountry\n    is_intracountry = (row['issuing_country'] == row['acquirer_country'])\n    \n    # Build Context\n    tx_context = {\n        'card_scheme': 'SwiftCharge',\n        'is_credit': True,\n        'mcc': m_data['merchant_category_code'],\n        'account_type': m_data['account_type'],\n        'aci': row['aci'],\n        'intracountry': is_intracountry,\n        'monthly_volume': stats['volume'],\n        'monthly_fraud_level': stats['fraud_rate'],\n        'capture_delay': m_data['capture_delay']\n    }\n    \n    # Find Matching Rule\n    matched_rule = None\n    # Iterate through fees (assuming order matters or first match is sufficient)\n    # In many fee structures, specific rules override generic ones. \n    # However, without explicit priority logic, we scan for the first valid match.\n    # If multiple match, usually the most specific one applies, but here we'll take the first found\n    # that satisfies all non-null constraints.\n    \n    for rule in fees_data:\n        if match_fee_rule(tx_context, rule):\n            matched_rule = rule\n            break\n            \n    if matched_rule:\n        # Calculate Fee for 5000 EUR\n        # Fee = Fixed + (Rate * Amount / 10000)\n        fixed = matched_rule['fixed_amount']\n        rate = matched_rule['rate']\n        fee = fixed + (rate * target_amount / 10000)\n        fees_calculated.append(fee)\n\n# 5. Compute Average\nif fees_calculated:\n    average_fee = sum(fees_calculated) / len(fees_calculated)\n    print(f\"Average fee for 5000 EUR transaction: {average_fee:.14f}\")\nelse:\n    print(\"No applicable fee rules found for the filtered transactions.\")",
    "execution_output": "Loading data...\nCalculating monthly stats...\nFiltering SwiftCharge Credit transactions...\nFound 10128 matching transactions.\nAverage fee for 5000 EUR transaction: 27.22285616718737\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter for transactions where `card_scheme` is 'SwiftCharge' and `is_credit` is True, while also loading `fees.json` and `merchant_data.json` to prepare for linking fee rules.",
      "Calculate monthly volume and fraud metrics for each merchant using the full dataset, then enrich the filtered SwiftCharge credit transactions with these metrics, merchant metadata (from merchant_data.json), and an 'intracountry' indicator to prepare for fee rule matching."
    ]
  }
]