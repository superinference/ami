[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2674,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\n# Define the file path\npayments_path = '/output/chunk3/data/context/payments.csv'\n\n# Load the payments dataset\ndf_payments = pd.read_csv(payments_path)\n\n# Define the target merchant and year\ntarget_merchant = \"Martinis_Fine_Steakhouse\"\ntarget_year = 2023\n\n# Filter the data for the specific merchant and year\n# We check both conditions: merchant name match and year match\nmerchant_transactions = df_payments[\n    (df_payments['merchant'] == target_merchant) & \n    (df_payments['year'] == target_year)\n]\n\n# Verify the filtering\nprint(f\"Total transactions in file: {len(df_payments)}\")\nprint(f\"Transactions for '{target_merchant}' in {target_year}: {len(merchant_transactions)}\")\n\n# Display a sample of the filtered data to confirm structure\nprint(\"\\nFirst 5 rows of filtered data:\")\nprint(merchant_transactions.head())\n\n# Display column names to ensure we have necessary fields for fee calculation (eur_amount, card_scheme, etc.)\nprint(\"\\nColumns available:\")\nprint(merchant_transactions.columns.tolist())",
    "execution_output": "Total transactions in file: 138236\nTransactions for 'Martinis_Fine_Steakhouse' in 2023: 13805\n\nFirst 5 rows of filtered data:\n    psp_reference                  merchant  ... aci  acquirer_country\n13    39321493661  Martinis_Fine_Steakhouse  ...   D                FR\n50    24796561934  Martinis_Fine_Steakhouse  ...   D                FR\n55    21702732737  Martinis_Fine_Steakhouse  ...   B                FR\n58    71209492949  Martinis_Fine_Steakhouse  ...   D                FR\n76    80211788576  Martinis_Fine_Steakhouse  ...   A                FR\n\n[5 rows x 21 columns]\n\nColumns available:\n['psp_reference', 'merchant', 'card_scheme', 'year', 'hour_of_day', 'minute_of_hour', 'day_of_year', 'is_credit', 'eur_amount', 'ip_country', 'issuing_country', 'device_type', 'ip_address', 'email_address', 'card_number', 'shopper_interaction', 'card_bin', 'has_fraudulent_dispute', 'is_refused_by_adyen', 'aci', 'acquirer_country']\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the data to retrieve all transactions associated with the merchant \"Martinis_Fine_Steakhouse\" for the year 2023."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 9205,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n# --- Custom Logic for Fee Calculation ---\n\ndef parse_value_custom(val_str):\n    \"\"\"Parses a value string with units (k, m, %) into a float.\"\"\"\n    val_str = str(val_str).strip().lower()\n    scale = 1.0\n    if '%' in val_str:\n        scale = 0.01\n        val_str = val_str.replace('%', '')\n    \n    if 'k' in val_str:\n        scale *= 1000\n        val_str = val_str.replace('k', '')\n    elif 'm' in val_str:\n        scale *= 1000000\n        val_str = val_str.replace('m', '')\n        \n    try:\n        return float(val_str) * scale\n    except ValueError:\n        return 0.0\n\ndef check_range(range_str, value):\n    \"\"\"Checks if a value falls within a range string (e.g., '100k-1m', '>5%', '<3').\"\"\"\n    if range_str is None:\n        return True\n    s = str(range_str).strip()\n    if s == '':\n        return True\n    \n    # Handle operators\n    if s.startswith(('>', '<', '\u2265', '\u2264')):\n        operator = s[0]\n        if len(s) > 1 and s[1] == '=': \n            operator += '='\n            num_str = s[2:]\n        else:\n            num_str = s[1:]\n        \n        limit = parse_value_custom(num_str)\n        \n        if operator == '>': return value > limit\n        if operator == '<': return value < limit\n        if operator == '\u2265' or operator == '>=': return value >= limit\n        if operator == '\u2264' or operator == '<=': return value <= limit\n        \n    # Handle range \"min-max\"\n    if '-' in s:\n        parts = s.split('-')\n        if len(parts) == 2:\n            try:\n                min_val = parse_value_custom(parts[0])\n                max_val = parse_value_custom(parts[1])\n                return min_val <= value <= max_val\n            except:\n                return False\n    \n    # Exact match\n    try:\n        return value == parse_value_custom(s)\n    except:\n        return False\n\ndef check_capture_delay(rule_delay, merchant_delay):\n    \"\"\"Checks if merchant capture delay matches the rule.\"\"\"\n    if rule_delay is None:\n        return True\n    \n    md = str(merchant_delay).lower()\n    rd = str(rule_delay).lower()\n    \n    if rd == md:\n        return True\n        \n    # Handle numeric comparisons for days\n    if md.isdigit():\n        days = int(md)\n        if rd == '<3':\n            return days < 3\n        if rd == '>5':\n            return days > 5\n        if rd == '3-5':\n            return 3 <= days <= 5\n    \n    return False\n\ndef main():\n    # 1. Load Data\n    payments_path = '/output/chunk3/data/context/payments.csv'\n    fees_path = '/output/chunk3/data/context/fees.json'\n    merchant_data_path = '/output/chunk3/data/context/merchant_data.json'\n\n    df_payments = pd.read_csv(payments_path)\n    with open(fees_path, 'r') as f:\n        fees_rules = json.load(f)\n    with open(merchant_data_path, 'r') as f:\n        merchant_data = json.load(f)\n\n    target_merchant = \"Martinis_Fine_Steakhouse\"\n    target_year = 2023\n\n    # 2. Filter Transactions\n    df = df_payments[\n        (df_payments['merchant'] == target_merchant) & \n        (df_payments['year'] == target_year)\n    ].copy()\n\n    if df.empty:\n        print(\"No transactions found.\")\n        return\n\n    # 3. Get Merchant Metadata\n    merchant_info = next((item for item in merchant_data if item[\"merchant\"] == target_merchant), None)\n    if not merchant_info:\n        print(\"Merchant info not found.\")\n        return\n\n    original_mcc = merchant_info['merchant_category_code']\n    account_type = merchant_info['account_type']\n    capture_delay_val = merchant_info['capture_delay']\n\n    # 4. Pre-calculate Monthly Stats (Volume and Fraud Rate)\n    # Create date/month column\n    df['date'] = pd.to_datetime(df['year'] * 1000 + df['day_of_year'], format='%Y%j')\n    df['month'] = df['date'].dt.month\n\n    monthly_stats = {}\n    for month in df['month'].unique():\n        month_df = df[df['month'] == month]\n        total_vol = month_df['eur_amount'].sum()\n        fraud_vol = month_df[month_df['has_fraudulent_dispute'] == True]['eur_amount'].sum()\n        # Fraud rate = Fraud Volume / Total Volume\n        fraud_rate = fraud_vol / total_vol if total_vol > 0 else 0.0\n        monthly_stats[month] = {\n            'volume': total_vol,\n            'fraud_rate': fraud_rate\n        }\n\n    # 5. Define Fee Calculation Function\n    def calculate_total_fees_for_mcc(mcc_code):\n        total_fee = 0.0\n        \n        # Iterate through each transaction\n        for _, row in df.iterrows():\n            # Transaction attributes\n            r_scheme = row['card_scheme']\n            r_credit = row['is_credit'] # boolean in csv\n            r_aci = row['aci']\n            r_intra = (row['issuing_country'] == row['acquirer_country'])\n            r_amount = row['eur_amount']\n            \n            # Monthly stats for this transaction\n            m_stats = monthly_stats[row['month']]\n            m_vol = m_stats['volume']\n            m_fraud = m_stats['fraud_rate']\n            \n            matched_rule = None\n            \n            # Find the first matching rule\n            for rule in fees_rules:\n                # 1. Card Scheme\n                if rule['card_scheme'] != r_scheme:\n                    continue\n                \n                # 2. Account Type (list, empty=wildcard)\n                if is_not_empty(rule['account_type']) and account_type not in rule['account_type']:\n                    continue\n                    \n                # 3. Capture Delay\n                if not check_capture_delay(rule['capture_delay'], capture_delay_val):\n                    continue\n                \n                # 4. Monthly Fraud Level\n                if not check_range(rule['monthly_fraud_level'], m_fraud):\n                    continue\n                    \n                # 5. Monthly Volume\n                if not check_range(rule['monthly_volume'], m_vol):\n                    continue\n                    \n                # 6. MCC (list, empty=wildcard)\n                if is_not_empty(rule['merchant_category_code']) and mcc_code not in rule['merchant_category_code']:\n                    continue\n                    \n                # 7. Is Credit (bool, null=wildcard)\n                if rule['is_credit'] is not None:\n                    if rule['is_credit'] != r_credit:\n                        continue\n                        \n                # 8. ACI (list, empty=wildcard)\n                if is_not_empty(rule['aci']) and r_aci not in rule['aci']:\n                    continue\n                    \n                # 9. Intracountry (bool/float, null=wildcard)\n                if rule['intracountry'] is not None:\n                    # Convert 0.0/1.0 to bool\n                    rule_intra = bool(rule['intracountry'])\n                    if rule_intra != r_intra:\n                        continue\n                \n                # Match found\n                matched_rule = rule\n                break\n            \n            if matched_rule:\n                # Fee = Fixed + (Rate * Amount / 10000)\n                fee = matched_rule['fixed_amount'] + (matched_rule['rate'] * r_amount / 10000.0)\n                total_fee += fee\n            else:\n                # No rule found (should not happen in synthetic data usually)\n                pass\n                \n        return total_fee\n\n    # 6. Calculate Fees for Both Scenarios\n    fees_original = calculate_total_fees_for_mcc(original_mcc)\n    fees_new = calculate_total_fees_for_mcc(7523)\n\n    # 7. Calculate Delta\n    delta = fees_new - fees_original\n    \n    # 8. Output\n    print(f\"{delta:.14f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "execution_output": "115.07792899998003\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the data to retrieve all transactions associated with the merchant \"Martinis_Fine_Steakhouse\" for the year 2023.",
      "Load `merchant_data.json` to retrieve the current MCC, account type, and capture delay for \"Martinis_Fine_Steakhouse\", load `fees.json` to access the fee rules, and calculate the monthly total volume and fraud rates from the transaction data to determine the applicable fee tiers for the year 2023."
    ]
  }
]