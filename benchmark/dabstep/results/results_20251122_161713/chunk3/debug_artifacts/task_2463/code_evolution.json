[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2515,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\n# Load the payments dataset\npayments_path = '/output/chunk3/data/context/payments.csv'\ndf_payments = pd.read_csv(payments_path)\n\n# Filter for Rafa_AI, Year 2023, and December (Day of Year >= 335)\n# 2023 is a non-leap year. Sum of days Jan-Nov = 334. Dec 1st is day 335.\nfiltered_df = df_payments[\n    (df_payments['merchant'] == 'Rafa_AI') & \n    (df_payments['year'] == 2023) & \n    (df_payments['day_of_year'] >= 335)\n]\n\n# Display verification of the filtered data\nprint(\"Filtered DataFrame Shape:\", filtered_df.shape)\nprint(\"\\nFirst 5 rows of filtered data:\")\nprint(filtered_df.head())\n\n# Verify specific columns relevant to the next steps (fee calculation)\nprint(\"\\nUnique Card Schemes in filtered data:\", filtered_df['card_scheme'].unique())\nprint(\"Unique Shopper Interactions in filtered data:\", filtered_df['shopper_interaction'].unique())",
    "execution_output": "Filtered DataFrame Shape: (2396, 21)\n\nFirst 5 rows of filtered data:\n     psp_reference merchant  ... aci  acquirer_country\n62     12075623213  Rafa_AI  ...   E                NL\n142    16711044830  Rafa_AI  ...   C                NL\n311    84174910496  Rafa_AI  ...   E                NL\n325    77365566967  Rafa_AI  ...   E                NL\n352    72544997083  Rafa_AI  ...   E                NL\n\n[5 rows x 21 columns]\n\nUnique Card Schemes in filtered data: ['GlobalCard' 'NexPay' 'TransactPlus' 'SwiftCharge']\nUnique Shopper Interactions in filtered data: ['Ecommerce' 'POS']\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the dataframe to include only transactions where the merchant is 'Rafa_AI', the year is 2023, and the day_of_year is greater than or equal to 335 (representing December 1st onwards)."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 8347,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except:\n            return 0.0\n    return 0.0\n\ndef parse_volume_range(range_str, value):\n    \"\"\"Check if value falls within a volume range string (e.g., '100k-1m').\"\"\"\n    if not range_str: return True\n    \n    def parse_val(s):\n        s = s.lower().replace('\u20ac', '').strip()\n        mult = 1\n        if 'k' in s: mult = 1000; s = s.replace('k', '')\n        if 'm' in s: mult = 1000000; s = s.replace('m', '')\n        try:\n            return float(s) * mult\n        except:\n            return 0.0\n\n    try:\n        if '-' in range_str:\n            low, high = range_str.split('-')\n            return parse_val(low) <= value <= parse_val(high)\n        if '>' in range_str:\n            return value > parse_val(range_str.replace('>', ''))\n        if '<' in range_str:\n            return value < parse_val(range_str.replace('<', ''))\n        return value == parse_val(range_str)\n    except:\n        return False\n\ndef parse_fraud_range(range_str, value):\n    \"\"\"Check if value falls within a fraud percentage range (e.g., '>8.3%').\"\"\"\n    if not range_str: return True\n    \n    def parse_pct(s):\n        s = s.replace('%', '').strip()\n        try:\n            return float(s) / 100.0\n        except:\n            return 0.0\n    \n    try:\n        if '-' in range_str:\n            low, high = range_str.split('-')\n            return parse_pct(low) <= value <= parse_pct(high)\n        if '>' in range_str:\n            return value > parse_pct(range_str.replace('>', ''))\n        if '<' in range_str:\n            return value < parse_pct(range_str.replace('<', ''))\n        return False\n    except:\n        return False\n\ndef match_capture_delay(rule_val, merch_val):\n    \"\"\"Match capture delay rules against merchant setting.\"\"\"\n    if not rule_val: return True\n    if str(rule_val) == str(merch_val): return True\n    \n    # Try numeric comparison if merchant value is numeric\n    try:\n        m_float = float(merch_val)\n        if '-' in rule_val:\n            l, h = map(float, rule_val.split('-'))\n            return l <= m_float <= h\n        if '>' in rule_val:\n            return m_float > float(rule_val.replace('>', ''))\n        if '<' in rule_val:\n            return m_float < float(rule_val.replace('<', ''))\n    except:\n        pass\n    return False\n\ndef match_fee_rule(ctx, rule):\n    \"\"\"\n    Check if a fee rule applies to a transaction context.\n    ctx: dict containing transaction and merchant details\n    rule: dict containing fee rule details\n    \"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule['card_scheme'] != ctx['card_scheme']:\n        return False\n\n    # 2. Account Type (List match or Wildcard)\n    if rule['account_type'] and ctx['account_type'] not in rule['account_type']:\n        return False\n\n    # 3. Merchant Category Code (List match or Wildcard)\n    if rule['merchant_category_code'] and ctx['mcc'] not in rule['merchant_category_code']:\n        return False\n\n    # 4. Is Credit (Bool match or Wildcard)\n    if rule['is_credit'] is not None and rule['is_credit'] != ctx['is_credit']:\n        return False\n\n    # 5. ACI (List match or Wildcard)\n    if rule['aci'] and ctx['aci'] not in rule['aci']:\n        return False\n\n    # 6. Intracountry (Bool match or Wildcard)\n    # rule['intracountry'] is 0.0 or 1.0. ctx['intracountry'] is Bool.\n    if rule['intracountry'] is not None:\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != ctx['intracountry']:\n            return False\n\n    # 7. Capture Delay (Complex match or Wildcard)\n    if not match_capture_delay(rule['capture_delay'], ctx['capture_delay']):\n        return False\n\n    # 8. Monthly Volume (Range match or Wildcard)\n    if not parse_volume_range(rule['monthly_volume'], ctx['monthly_volume']):\n        return False\n\n    # 9. Monthly Fraud Level (Range match or Wildcard)\n    if not parse_fraud_range(rule['monthly_fraud_level'], ctx['monthly_fraud_rate']):\n        return False\n\n    return True\n\n# ---------------------------------------------------------\n# MAIN EXECUTION\n# ---------------------------------------------------------\n\ndef main():\n    # 1. Load Data\n    payments_path = '/output/chunk3/data/context/payments.csv'\n    fees_path = '/output/chunk3/data/context/fees.json'\n    merchant_path = '/output/chunk3/data/context/merchant_data.json'\n\n    df_payments = pd.read_csv(payments_path)\n    with open(fees_path, 'r') as f:\n        fees = json.load(f)\n    with open(merchant_path, 'r') as f:\n        merchant_data = json.load(f)\n\n    # 2. Filter for Rafa_AI, December 2023\n    # December starts on Day 335 (non-leap year)\n    target_merchant = 'Rafa_AI'\n    df_filtered = df_payments[\n        (df_payments['merchant'] == target_merchant) & \n        (df_payments['year'] == 2023) & \n        (df_payments['day_of_year'] >= 335)\n    ].copy()\n\n    if df_filtered.empty:\n        print(\"No transactions found for Rafa_AI in Dec 2023.\")\n        return\n\n    # 3. Calculate Monthly Stats (Volume & Fraud)\n    # Manual: \"Monthly volumes and rates are computed always in natural months\"\n    # We use the filtered December data for these stats.\n    monthly_volume = df_filtered['eur_amount'].sum()\n    \n    fraud_txs = df_filtered[df_filtered['has_fraudulent_dispute'] == True]\n    fraud_volume = fraud_txs['eur_amount'].sum()\n    \n    # Manual: \"Fraud is defined as the ratio of fraudulent volume over total volume\"\n    monthly_fraud_rate = fraud_volume / monthly_volume if monthly_volume > 0 else 0.0\n\n    # 4. Get Merchant Attributes\n    merch_info = next((m for m in merchant_data if m['merchant'] == target_merchant), None)\n    if not merch_info:\n        print(f\"Merchant {target_merchant} not found in merchant_data.\")\n        return\n\n    # 5. Get Fee ID 141 Details\n    fee_141 = next((f for f in fees if f['ID'] == 141), None)\n    if not fee_141:\n        print(\"Fee ID 141 not found.\")\n        return\n    \n    old_rate = fee_141['rate']\n    new_rate = 1.0  # As per question\n    \n    # 6. Calculate Delta\n    total_delta = 0.0\n    \n    # Sort fees by ID to ensure deterministic matching order (usually first match applies)\n    fees_sorted = sorted(fees, key=lambda x: x['ID'])\n\n    for _, tx in df_filtered.iterrows():\n        # Build transaction context\n        ctx = {\n            'card_scheme': tx['card_scheme'],\n            'is_credit': tx['is_credit'],\n            'aci': tx['aci'],\n            'intracountry': tx['issuing_country'] == tx['acquirer_country'],\n            'amount': tx['eur_amount'],\n            # Merchant/Month Context\n            'account_type': merch_info['account_type'],\n            'mcc': merch_info['merchant_category_code'],\n            'capture_delay': merch_info['capture_delay'],\n            'monthly_volume': monthly_volume,\n            'monthly_fraud_rate': monthly_fraud_rate\n        }\n\n        # Find the applicable fee\n        matched_fee_id = None\n        for rule in fees_sorted:\n            if match_fee_rule(ctx, rule):\n                matched_fee_id = rule['ID']\n                break\n        \n        # If the applicable fee is ID 141, calculate the delta\n        if matched_fee_id == 141:\n            # Fee formula: fixed + rate * amount / 10000\n            # Delta = New Fee - Old Fee\n            # Delta = (fixed + new_rate * amt / 10000) - (fixed + old_rate * amt / 10000)\n            # Delta = (new_rate - old_rate) * amt / 10000\n            delta = (new_rate - old_rate) * ctx['amount'] / 10000.0\n            total_delta += delta\n\n    # 7. Output Result\n    # Use high precision for currency calculations\n    print(f\"{total_delta:.14f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "execution_output": "-5.24362600000000\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the dataframe to include only transactions where the merchant is 'Rafa_AI', the year is 2023, and the day_of_year is greater than or equal to 335 (representing December 1st onwards).",
      "Load `merchant_data.json` and `fees.json` to retrieve Rafa_AI's attributes and the fee rules, calculate the merchant's December 2023 monthly volume and fraud rate from the filtered data to satisfy rule conditions, and then compute the total fee delta by applying the fee logic to the transactions with the original fee ID 141 versus the modified fee ID 141 (rate = 1)."
    ]
  },
  {
    "round": 3,
    "plan_steps": 3,
    "code_length": 8576,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float.\"\"\"\n    if value is None:\n        return 0.0\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            try:\n                return float(v.replace('%', '')) / 100\n            except:\n                return 0.0\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except:\n            return 0.0\n    return 0.0\n\ndef parse_volume_range(range_str, value):\n    \"\"\"Check if value falls within a volume range string (e.g., '100k-1m').\"\"\"\n    if not range_str: return True\n    \n    def parse_val(s):\n        s = str(s).lower().replace('\u20ac', '').strip()\n        mult = 1\n        if 'k' in s: mult = 1000; s = s.replace('k', '')\n        if 'm' in s: mult = 1000000; s = s.replace('m', '')\n        try:\n            return float(s) * mult\n        except:\n            return 0.0\n\n    try:\n        if '-' in range_str:\n            low, high = range_str.split('-')\n            return parse_val(low) <= value <= parse_val(high)\n        if '>' in range_str:\n            return value > parse_val(range_str.replace('>', ''))\n        if '<' in range_str:\n            return value < parse_val(range_str.replace('<', ''))\n        return value == parse_val(range_str)\n    except:\n        return False\n\ndef parse_fraud_range(range_str, value):\n    \"\"\"Check if value falls within a fraud percentage range (e.g., '>8.3%').\"\"\"\n    if not range_str: return True\n    \n    def parse_pct(s):\n        s = str(s).replace('%', '').strip()\n        try:\n            return float(s) / 100.0\n        except:\n            return 0.0\n    \n    try:\n        if '-' in range_str:\n            low, high = range_str.split('-')\n            return parse_pct(low) <= value <= parse_pct(high)\n        if '>' in range_str:\n            return value > parse_pct(range_str.replace('>', ''))\n        if '<' in range_str:\n            return value < parse_pct(range_str.replace('<', ''))\n        return False\n    except:\n        return False\n\ndef match_capture_delay(rule_val, merch_val):\n    \"\"\"Match capture delay rules against merchant setting.\"\"\"\n    if not rule_val: return True\n    # Direct string match\n    if str(rule_val).lower() == str(merch_val).lower(): return True\n    \n    # Try numeric comparison if merchant value is numeric\n    try:\n        m_float = float(merch_val)\n        if '-' in rule_val:\n            l, h = map(float, rule_val.split('-'))\n            return l <= m_float <= h\n        if '>' in rule_val:\n            return m_float > float(rule_val.replace('>', ''))\n        if '<' in rule_val:\n            return m_float < float(rule_val.replace('<', ''))\n    except:\n        pass\n    return False\n\ndef match_fee_rule(ctx, rule):\n    \"\"\"\n    Check if a fee rule applies to a transaction context.\n    \"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule.get('card_scheme') and rule['card_scheme'] != ctx['card_scheme']:\n        return False\n\n    # 2. Account Type (List match or Wildcard)\n    if rule.get('account_type') and ctx['account_type'] not in rule['account_type']:\n        return False\n\n    # 3. Merchant Category Code (List match or Wildcard)\n    if rule.get('merchant_category_code') and ctx['mcc'] not in rule['merchant_category_code']:\n        return False\n\n    # 4. Is Credit (Bool match or Wildcard)\n    # Note: rule['is_credit'] can be True, False, or None\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != ctx['is_credit']:\n            return False\n\n    # 5. ACI (List match or Wildcard)\n    if rule.get('aci') and ctx['aci'] not in rule['aci']:\n        return False\n\n    # 6. Intracountry (Bool match or Wildcard)\n    # rule['intracountry'] is 0.0, 1.0, or None.\n    if rule.get('intracountry') is not None:\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != ctx['intracountry']:\n            return False\n\n    # 7. Capture Delay (Complex match or Wildcard)\n    if not match_capture_delay(rule.get('capture_delay'), ctx['capture_delay']):\n        return False\n\n    # 8. Monthly Volume (Range match or Wildcard)\n    if not parse_volume_range(rule.get('monthly_volume'), ctx['monthly_volume']):\n        return False\n\n    # 9. Monthly Fraud Level (Range match or Wildcard)\n    if not parse_fraud_range(rule.get('monthly_fraud_level'), ctx['monthly_fraud_rate']):\n        return False\n\n    return True\n\n# ---------------------------------------------------------\n# MAIN EXECUTION\n# ---------------------------------------------------------\n\ndef main():\n    # 1. Load Data\n    payments_path = '/output/chunk3/data/context/payments.csv'\n    fees_path = '/output/chunk3/data/context/fees.json'\n    merchant_path = '/output/chunk3/data/context/merchant_data.json'\n\n    try:\n        df_payments = pd.read_csv(payments_path)\n        with open(fees_path, 'r') as f:\n            fees = json.load(f)\n        with open(merchant_path, 'r') as f:\n            merchant_data = json.load(f)\n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return\n\n    # 2. Filter for Rafa_AI, December 2023\n    # December starts on Day 335 (non-leap year)\n    target_merchant = 'Rafa_AI'\n    \n    # Filter by merchant first to reduce size\n    df_merchant = df_payments[df_payments['merchant'] == target_merchant].copy()\n    \n    # Filter by date (Year 2023, Day >= 335)\n    df_filtered = df_merchant[\n        (df_merchant['year'] == 2023) & \n        (df_merchant['day_of_year'] >= 335)\n    ].copy()\n\n    if df_filtered.empty:\n        print(\"No transactions found for Rafa_AI in Dec 2023.\")\n        return\n\n    # 3. Calculate Monthly Stats (Volume & Fraud)\n    # Manual: \"Monthly volumes and rates are computed always in natural months\"\n    monthly_volume = df_filtered['eur_amount'].sum()\n    \n    fraud_txs = df_filtered[df_filtered['has_fraudulent_dispute'] == True]\n    fraud_volume = fraud_txs['eur_amount'].sum()\n    \n    # Manual: \"Fraud is defined as the ratio of fraudulent volume over total volume\"\n    monthly_fraud_rate = fraud_volume / monthly_volume if monthly_volume > 0 else 0.0\n\n    # 4. Get Merchant Attributes\n    merch_info = next((m for m in merchant_data if m['merchant'] == target_merchant), None)\n    if not merch_info:\n        print(f\"Merchant {target_merchant} not found in merchant_data.\")\n        return\n\n    # 5. Get Fee ID 141 Details\n    fee_141 = next((f for f in fees if f['ID'] == 141), None)\n    if not fee_141:\n        print(\"Fee ID 141 not found.\")\n        return\n    \n    old_rate = fee_141['rate']\n    new_rate = 1.0  # As per question\n    \n    # 6. Calculate Delta\n    total_delta = 0.0\n    \n    # Sort fees by ID to ensure deterministic matching order\n    fees_sorted = sorted(fees, key=lambda x: x['ID'])\n\n    # Pre-calculate merchant context to avoid repetition\n    merch_ctx = {\n        'account_type': merch_info['account_type'],\n        'mcc': merch_info['merchant_category_code'],\n        'capture_delay': merch_info['capture_delay'],\n        'monthly_volume': monthly_volume,\n        'monthly_fraud_rate': monthly_fraud_rate\n    }\n\n    # Iterate through transactions\n    for _, tx in df_filtered.iterrows():\n        # Build transaction context\n        ctx = merch_ctx.copy()\n        ctx.update({\n            'card_scheme': tx['card_scheme'],\n            'is_credit': tx['is_credit'],\n            'aci': tx['aci'],\n            'intracountry': tx['issuing_country'] == tx['acquirer_country'],\n            'amount': tx['eur_amount']\n        })\n\n        # Find the applicable fee\n        matched_fee_id = None\n        for rule in fees_sorted:\n            if match_fee_rule(ctx, rule):\n                matched_fee_id = rule['ID']\n                break\n        \n        # If the applicable fee is ID 141, calculate the delta\n        if matched_fee_id == 141:\n            # Delta = (new_rate - old_rate) * amt / 10000\n            delta = (new_rate - old_rate) * ctx['amount'] / 10000.0\n            total_delta += delta\n\n    # 7. Output Result\n    # Use high precision for currency calculations\n    print(f\"{total_delta:.14f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "execution_output": "-5.24362600000000\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "sufficient",
    "temperature": 0.2,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the dataframe to include only transactions where the merchant is 'Rafa_AI', the year is 2023, and the day_of_year is greater than or equal to 335 (representing December 1st onwards).",
      "Load `merchant_data.json` and `fees.json` to retrieve Rafa_AI's attributes and the fee rules, calculate the merchant's December 2023 monthly volume and fraud rate from the filtered data to satisfy rule conditions, and then compute the total fee delta by applying the fee logic to the transactions with the original fee ID 141 versus the modified fee ID 141 (rate = 1).",
      "Load `payments.csv`, `merchant_data.json`, and `fees.json`, filter for Rafa_AI's transactions in December 2023, identify the fee rule with ID=141 and its original rate, select the transactions that satisfy all conditions of fee ID 141, and calculate the total fee delta by summing `(1 - original_rate) * eur_amount / 10000` for those transactions."
    ]
  }
]