[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2631,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\n# Define file path\npayments_path = '/output/chunk3/data/context/payments.csv'\n\n# Load the payments dataset\ndf = pd.read_csv(payments_path)\n\n# Filter the dataset for the specific merchant and year\nmerchant_name = \"Martinis_Fine_Steakhouse\"\ntarget_year = 2023\n\nfiltered_df = df[\n    (df['merchant'] == merchant_name) & \n    (df['year'] == target_year)\n]\n\n# Calculate summary metrics to verify against ground truth\ntotal_volume = filtered_df['eur_amount'].sum()\nfraud_volume = filtered_df[filtered_df['has_fraudulent_dispute']]['eur_amount'].sum()\nfraud_rate = (fraud_volume / total_volume * 100) if total_volume > 0 else 0\n\n# Print results\nprint(f\"Data loaded and filtered for {merchant_name} in {target_year}\")\nprint(f\"Number of transactions: {len(filtered_df)}\")\nprint(f\"Total Volume: {total_volume:.2f}\")\nprint(f\"Fraud Volume: {fraud_volume:.2f}\")\nprint(f\"Fraud Rate: {fraud_rate:.2f}%\")\nprint(\"\\nSample of filtered data:\")\nprint(filtered_df.head().to_string())",
    "execution_output": "Data loaded and filtered for Martinis_Fine_Steakhouse in 2023\nNumber of transactions: 13805\nTotal Volume: 1260227.18\nFraud Volume: 115108.53\nFraud Rate: 9.13%\n\nSample of filtered data:\n    psp_reference                  merchant card_scheme  year  hour_of_day  minute_of_hour  day_of_year  is_credit  eur_amount ip_country issuing_country device_type              ip_address           email_address             card_number shopper_interaction  card_bin  has_fraudulent_dispute  is_refused_by_adyen aci acquirer_country\n13    39321493661  Martinis_Fine_Steakhouse  GlobalCard  2023            9              48           42       True       29.47         FR              FR       Linux  0LG7KSVCKOxMGDkgRElCZA  tCUsaB-FqRo7u9PBFRL9OA  Dqk1EsUqVh-mzFQdrg3Wzw           Ecommerce      4916                   False                False   D               FR\n50    24796561934  Martinis_Fine_Steakhouse  GlobalCard  2023           15              15          131       True      102.88         GR              GR       Other  9icJ_wdB1s4wFeTUX37qQQ  xFJ2x8xsl0qrnp83ZtTv8w  LHZKE1No_msVwVxAT6lZIA           Ecommerce      4556                   False                False   D               FR\n55    21702732737  Martinis_Fine_Steakhouse      NexPay  2023           19               3          291       True       45.11         BE              BE       Other  x8fwfbBnI_i1bQsm1nn_uw                     NaN  0IZ6uTwI3SiPFBgBl2GcRQ                 POS      4916                   False                False   B               FR\n58    71209492949  Martinis_Fine_Steakhouse      NexPay  2023           17              20          226       True       94.46         GR              GR     Android  3nc_L6rj0rcnMCn49Q3Biw  Ln9hAIt17mMS-xXpmBlGpw  KaPbqryvRCuVLz5HCmfwBA           Ecommerce      4556                   False                False   D               FR\n76    80211788576  Martinis_Fine_Steakhouse  GlobalCard  2023           22              11           30       True       62.96         BE              BE       Other                     NaN  eDaA7wLzXDzyEKGlhWZ8wA  Ur-i7ri9uNmV_mnQFB6Gug                 POS      4622                   False                False   A               FR\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the dataset to include only transactions where the merchant is \"Martinis_Fine_Steakhouse\" and the year is 2023."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 7905,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# HELPER FUNCTIONS\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef parse_range_check(value, range_str):\n    \"\"\"\n    Checks if a numeric value falls within a range string.\n    Range string examples: '100k-1m', '>5', '<3', '0%-0.5%', '7.7%-8.3%'\n    \"\"\"\n    if range_str is None:\n        return True\n    \n    try:\n        # Handle k/m suffixes for volume\n        def parse_val(s):\n            s = s.strip()\n            factor = 1\n            if s.endswith('%'):\n                s = s[:-1]\n                factor = 0.01\n            elif s.lower().endswith('k'):\n                s = s[:-1]\n                factor = 1000\n            elif s.lower().endswith('m'):\n                s = s[:-1]\n                factor = 1000000\n            return float(s) * factor\n\n        if '-' in range_str:\n            low_str, high_str = range_str.split('-')\n            low = parse_val(low_str)\n            high = parse_val(high_str)\n            return low <= value <= high\n        elif range_str.startswith('>'):\n            limit = parse_val(range_str[1:])\n            return value > limit\n        elif range_str.startswith('<'):\n            limit = parse_val(range_str[1:])\n            return value < limit\n        else:\n            # Exact match or single value (unlikely for ranges but possible)\n            return value == parse_val(range_str)\n    except:\n        return False\n\ndef match_fee_rule(tx_context, rule):\n    \"\"\"\n    Determines if a fee rule applies to a specific transaction context.\n    tx_context must contain:\n    - card_scheme, is_credit, aci, intracountry (from transaction)\n    - account_type, merchant_category_code, capture_delay (from merchant data)\n    - monthly_volume, monthly_fraud_rate (calculated stats)\n    \"\"\"\n    \n    # 1. Card Scheme (Exact match)\n    if rule['card_scheme'] != tx_context['card_scheme']:\n        return False\n        \n    # 2. Account Type (List containment or Wildcard)\n    if rule['account_type'] and tx_context['account_type'] not in rule['account_type']:\n        return False\n        \n    # 3. Merchant Category Code (List containment or Wildcard)\n    if rule['merchant_category_code'] and tx_context['merchant_category_code'] not in rule['merchant_category_code']:\n        return False\n        \n    # 4. Capture Delay (Exact match or Wildcard)\n    # Note: Rule specifies required delay. Merchant must match.\n    if rule['capture_delay'] and rule['capture_delay'] != tx_context['capture_delay']:\n        return False\n        \n    # 5. Is Credit (Boolean match or Wildcard)\n    if rule['is_credit'] is not None and rule['is_credit'] != tx_context['is_credit']:\n        return False\n        \n    # 6. ACI (List containment or Wildcard)\n    if rule['aci'] and tx_context['aci'] not in rule['aci']:\n        return False\n        \n    # 7. Intracountry (Boolean match or Wildcard)\n    # Note: fees.json uses 0.0/1.0 or null. tx_context uses boolean.\n    if rule['intracountry'] is not None:\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != tx_context['intracountry']:\n            return False\n\n    # 8. Monthly Volume (Range check)\n    if rule['monthly_volume'] and not parse_range_check(tx_context['monthly_volume'], rule['monthly_volume']):\n        return False\n        \n    # 9. Monthly Fraud Level (Range check)\n    if rule['monthly_fraud_level'] and not parse_range_check(tx_context['monthly_fraud_rate'], rule['monthly_fraud_level']):\n        return False\n        \n    return True\n\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n# MAIN LOGIC\n# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n# File paths\npayments_path = '/output/chunk3/data/context/payments.csv'\nmerchant_data_path = '/output/chunk3/data/context/merchant_data.json'\nfees_path = '/output/chunk3/data/context/fees.json'\n\n# 1. Load Data\ndf_payments = pd.read_csv(payments_path)\nwith open(merchant_data_path, 'r') as f:\n    merchant_data = json.load(f)\nwith open(fees_path, 'r') as f:\n    fees = json.load(f)\n\n# 2. Filter for Merchant and Year\ntarget_merchant = \"Martinis_Fine_Steakhouse\"\ntarget_year = 2023\n\ndf_merchant_txs = df_payments[\n    (df_payments['merchant'] == target_merchant) & \n    (df_payments['year'] == target_year)\n].copy()\n\nif df_merchant_txs.empty:\n    print(\"No transactions found for this merchant in 2023.\")\n    exit()\n\n# 3. Get Merchant Static Attributes\nmerchant_info = next((m for m in merchant_data if m['merchant'] == target_merchant), None)\nif not merchant_info:\n    print(f\"Merchant {target_merchant} not found in merchant_data.json\")\n    exit()\n\n# 4. Calculate Monthly Stats (Volume and Fraud Rate)\n# Add month column (assuming data is 2023, we can use day_of_year to approximate or just assume month logic if date existed)\n# Since we only have day_of_year, we map it to month.\ndef get_month(day_of_year):\n    # Simple approximation for 2023 (non-leap)\n    cumulative_days = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]\n    for i, d in enumerate(cumulative_days):\n        if day_of_year <= d:\n            return i # Returns month 1-12\n    return 12\n\ndf_merchant_txs['month'] = df_merchant_txs['day_of_year'].apply(get_month)\n\n# Group by month to get stats\nmonthly_stats = df_merchant_txs.groupby('month').agg(\n    total_volume=('eur_amount', 'sum'),\n    fraud_volume=('eur_amount', lambda x: x[df_merchant_txs.loc[x.index, 'has_fraudulent_dispute']].sum())\n).reset_index()\n\nmonthly_stats['fraud_rate'] = monthly_stats['fraud_volume'] / monthly_stats['total_volume'] # Ratio (0.0 - 1.0)\n\n# 5. Identify Applicable Fees\napplicable_fee_ids = set()\n\n# Optimization: Instead of iterating every row, iterate unique combinations per month\n# Relevant columns for fee matching: card_scheme, is_credit, aci, intracountry\n# Plus the monthly stats which depend on 'month'\n\n# Determine intracountry for all rows\ndf_merchant_txs['intracountry'] = df_merchant_txs['issuing_country'] == df_merchant_txs['acquirer_country']\n\n# Group by relevant columns to reduce iterations\ngrouped = df_merchant_txs.groupby(['month', 'card_scheme', 'is_credit', 'aci', 'intracountry']).size().reset_index(name='count')\n\nfor _, row in grouped.iterrows():\n    month = row['month']\n    \n    # Get monthly stats\n    stats = monthly_stats[monthly_stats['month'] == month].iloc[0]\n    monthly_vol = stats['total_volume']\n    monthly_fraud = stats['fraud_rate']\n    \n    # Build context\n    tx_context = {\n        'card_scheme': row['card_scheme'],\n        'is_credit': row['is_credit'],\n        'aci': row['aci'],\n        'intracountry': row['intracountry'],\n        'account_type': merchant_info['account_type'],\n        'merchant_category_code': merchant_info['merchant_category_code'],\n        'capture_delay': merchant_info['capture_delay'],\n        'monthly_volume': monthly_vol,\n        'monthly_fraud_rate': monthly_fraud\n    }\n    \n    # Check against all rules\n    for rule in fees:\n        if match_fee_rule(tx_context, rule):\n            applicable_fee_ids.add(rule['ID'])\n\n# 6. Output Result\nsorted_ids = sorted(list(applicable_fee_ids))\nprint(\", \".join(map(str, sorted_ids)))",
    "execution_output": "12, 16, 36, 38, 51, 64, 65, 79, 84, 95, 107, 123, 134, 141, 150, 154, 162, 163, 187, 217, 229, 257, 276, 280, 284, 300, 304, 332, 347, 364, 367, 381, 384, 398, 428, 431, 433, 454, 456, 459, 470, 473, 477, 485, 491, 501, 503, 536, 547, 556, 572, 595, 612, 616, 622, 626, 637, 640, 648, 660, 678, 680, 682, 702, 709, 721, 741, 769, 804, 813, 834, 849, 858, 861, 863, 870, 878, 888, 891, 895, 899, 913, 915, 921, 980, 996\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the dataset to include only transactions where the merchant is \"Martinis_Fine_Steakhouse\" and the year is 2023.",
      "Load `merchant_data.json` to get the merchant's attributes, then load `fees.json` and the filtered transaction data to calculate monthly volume and fraud rates, and finally iterate through the fee rules to identify all applicable fee IDs for the merchant's transactions in 2023."
    ]
  }
]