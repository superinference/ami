[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2921,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\nimport json\n\n# Set display options to ensure all columns are visible\npd.set_option('display.max_columns', None)\npd.set_option('display.width', 1000)\n\n# Load the fees.json file\nfees_path = '/output/chunk3/data/context/fees.json'\ntry:\n    df_fees = pd.read_json(fees_path)\n    print(\"Successfully loaded fees.json\")\n    print(f\"Shape: {df_fees.shape}\")\n    \n    # Inspect the columns and data types\n    print(\"\\nColumns and Data Types:\")\n    print(df_fees.dtypes)\n    \n    # Display the first few rows to understand the structure\n    print(\"\\nFirst 5 rows of Fee Rules:\")\n    print(df_fees.head().to_string())\n    \n    # Inspect unique values for key columns relevant to the question\n    print(\"\\nUnique Card Schemes:\")\n    print(df_fees['card_scheme'].unique())\n    \n    print(\"\\nUnique values for 'is_credit' (relevant for credit transactions):\")\n    print(df_fees['is_credit'].unique())\n    \n    # Filter for GlobalCard rules to inspect specific conditions\n    global_card_rules = df_fees[df_fees['card_scheme'] == 'GlobalCard']\n    print(f\"\\nNumber of GlobalCard rules: {len(global_card_rules)}\")\n    print(\"\\nSample GlobalCard Rules:\")\n    print(global_card_rules.head().to_string())\n\nexcept Exception as e:\n    print(f\"Error loading fees.json: {e}\")",
    "execution_output": "Successfully loaded fees.json\nShape: (1000, 12)\n\nColumns and Data Types:\nID                          int64\ncard_scheme                object\naccount_type               object\ncapture_delay              object\nmonthly_fraud_level        object\nmonthly_volume             object\nmerchant_category_code     object\nis_credit                 float64\naci                        object\nfixed_amount              float64\nrate                        int64\nintracountry              float64\ndtype: object\n\nFirst 5 rows of Fee Rules:\n   ID   card_scheme account_type capture_delay monthly_fraud_level monthly_volume                            merchant_category_code  is_credit     aci  fixed_amount  rate  intracountry\n0   1  TransactPlus           []          None                None           None  [8000, 8011, 8021, 8031, 8041, 7299, 9399, 8742]        0.0  [C, B]          0.10    19           NaN\n1   2    GlobalCard           []          None               >8.3%           None  [3000, 3001, 3002, 3003, 7011, 7032, 7512, 7513]        NaN     [B]          0.13    86           0.0\n2   3  TransactPlus           []            >5                None           None  [4111, 4121, 4131, 4411, 4511, 4789, 7513, 7523]        1.0  [C, A]          0.09    16           0.0\n3   4        NexPay           []          None                None           None        [8062, 8011, 8021, 7231, 7298, 7991, 8049]        NaN  [C, A]          0.11    25           1.0\n4   5    GlobalCard           []            <3                None            >5m  [5411, 5412, 5499, 5912, 5812, 5813, 5911, 5983]        0.0      []          0.13    69           NaN\n\nUnique Card Schemes:\n['TransactPlus' 'GlobalCard' 'NexPay' 'SwiftCharge']\n\nUnique values for 'is_credit' (relevant for credit transactions):\n[ 0. nan  1.]\n\nNumber of GlobalCard rules: 257\n\nSample GlobalCard Rules:\n    ID card_scheme account_type capture_delay monthly_fraud_level monthly_volume                            merchant_category_code  is_credit        aci  fixed_amount  rate  intracountry\n1    2  GlobalCard           []          None               >8.3%           None  [3000, 3001, 3002, 3003, 7011, 7032, 7512, 7513]        NaN        [B]          0.13    86           0.0\n4    5  GlobalCard           []            <3                None            >5m  [5411, 5412, 5499, 5912, 5812, 5813, 5911, 5983]        0.0         []          0.13    69           NaN\n9   10  GlobalCard           []     immediate                None            >5m  [5814, 5815, 5816, 7832, 7922, 7995, 7999, 5813]        NaN        [B]          0.12    59           0.0\n17  18  GlobalCard           []          None                None           None        [8062, 8011, 8021, 7231, 7298, 7991, 8049]        0.0     [C, A]          0.01    14           NaN\n24  25  GlobalCard           []          None                None           None  [3000, 3001, 3002, 3003, 7011, 7032, 7512, 7513]        1.0  [A, B, C]          0.14    57           NaN\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `fees.json` file into a dataframe to inspect the fee rules and their conditions."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 10581,
    "code": "import pandas as pd\nimport numpy as np\nimport json\n\n# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n# --- Domain Specific Helpers ---\n\ndef get_month(day_of_year):\n    \"\"\"Convert day of year (1-365) to month (1-12). Assumes non-leap year (2023).\"\"\"\n    days_in_months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    cumulative = 0\n    for i, days in enumerate(days_in_months):\n        cumulative += days\n        if day_of_year <= cumulative:\n            return i + 1\n    return 12\n\ndef parse_volume_string(vol_str):\n    \"\"\"Parse volume range strings like '100k-1m' or '>10m'.\"\"\"\n    if not vol_str: return None\n    v = vol_str.lower().replace(',', '')\n    \n    def parse_val(s):\n        m = 1\n        if 'k' in s: m = 1000; s = s.replace('k', '')\n        elif 'm' in s: m = 1000000; s = s.replace('m', '')\n        try:\n            return float(s) * m\n        except ValueError:\n            return 0.0\n\n    if '-' in v:\n        try:\n            low, high = v.split('-')\n            return (parse_val(low), parse_val(high))\n        except ValueError:\n            return None\n    elif '>' in v:\n        return (parse_val(v.replace('>', '')), float('inf'))\n    elif '<' in v:\n        return (0, parse_val(v.replace('<', '')))\n    return None\n\ndef check_volume_match(actual_vol, rule_vol_str):\n    \"\"\"Check if actual volume falls within the rule's volume range.\"\"\"\n    if not rule_vol_str: return True\n    rng = parse_volume_string(rule_vol_str)\n    if not rng: return True\n    return rng[0] <= actual_vol <= rng[1]\n\ndef parse_fraud_string(fraud_str):\n    \"\"\"Parse fraud range strings like '7.7%-8.3%' or '>8.3%'.\"\"\"\n    if not fraud_str: return None\n    v = fraud_str.replace('%', '')\n    \n    def parse_val(s):\n        try:\n            return float(s) / 100.0\n        except ValueError:\n            return 0.0\n\n    if '-' in v:\n        try:\n            low, high = v.split('-')\n            return (parse_val(low), parse_val(high))\n        except ValueError:\n            return None\n    elif '>' in v:\n        return (parse_val(v.replace('>', '')), float('inf'))\n    elif '<' in v:\n        return (0, parse_val(v.replace('<', '')))\n    return None\n\ndef check_fraud_match(actual_rate, rule_fraud_str):\n    \"\"\"Check if actual fraud rate falls within the rule's fraud range.\"\"\"\n    if not rule_fraud_str: return True\n    rng = parse_fraud_string(rule_fraud_str)\n    if not rng: return True\n    # Use a small epsilon for float comparison if needed, but direct comparison is usually sufficient\n    return rng[0] <= actual_rate <= rng[1]\n\ndef check_capture_delay(merchant_delay, rule_delay):\n    \"\"\"Check if merchant capture delay matches the rule.\"\"\"\n    if not rule_delay: return True\n    md = str(merchant_delay).lower()\n    rd = str(rule_delay).lower()\n    \n    # Exact match (e.g., \"manual\" == \"manual\", \"immediate\" == \"immediate\")\n    if md == rd: return True\n    \n    # Numeric range checks\n    # Merchant delay might be \"1\", \"2\", \"7\"\n    # Rule might be \"<3\", \">5\", \"3-5\"\n    if md.isdigit():\n        md_val = float(md)\n        if '-' in rd:\n            try:\n                low, high = map(float, rd.split('-'))\n                return low <= md_val <= high\n            except ValueError:\n                pass\n        elif '>' in rd:\n            try:\n                return md_val > float(rd.replace('>', ''))\n            except ValueError:\n                pass\n        elif '<' in rd:\n            try:\n                return md_val < float(rd.replace('<', ''))\n            except ValueError:\n                pass\n    \n    return False\n\ndef solve():\n    # 1. Load Data\n    try:\n        payments = pd.read_csv('/output/chunk3/data/context/payments.csv')\n        with open('/output/chunk3/data/context/fees.json', 'r') as f:\n            fees = json.load(f)\n        with open('/output/chunk3/data/context/merchant_data.json', 'r') as f:\n            merchant_data = json.load(f)\n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return\n\n    # Convert merchant_data to dict for easy lookup\n    merchants = {m['merchant']: m for m in merchant_data}\n\n    # 2. Preprocessing Payments\n    # Add Month\n    payments['month'] = payments['day_of_year'].apply(get_month)\n    \n    # Calculate Monthly Stats per Merchant (Volume and Fraud Rate)\n    # Fraud Rate = Fraud Volume / Total Volume (as per manual)\n    payments['fraud_amount'] = np.where(payments['has_fraudulent_dispute'], payments['eur_amount'], 0.0)\n    \n    monthly_stats = payments.groupby(['merchant', 'month']).agg({\n        'eur_amount': 'sum',\n        'fraud_amount': 'sum'\n    }).reset_index()\n    \n    monthly_stats.rename(columns={'eur_amount': 'monthly_volume'}, inplace=True)\n    # Avoid division by zero\n    monthly_stats['monthly_fraud_rate'] = monthly_stats.apply(\n        lambda row: row['fraud_amount'] / row['monthly_volume'] if row['monthly_volume'] > 0 else 0.0, \n        axis=1\n    )\n    \n    # Create a lookup for stats: (merchant, month) -> (vol, fraud_rate)\n    stats_lookup = {}\n    for _, row in monthly_stats.iterrows():\n        stats_lookup[(row['merchant'], row['month'])] = (row['monthly_volume'], row['monthly_fraud_rate'])\n\n    # 3. Filter Target Transactions\n    # Question: \"For credit transactions... GlobalCard... average fee... for 1234 EUR\"\n    # We simulate the fee for 1234 EUR on every historical GlobalCard Credit transaction\n    target_txs = payments[\n        (payments['card_scheme'] == 'GlobalCard') & \n        (payments['is_credit'] == True)\n    ].copy()\n    \n    if target_txs.empty:\n        print(\"No matching transactions found.\")\n        return\n\n    # 4. Calculate Fees\n    calculated_fees = []\n    \n    # Pre-filter fees for GlobalCard to optimize matching loop\n    global_fees = [f for f in fees if f['card_scheme'] == 'GlobalCard']\n    \n    # Sort fees by ID to ensure deterministic matching (though usually first match is standard)\n    global_fees.sort(key=lambda x: x['ID'])\n\n    for _, tx in target_txs.iterrows():\n        merch_name = tx['merchant']\n        if merch_name not in merchants:\n            continue \n            \n        merch_info = merchants[merch_name]\n        month = tx['month']\n        \n        # Retrieve Context Variables\n        vol, fraud_rate = stats_lookup.get((merch_name, month), (0.0, 0.0))\n        is_intracountry = (tx['issuing_country'] == tx['acquirer_country'])\n        \n        # Find matching rule\n        matched_rule = None\n        for rule in global_fees:\n            # 1. Check is_credit (Rule: True or Null. Tx: True)\n            # If rule is explicitly False, it doesn't match our Credit tx\n            if rule['is_credit'] is not None and rule['is_credit'] is False:\n                continue\n                \n            # 2. Check Account Type (Rule: List or Null. Tx: Single Value)\n            if rule['account_type'] and merch_info['account_type'] not in rule['account_type']:\n                continue\n                \n            # 3. Check MCC (Rule: List or Null. Tx: Single Value)\n            if rule['merchant_category_code'] and merch_info['merchant_category_code'] not in rule['merchant_category_code']:\n                continue\n                \n            # 4. Check ACI (Rule: List or Null. Tx: Single Value)\n            if rule['aci'] and tx['aci'] not in rule['aci']:\n                continue\n                \n            # 5. Check Intracountry (Rule: 0.0/1.0 or Null. Tx: Bool)\n            if rule['intracountry'] is not None:\n                rule_intra = bool(rule['intracountry'])\n                if rule_intra != is_intracountry:\n                    continue\n            \n            # 6. Check Capture Delay\n            if not check_capture_delay(merch_info['capture_delay'], rule['capture_delay']):\n                continue\n                \n            # 7. Check Monthly Volume\n            if not check_volume_match(vol, rule['monthly_volume']):\n                continue\n                \n            # 8. Check Monthly Fraud Level\n            if not check_fraud_match(fraud_rate, rule['monthly_fraud_level']):\n                continue\n            \n            # If all conditions pass, this is our rule\n            matched_rule = rule\n            break\n        \n        if matched_rule:\n            # Calculate Fee for hypothetical amount of 1234 EUR\n            # Formula: fee = fixed_amount + (rate * amount / 10000)\n            # rate is in basis points (per 10,000)\n            hypothetical_amount = 1234.0\n            fee = matched_rule['fixed_amount'] + (matched_rule['rate'] * hypothetical_amount / 10000.0)\n            calculated_fees.append(fee)\n        else:\n            # If no rule matches, we skip. In a real audit, this would be flagged.\n            pass\n\n    # 5. Average and Output\n    if not calculated_fees:\n        print(\"No applicable fees found.\")\n    else:\n        avg_fee = sum(calculated_fees) / len(calculated_fees)\n        # Print with high precision as requested for calculation tasks\n        print(f\"{avg_fee:.14f}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "execution_output": "9.50507562656464\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `fees.json` file into a dataframe to inspect the fee rules and their conditions.",
      "Load the `payments.csv` and `merchant_data.json` files, filter the payments for 'GlobalCard' and credit transactions, merge the merchant data, and calculate the necessary fields for fee rule matching (intracountry status, monthly volume, and monthly fraud level per merchant)."
    ]
  }
]