[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2192,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\n# Load the payments data\npayments_path = '/output/chunk3/data/context/payments.csv'\ndf_payments = pd.read_csv(payments_path)\n\n# Filter for the specific merchant, day, and year\n# Merchant: Martinis_Fine_Steakhouse\n# Day of year: 365\n# Year: 2023\nfiltered_df = df_payments[\n    (df_payments['merchant'] == 'Martinis_Fine_Steakhouse') &\n    (df_payments['day_of_year'] == 365) &\n    (df_payments['year'] == 2023)\n]\n\n# Print the result to verify\nprint(f\"Filtered dataframe shape: {filtered_df.shape}\")\nprint(filtered_df.head())",
    "execution_output": "Filtered dataframe shape: (33, 21)\n      psp_reference                  merchant  ... aci  acquirer_country\n918     23795700038  Martinis_Fine_Steakhouse  ...   G                FR\n3205    12228564812  Martinis_Fine_Steakhouse  ...   G                FR\n3675    57155000478  Martinis_Fine_Steakhouse  ...   C                FR\n5260    82451039423  Martinis_Fine_Steakhouse  ...   F                FR\n7916    15097356669  Martinis_Fine_Steakhouse  ...   F                FR\n\n[5 rows x 21 columns]\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter for rows where the `merchant` is 'Martinis_Fine_Steakhouse', the `day_of_year` is 365, and the `year` is 2023."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 9970,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except ValueError:\n            return 0.0\n    return 0.0\n\ndef parse_volume_string(vol_str):\n    \"\"\"Parses volume strings like '100k-1m' into (min, max) tuple.\"\"\"\n    if not vol_str:\n        return None\n    \n    def parse_val(s):\n        s = s.lower().strip()\n        mult = 1\n        if 'k' in s:\n            mult = 1000\n            s = s.replace('k', '')\n        elif 'm' in s:\n            mult = 1_000_000\n            s = s.replace('m', '')\n        return float(s) * mult\n\n    try:\n        if '-' in vol_str:\n            parts = vol_str.split('-')\n            return (parse_val(parts[0]), parse_val(parts[1]))\n        elif '>' in vol_str:\n            val = parse_val(vol_str.replace('>', ''))\n            return (val, float('inf'))\n        elif '<' in vol_str:\n            val = parse_val(vol_str.replace('<', ''))\n            return (0, val)\n    except:\n        return None\n    return None\n\ndef parse_fraud_string(fraud_str):\n    \"\"\"Parses fraud strings like '7.7%-8.3%' into (min, max) tuple.\"\"\"\n    if not fraud_str:\n        return None\n    \n    def parse_pct(s):\n        s = s.strip().replace('%', '')\n        return float(s) / 100.0\n\n    try:\n        if '-' in fraud_str:\n            parts = fraud_str.split('-')\n            return (parse_pct(parts[0]), parse_pct(parts[1]))\n        elif '>' in fraud_str:\n            val = parse_pct(fraud_str.replace('>', ''))\n            return (val, float('inf'))\n        elif '<' in fraud_str:\n            val = parse_pct(fraud_str.replace('<', ''))\n            return (0, val)\n    except:\n        return None\n    return None\n\ndef check_capture_delay(merchant_delay, rule_delay):\n    \"\"\"Matches merchant capture delay against rule criteria.\"\"\"\n    if rule_delay is None:\n        return True\n    \n    # Normalize merchant delay\n    md = str(merchant_delay).lower()\n    rd = str(rule_delay).lower()\n    \n    if rd == 'immediate':\n        return md == 'immediate'\n    if rd == 'manual':\n        return md == 'manual'\n    \n    # Numeric checks\n    try:\n        # If merchant delay is numeric (e.g., \"1\")\n        if md.isdigit():\n            md_val = int(md)\n            if '-' in rd:\n                low, high = map(int, rd.split('-'))\n                return low <= md_val <= high\n            if rd.startswith('>'):\n                return md_val > int(rd[1:])\n            if rd.startswith('<'):\n                return md_val < int(rd[1:])\n    except:\n        pass\n        \n    return False\n\ndef match_fee_rule(tx_context, rule):\n    \"\"\"\n    Determines if a fee rule applies to a specific transaction context.\n    tx_context must contain:\n    - card_scheme, account_type, merchant_category_code, is_credit, aci\n    - issuing_country, acquirer_country\n    - capture_delay (from merchant data)\n    - monthly_volume (calculated)\n    - monthly_fraud_rate (calculated)\n    \"\"\"\n    \n    # 1. Card Scheme (Exact match required)\n    if rule['card_scheme'] != tx_context['card_scheme']:\n        return False\n\n    # 2. Account Type (List match or Wildcard)\n    if rule['account_type'] and len(rule['account_type']) > 0:\n        if tx_context['account_type'] not in rule['account_type']:\n            return False\n\n    # 3. Merchant Category Code (List match or Wildcard)\n    if rule['merchant_category_code'] and len(rule['merchant_category_code']) > 0:\n        if tx_context['merchant_category_code'] not in rule['merchant_category_code']:\n            return False\n\n    # 4. Is Credit (Boolean match or Wildcard)\n    if rule['is_credit'] is not None:\n        if rule['is_credit'] != tx_context['is_credit']:\n            return False\n\n    # 5. ACI (List match or Wildcard)\n    if rule['aci'] and len(rule['aci']) > 0:\n        if tx_context['aci'] not in rule['aci']:\n            return False\n\n    # 6. Intracountry (Boolean match or Wildcard)\n    # Intracountry: Issuer Country == Acquirer Country\n    is_intra = (tx_context['issuing_country'] == tx_context['acquirer_country'])\n    if rule['intracountry'] is not None:\n        # rule['intracountry'] is 0.0 or 1.0 in JSON\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != is_intra:\n            return False\n\n    # 7. Capture Delay (Complex match or Wildcard)\n    if rule['capture_delay']:\n        if not check_capture_delay(tx_context['capture_delay'], rule['capture_delay']):\n            return False\n\n    # 8. Monthly Volume (Range match or Wildcard)\n    if rule['monthly_volume']:\n        vol_range = parse_volume_string(rule['monthly_volume'])\n        if vol_range:\n            if not (vol_range[0] <= tx_context['monthly_volume'] < vol_range[1]):\n                return False\n\n    # 9. Monthly Fraud Level (Range match or Wildcard)\n    if rule['monthly_fraud_level']:\n        fraud_range = parse_fraud_string(rule['monthly_fraud_level'])\n        if fraud_range:\n            # Note: fraud_range is (0.077, 0.083) for 7.7%-8.3%\n            # tx_context['monthly_fraud_rate'] should be a ratio (e.g. 0.08)\n            if not (fraud_range[0] <= tx_context['monthly_fraud_rate'] <= fraud_range[1]):\n                return False\n\n    return True\n\n# ---------------------------------------------------------\n# MAIN EXECUTION\n# ---------------------------------------------------------\n\n# 1. Load Data\npayments_path = '/output/chunk3/data/context/payments.csv'\nmerchant_path = '/output/chunk3/data/context/merchant_data.json'\nfees_path = '/output/chunk3/data/context/fees.json'\n\ndf_payments = pd.read_csv(payments_path)\nwith open(merchant_path, 'r') as f:\n    merchant_data = json.load(f)\nwith open(fees_path, 'r') as f:\n    fees_data = json.load(f)\n\n# 2. Get Merchant Metadata\ntarget_merchant = 'Martinis_Fine_Steakhouse'\nmerchant_info = next((item for item in merchant_data if item[\"merchant\"] == target_merchant), None)\n\nif not merchant_info:\n    print(f\"Error: Merchant {target_merchant} not found in merchant_data.json\")\nelse:\n    # 3. Calculate Monthly Stats for December 2023\n    # December is days 335 to 365 (inclusive) in a non-leap year\n    dec_start = 335\n    dec_end = 365\n    \n    df_december = df_payments[\n        (df_payments['merchant'] == target_merchant) &\n        (df_payments['year'] == 2023) &\n        (df_payments['day_of_year'] >= dec_start) &\n        (df_payments['day_of_year'] <= dec_end)\n    ]\n    \n    monthly_volume = df_december['eur_amount'].sum()\n    \n    # Fraud Rate = Count of Fraudulent Txs / Total Txs\n    # Note: Manual defines fraud level as \"ratio between monthly total volume and monthly volume notified as fraud\" \n    # WAIT: Re-reading manual section 5: \"fraud levels measured as ratio between monthly total volume and monthly volume notified as fraud\"\n    # Actually, usually it's count or volume. Let's check the text carefully.\n    # \"ratio between monthly total volume and monthly volume notified as fraud\" -> This phrasing is odd. \n    # Usually it is (Fraud Volume / Total Volume). Let's assume Volume based on the text \"monthly volume notified as fraud\".\n    # However, Section 7 says \"Fraud is defined as the ratio of fraudulent volume over total volume.\"\n    # Okay, so it is Volume based.\n    \n    fraud_volume = df_december[df_december['has_fraudulent_dispute']]['eur_amount'].sum()\n    total_volume = df_december['eur_amount'].sum()\n    \n    if total_volume > 0:\n        monthly_fraud_rate = fraud_volume / total_volume\n    else:\n        monthly_fraud_rate = 0.0\n\n    # 4. Filter Transactions for Day 365\n    df_target_day = df_payments[\n        (df_payments['merchant'] == target_merchant) &\n        (df_payments['year'] == 2023) &\n        (df_payments['day_of_year'] == 365)\n    ]\n\n    # 5. Calculate Fees\n    total_fees = 0.0\n    \n    # Pre-prepare context that doesn't change per transaction\n    base_context = {\n        'account_type': merchant_info['account_type'],\n        'merchant_category_code': merchant_info['merchant_category_code'],\n        'capture_delay': merchant_info['capture_delay'],\n        'monthly_volume': monthly_volume,\n        'monthly_fraud_rate': monthly_fraud_rate\n    }\n\n    for _, tx in df_target_day.iterrows():\n        # Build full context for this transaction\n        tx_context = base_context.copy()\n        tx_context['card_scheme'] = tx['card_scheme']\n        tx_context['is_credit'] = tx['is_credit']\n        tx_context['aci'] = tx['aci']\n        tx_context['issuing_country'] = tx['issuing_country']\n        tx_context['acquirer_country'] = tx['acquirer_country']\n        \n        # Find matching rule\n        matched_rule = None\n        for rule in fees_data:\n            if match_fee_rule(tx_context, rule):\n                matched_rule = rule\n                break # Assume first match wins\n        \n        if matched_rule:\n            # Fee = Fixed + (Rate * Amount / 10000)\n            # Rate is an integer (e.g., 19 means 0.19% or 19 basis points? Manual says \"divided by 10000\")\n            fee = matched_rule['fixed_amount'] + (matched_rule['rate'] * tx['eur_amount'] / 10000.0)\n            total_fees += fee\n        else:\n            # Fallback or error if no rule matches? \n            # In a real scenario, we might log this. For now, assume 0 or skip.\n            pass\n\n    print(f\"{total_fees:.2f}\")",
    "execution_output": "4.39\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter for rows where the `merchant` is 'Martinis_Fine_Steakhouse', the `day_of_year` is 365, and the `year` is 2023.",
      "Load `merchant_data.json` to retrieve the `account_type`, `merchant_category_code`, and `capture_delay` for 'Martinis_Fine_Steakhouse', and simultaneously load `payments.csv` to calculate the total `eur_amount` (monthly volume) and fraud rate (fraud volume / total volume) for this merchant for the entire month of December 2023 (day_of_year 335 to 365)."
    ]
  },
  {
    "round": 3,
    "plan_steps": 3,
    "code_length": 9170,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except ValueError:\n            return 0.0\n    return 0.0\n\ndef parse_volume_string(vol_str):\n    \"\"\"Parses volume strings like '100k-1m' into (min, max) tuple.\"\"\"\n    if not vol_str:\n        return None\n    \n    def parse_val(s):\n        s = s.lower().strip()\n        mult = 1\n        if 'k' in s:\n            mult = 1000\n            s = s.replace('k', '')\n        elif 'm' in s:\n            mult = 1_000_000\n            s = s.replace('m', '')\n        try:\n            return float(s) * mult\n        except:\n            return 0.0\n\n    try:\n        if '-' in vol_str:\n            parts = vol_str.split('-')\n            return (parse_val(parts[0]), parse_val(parts[1]))\n        elif '>' in vol_str:\n            val = parse_val(vol_str.replace('>', ''))\n            return (val, float('inf'))\n        elif '<' in vol_str:\n            val = parse_val(vol_str.replace('<', ''))\n            return (0, val)\n    except:\n        return None\n    return None\n\ndef parse_fraud_string(fraud_str):\n    \"\"\"Parses fraud strings like '7.7%-8.3%' into (min, max) tuple.\"\"\"\n    if not fraud_str:\n        return None\n    \n    def parse_pct(s):\n        s = s.strip().replace('%', '')\n        try:\n            return float(s) / 100.0\n        except:\n            return 0.0\n\n    try:\n        if '-' in fraud_str:\n            parts = fraud_str.split('-')\n            return (parse_pct(parts[0]), parse_pct(parts[1]))\n        elif '>' in fraud_str:\n            val = parse_pct(fraud_str.replace('>', ''))\n            return (val, float('inf'))\n        elif '<' in fraud_str:\n            val = parse_pct(fraud_str.replace('<', ''))\n            return (0, val)\n    except:\n        return None\n    return None\n\ndef check_capture_delay(merchant_delay, rule_delay):\n    \"\"\"Matches merchant capture delay against rule criteria.\"\"\"\n    if rule_delay is None:\n        return True\n    \n    # Normalize inputs\n    md = str(merchant_delay).lower().strip()\n    rd = str(rule_delay).lower().strip()\n    \n    if rd == 'immediate':\n        return md == 'immediate'\n    if rd == 'manual':\n        return md == 'manual'\n    \n    # Numeric checks\n    try:\n        # If merchant delay is numeric (e.g., \"1\")\n        if md.isdigit():\n            md_val = int(md)\n            if '-' in rd:\n                low, high = map(int, rd.split('-'))\n                return low <= md_val <= high\n            if rd.startswith('>'):\n                return md_val > int(rd[1:])\n            if rd.startswith('<'):\n                return md_val < int(rd[1:])\n    except:\n        pass\n        \n    return False\n\ndef match_fee_rule(tx_context, rule):\n    \"\"\"\n    Determines if a fee rule applies to a specific transaction context.\n    \"\"\"\n    \n    # 1. Card Scheme (Exact match required)\n    if rule.get('card_scheme') != tx_context['card_scheme']:\n        return False\n\n    # 2. Account Type (List match or Wildcard)\n    if rule.get('account_type') and len(rule['account_type']) > 0:\n        if tx_context['account_type'] not in rule['account_type']:\n            return False\n\n    # 3. Merchant Category Code (List match or Wildcard)\n    if rule.get('merchant_category_code') and len(rule['merchant_category_code']) > 0:\n        if tx_context['merchant_category_code'] not in rule['merchant_category_code']:\n            return False\n\n    # 4. Is Credit (Boolean match or Wildcard)\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != tx_context['is_credit']:\n            return False\n\n    # 5. ACI (List match or Wildcard)\n    if rule.get('aci') and len(rule['aci']) > 0:\n        if tx_context['aci'] not in rule['aci']:\n            return False\n\n    # 6. Intracountry (Boolean match or Wildcard)\n    # Intracountry: Issuer Country == Acquirer Country\n    is_intra = (tx_context['issuing_country'] == tx_context['acquirer_country'])\n    if rule.get('intracountry') is not None:\n        # rule['intracountry'] is 0.0 or 1.0 in JSON\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != is_intra:\n            return False\n\n    # 7. Capture Delay (Complex match or Wildcard)\n    if rule.get('capture_delay'):\n        if not check_capture_delay(tx_context['capture_delay'], rule['capture_delay']):\n            return False\n\n    # 8. Monthly Volume (Range match or Wildcard)\n    if rule.get('monthly_volume'):\n        vol_range = parse_volume_string(rule['monthly_volume'])\n        if vol_range:\n            if not (vol_range[0] <= tx_context['monthly_volume'] < vol_range[1]):\n                return False\n\n    # 9. Monthly Fraud Level (Range match or Wildcard)\n    if rule.get('monthly_fraud_level'):\n        fraud_range = parse_fraud_string(rule['monthly_fraud_level'])\n        if fraud_range:\n            # tx_context['monthly_fraud_rate'] is a ratio (e.g. 0.08)\n            # fraud_range is (0.077, 0.083)\n            if not (fraud_range[0] <= tx_context['monthly_fraud_rate'] <= fraud_range[1]):\n                return False\n\n    return True\n\n# ---------------------------------------------------------\n# MAIN EXECUTION\n# ---------------------------------------------------------\n\n# 1. Load Data\npayments_path = '/output/chunk3/data/context/payments.csv'\nmerchant_path = '/output/chunk3/data/context/merchant_data.json'\nfees_path = '/output/chunk3/data/context/fees.json'\n\ndf_payments = pd.read_csv(payments_path)\nwith open(merchant_path, 'r') as f:\n    merchant_data = json.load(f)\nwith open(fees_path, 'r') as f:\n    fees_data = json.load(f)\n\n# 2. Get Merchant Metadata\ntarget_merchant = 'Martinis_Fine_Steakhouse'\nmerchant_info = next((item for item in merchant_data if item[\"merchant\"] == target_merchant), None)\n\nif not merchant_info:\n    print(f\"Error: Merchant {target_merchant} not found in merchant_data.json\")\nelse:\n    # 3. Calculate Monthly Stats for December 2023\n    # December is days 335 to 365 (inclusive) in a non-leap year\n    dec_start = 335\n    dec_end = 365\n    \n    df_december = df_payments[\n        (df_payments['merchant'] == target_merchant) &\n        (df_payments['year'] == 2023) &\n        (df_payments['day_of_year'] >= dec_start) &\n        (df_payments['day_of_year'] <= dec_end)\n    ]\n    \n    monthly_volume = df_december['eur_amount'].sum()\n    \n    # Fraud Volume / Total Volume\n    fraud_volume = df_december[df_december['has_fraudulent_dispute']]['eur_amount'].sum()\n    \n    if monthly_volume > 0:\n        monthly_fraud_rate = fraud_volume / monthly_volume\n    else:\n        monthly_fraud_rate = 0.0\n\n    # 4. Filter Transactions for Day 365\n    df_target_day = df_payments[\n        (df_payments['merchant'] == target_merchant) &\n        (df_payments['year'] == 2023) &\n        (df_payments['day_of_year'] == 365)\n    ]\n\n    # 5. Calculate Fees\n    total_fees = 0.0\n    \n    # Pre-prepare context that doesn't change per transaction\n    base_context = {\n        'account_type': merchant_info['account_type'],\n        'merchant_category_code': merchant_info['merchant_category_code'],\n        'capture_delay': merchant_info['capture_delay'],\n        'monthly_volume': monthly_volume,\n        'monthly_fraud_rate': monthly_fraud_rate\n    }\n\n    for _, tx in df_target_day.iterrows():\n        # Build full context for this transaction\n        tx_context = base_context.copy()\n        tx_context['card_scheme'] = tx['card_scheme']\n        tx_context['is_credit'] = tx['is_credit']\n        tx_context['aci'] = tx['aci']\n        tx_context['issuing_country'] = tx['issuing_country']\n        tx_context['acquirer_country'] = tx['acquirer_country']\n        \n        # Find matching rule\n        matched_rule = None\n        # Iterate through rules in order. The problem doesn't specify priority, \n        # but typically in rule engines, the first match or most specific match wins.\n        # Given the structure, we'll assume the dataset is ordered or first match is sufficient.\n        for rule in fees_data:\n            if match_fee_rule(tx_context, rule):\n                matched_rule = rule\n                break \n        \n        if matched_rule:\n            # Fee = Fixed + (Rate * Amount / 10000)\n            fee = matched_rule['fixed_amount'] + (matched_rule['rate'] * tx['eur_amount'] / 10000.0)\n            total_fees += fee\n        else:\n            # If no rule matches, we skip or log. \n            # In this context, we assume coverage.\n            pass\n\n    print(f\"{total_fees:.2f}\")",
    "execution_output": "4.39\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "sufficient",
    "temperature": 0.2,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter for rows where the `merchant` is 'Martinis_Fine_Steakhouse', the `day_of_year` is 365, and the `year` is 2023.",
      "Load `merchant_data.json` to retrieve the `account_type`, `merchant_category_code`, and `capture_delay` for 'Martinis_Fine_Steakhouse', and simultaneously load `payments.csv` to calculate the total `eur_amount` (monthly volume) and fraud rate (fraud volume / total volume) for this merchant for the entire month of December 2023 (day_of_year 335 to 365).",
      "Load `fees.json`, `merchant_data.json`, and `payments.csv`, then for 'Martinis_Fine_Steakhouse':\n1. Retrieve static merchant details (`account_type`, `merchant_category_code`, `capture_delay`) from `merchant_data.json`.\n2. Calculate `monthly_volume` (sum of `eur_amount`) and `monthly_fraud_level` (sum of `eur_amount` where `has_fraudulent_dispute` is True divided by `monthly_volume`) for December 2023 (days 335-365) using `payments.csv`.\n3. Filter `payments.csv` for transactions on day 365 for this merchant.\n4. For each transaction, find the matching fee rule in `fees.json` by comparing:\n   - Merchant fields: `account_type`, `merchant_category_code`, `capture_delay` (mapping '1','2' to '<3'; '7' to '>5'), `monthly_volume`, `monthly_fraud_level`.\n   - Transaction fields: `card_scheme`, `is_credit`, `aci`, `intracountry` (True if `issuing_country` == `acquirer_country`).\n5. Calculate the fee for each transaction using `fee = fixed_amount + rate * eur_amount / 10000` and sum them to get the total fees."
    ]
  }
]