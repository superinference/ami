[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2258,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\n# Load the payments.csv file\nfile_path = '/output/chunk4/data/context/payments.csv'\ndf = pd.read_csv(file_path)\n\n# Filter for rows where card_scheme is 'GlobalCard' and is_credit is True\nglobalcard_credit_txs = df[(df['card_scheme'] == 'GlobalCard') & (df['is_credit'] == True)]\n\n# Get the total count of these transactions\ntotal_count = len(globalcard_credit_txs)\n\n# Get the first 5 rows\nfirst_5_rows = globalcard_credit_txs.head(5)\n\n# Display the results\nprint(f\"Total count of GlobalCard credit transactions: {total_count}\")\nprint(\"\\nFirst 5 rows of filtered data:\")\nprint(first_5_rows)",
    "execution_output": "Total count of GlobalCard credit transactions: 35061\n\nFirst 5 rows of filtered data:\n    psp_reference                  merchant  ... aci  acquirer_country\n11    25576144624      Golfclub_Baron_Friso  ...   D                IT\n13    39321493661  Martinis_Fine_Steakhouse  ...   D                FR\n14    15954433169                   Rafa_AI  ...   E                NL\n16    39644392406      Golfclub_Baron_Friso  ...   D                IT\n17    58125631016            Crossfit_Hanna  ...   G                NL\n\n[5 rows x 21 columns]\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter for rows where `card_scheme` is 'GlobalCard' and `is_credit` is True, then display the first 5 rows and the total count of these transactions."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 9393,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except ValueError:\n            return 0.0\n    return 0.0\n\ndef parse_range_check(value, rule_range_str):\n    \"\"\"Checks if a numeric value falls within a string range (e.g., '100k-1m', '>5').\"\"\"\n    if rule_range_str is None:\n        return True\n    \n    # Handle K/M suffixes\n    def parse_val(s):\n        s = s.lower().strip().replace('%', '')\n        mult = 1\n        if 'k' in s:\n            mult = 1000\n            s = s.replace('k', '')\n        elif 'm' in s:\n            mult = 1_000_000\n            s = s.replace('m', '')\n        return float(s) * mult\n\n    try:\n        if '-' in rule_range_str:\n            low, high = rule_range_str.split('-')\n            # Handle percentages in ranges\n            is_percent = '%' in rule_range_str\n            l = parse_val(low)\n            h = parse_val(high)\n            if is_percent:\n                l /= 100\n                h /= 100\n            return l <= value <= h\n        elif '>' in rule_range_str:\n            limit = parse_val(rule_range_str.replace('>', ''))\n            if '%' in rule_range_str: limit /= 100\n            return value > limit\n        elif '<' in rule_range_str:\n            limit = parse_val(rule_range_str.replace('<', ''))\n            if '%' in rule_range_str: limit /= 100\n            return value < limit\n        else:\n            # Exact match (unlikely for ranges but possible)\n            return value == parse_val(rule_range_str)\n    except:\n        return False\n\ndef check_capture_delay(merchant_delay, rule_delay):\n    \"\"\"Matches merchant capture delay string to rule requirement.\"\"\"\n    if rule_delay is None:\n        return True\n    \n    # Map numeric strings to integers for comparison\n    try:\n        delay_days = int(merchant_delay)\n    except ValueError:\n        delay_days = None # 'immediate' or 'manual'\n\n    if rule_delay == 'immediate':\n        return merchant_delay == 'immediate'\n    elif rule_delay == 'manual':\n        return merchant_delay == 'manual'\n    elif rule_delay == '<3':\n        return merchant_delay == 'immediate' or (delay_days is not None and delay_days < 3)\n    elif rule_delay == '>5':\n        return merchant_delay == 'manual' or (delay_days is not None and delay_days > 5)\n    elif '-' in rule_delay: # e.g. '3-5'\n        low, high = map(int, rule_delay.split('-'))\n        return delay_days is not None and low <= delay_days <= high\n    \n    return False\n\ndef get_month(day_of_year):\n    \"\"\"Returns month (1-12) from day_of_year (1-365) for non-leap year.\"\"\"\n    # Cumulative days at start of each month\n    starts = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]\n    for i, start in enumerate(starts):\n        if day_of_year <= start:\n            return i # Previous month index is the month number (1-based adjustment happens naturally)\n    return 12 # December\n\ndef get_month_from_doy(doy):\n    \"\"\"Vectorized or scalar month lookup.\"\"\"\n    # Simple approximation or exact lookup\n    months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 366]\n    for i in range(12):\n        if doy <= months[i+1]:\n            return i + 1\n    return 12\n\ndef match_fee_rule(ctx, rule):\n    \"\"\"\n    Matches a transaction context against a fee rule.\n    ctx: dict containing transaction and merchant details\n    rule: dict from fees.json\n    \"\"\"\n    # 1. Card Scheme\n    if rule.get('card_scheme') and rule['card_scheme'] != ctx['card_scheme']:\n        return False\n        \n    # 2. Is Credit (Boolean or None)\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != ctx['is_credit']:\n            return False\n            \n    # 3. Merchant Category Code (List or None)\n    if rule.get('merchant_category_code'):\n        if ctx['mcc'] not in rule['merchant_category_code']:\n            return False\n            \n    # 4. Account Type (List or None)\n    if rule.get('account_type'):\n        if ctx['account_type'] not in rule['account_type']:\n            return False\n            \n    # 5. ACI (List or None)\n    if rule.get('aci'):\n        if ctx['aci'] not in rule['aci']:\n            return False\n            \n    # 6. Intracountry (Boolean or None)\n    if rule.get('intracountry') is not None:\n        if rule['intracountry'] != ctx['intracountry']:\n            return False\n            \n    # 7. Capture Delay (String/Range or None)\n    if not check_capture_delay(ctx['capture_delay'], rule.get('capture_delay')):\n        return False\n        \n    # 8. Monthly Volume (Range or None)\n    if not parse_range_check(ctx['monthly_volume'], rule.get('monthly_volume')):\n        return False\n        \n    # 9. Monthly Fraud Level (Range or None)\n    if not parse_range_check(ctx['monthly_fraud_rate'], rule.get('monthly_fraud_level')):\n        return False\n        \n    return True\n\n# ---------------------------------------------------------\n# MAIN EXECUTION\n# ---------------------------------------------------------\n\n# 1. Load Data\nbase_path = '/output/chunk4/data/context/'\ndf_payments = pd.read_csv(base_path + 'payments.csv')\nwith open(base_path + 'fees.json', 'r') as f:\n    fees_data = json.load(f)\nwith open(base_path + 'merchant_data.json', 'r') as f:\n    merchant_data_list = json.load(f)\n\n# Convert merchant data to dict for fast lookup\nmerchant_lookup = {m['merchant']: m for m in merchant_data_list}\n\n# 2. Pre-calculate Monthly Stats per Merchant\n# Add month column\ndf_payments['month'] = df_payments['day_of_year'].apply(get_month_from_doy)\n\n# Group by Merchant and Month\nmonthly_stats = df_payments.groupby(['merchant', 'month']).agg(\n    total_volume=('eur_amount', 'sum'),\n    fraud_volume=('eur_amount', lambda x: x[df_payments.loc[x.index, 'has_fraudulent_dispute']].sum())\n).reset_index()\n\n# Calculate fraud rate (volume based)\nmonthly_stats['fraud_rate'] = monthly_stats['fraud_volume'] / monthly_stats['total_volume']\n# Handle division by zero if any (unlikely given data)\nmonthly_stats['fraud_rate'] = monthly_stats['fraud_rate'].fillna(0.0)\n\n# Create a lookup dictionary: stats_lookup[merchant][month] = {'vol': ..., 'fraud': ...}\nstats_lookup = {}\nfor _, row in monthly_stats.iterrows():\n    if row['merchant'] not in stats_lookup:\n        stats_lookup[row['merchant']] = {}\n    stats_lookup[row['merchant']][row['month']] = {\n        'volume': row['total_volume'],\n        'fraud_rate': row['fraud_rate']\n    }\n\n# 3. Filter Target Transactions\n# Question asks for \"GlobalCard\" and \"credit transactions\"\ntarget_txs = df_payments[\n    (df_payments['card_scheme'] == 'GlobalCard') & \n    (df_payments['is_credit'] == True)\n].copy()\n\nprint(f\"Processing {len(target_txs)} GlobalCard credit transactions...\")\n\n# 4. Calculate Fees for 50 EUR\ncalculated_fees = []\ntarget_amount = 50.0\n\n# Iterate through each transaction to find the applicable fee\nfor _, tx in target_txs.iterrows():\n    merchant = tx['merchant']\n    month = tx['month']\n    \n    # Get Merchant Context\n    m_static = merchant_lookup.get(merchant)\n    m_stats = stats_lookup.get(merchant, {}).get(month)\n    \n    if not m_static or not m_stats:\n        continue # Should not happen with consistent data\n        \n    # Build Context for Matching\n    ctx = {\n        'card_scheme': tx['card_scheme'],\n        'is_credit': tx['is_credit'],\n        'mcc': m_static['merchant_category_code'],\n        'account_type': m_static['account_type'],\n        'capture_delay': m_static['capture_delay'],\n        'aci': tx['aci'],\n        'intracountry': tx['issuing_country'] == tx['acquirer_country'],\n        'monthly_volume': m_stats['volume'],\n        'monthly_fraud_rate': m_stats['fraud_rate']\n    }\n    \n    # Find Matching Rule\n    # We iterate through fees and pick the first match (assuming priority or specificity is handled by order or uniqueness)\n    # In reality, fee structures often have specific precedence, but here we look for the valid rule.\n    matched_rule = None\n    for rule in fees_data:\n        if match_fee_rule(ctx, rule):\n            matched_rule = rule\n            break\n            \n    if matched_rule:\n        # Calculate Fee: fixed + rate * amount / 10000\n        # Rate is in basis points (per 10,000) usually, or specified as integer to be divided.\n        # Manual says: \"rate: integer... multiplied by the transaction value and divided by 10000\"\n        fee = matched_rule['fixed_amount'] + (matched_rule['rate'] * target_amount / 10000)\n        calculated_fees.append(fee)\n\n# 5. Calculate Average\nif calculated_fees:\n    average_fee = sum(calculated_fees) / len(calculated_fees)\n    print(f\"Average fee for 50 EUR GlobalCard credit transaction: {average_fee:.4f} EUR\")\nelse:\n    print(\"No matching fees found.\")",
    "execution_output": "Processing 35061 GlobalCard credit transactions...\nAverage fee for 50 EUR GlobalCard credit transaction: 0.4270 EUR\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter for rows where `card_scheme` is 'GlobalCard' and `is_credit` is True, then display the first 5 rows and the total count of these transactions.",
      "Load `merchant_data.json` and `fees.json` into dataframes, then using the full `payments.csv` dataset, calculate the total monthly volume and monthly fraud rate (fraudulent volume / total volume) for each merchant to determine the applicable fee tiers."
    ]
  }
]