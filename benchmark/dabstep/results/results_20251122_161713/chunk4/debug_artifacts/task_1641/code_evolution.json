[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 3400,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\nimport json\n\n# Define file paths\npayments_path = '/output/chunk4/data/context/payments.csv'\nfees_path = '/output/chunk4/data/context/fees.json'\nmerchant_data_path = '/output/chunk4/data/context/merchant_data.json'\n\n# Load the datasets\ntry:\n    # Load payments.csv\n    df_payments = pd.read_csv(payments_path)\n    print(f\"Successfully loaded payments.csv: {df_payments.shape}\")\n\n    # Load merchant_data.json\n    df_merchants = pd.read_json(merchant_data_path)\n    print(f\"Successfully loaded merchant_data.json: {df_merchants.shape}\")\n\n    # Load fees.json\n    df_fees = pd.read_json(fees_path)\n    print(f\"Successfully loaded fees.json: {df_fees.shape}\")\n\n    # PREPARATION STEP: Link Merchants to Transactions\n    # We merge payments with merchant_data to attach 'account_type' and 'merchant_category_code' to each transaction\n    df_merged = pd.merge(df_payments, df_merchants, on='merchant', how='left')\n    \n    print(\"\\nMerged DataFrame Info:\")\n    print(f\"Shape: {df_merged.shape}\")\n    print(\"Columns:\", df_merged.columns.tolist())\n\n    # Verification for the specific goal (Account Type F, GlobalCard)\n    # Filter to see if we have relevant data\n    target_subset = df_merged[\n        (df_merged['account_type'] == 'F') & \n        (df_merged['card_scheme'] == 'GlobalCard')\n    ]\n    \n    print(f\"\\nVerification: Found {len(target_subset)} transactions matching Account Type 'F' and Card Scheme 'GlobalCard'.\")\n    if not target_subset.empty:\n        print(\"Sample of matching transactions:\")\n        print(target_subset[['merchant', 'card_scheme', 'account_type', 'aci', 'is_credit', 'eur_amount', 'issuing_country', 'acquirer_country']].head())\n\nexcept Exception as e:\n    print(f\"Error loading or processing data: {e}\")",
    "execution_output": "Successfully loaded payments.csv: (138236, 21)\nSuccessfully loaded merchant_data.json: (30, 5)\nSuccessfully loaded fees.json: (1000, 12)\n\nMerged DataFrame Info:\nShape: (138236, 25)\nColumns: ['psp_reference', 'merchant', 'card_scheme', 'year', 'hour_of_day', 'minute_of_hour', 'day_of_year', 'is_credit', 'eur_amount', 'ip_country', 'issuing_country', 'device_type', 'ip_address', 'email_address', 'card_number', 'shopper_interaction', 'card_bin', 'has_fraudulent_dispute', 'is_refused_by_adyen', 'aci', 'acquirer_country', 'capture_delay', 'acquirer', 'merchant_category_code', 'account_type']\n\nVerification: Found 28888 transactions matching Account Type 'F' and Card Scheme 'GlobalCard'.\nSample of matching transactions:\n                merchant card_scheme  ... issuing_country acquirer_country\n11  Golfclub_Baron_Friso  GlobalCard  ...              NL               IT\n15        Crossfit_Hanna  GlobalCard  ...              IT               NL\n16  Golfclub_Baron_Friso  GlobalCard  ...              NL               IT\n17        Crossfit_Hanna  GlobalCard  ...              IT               NL\n28        Crossfit_Hanna  GlobalCard  ...              BE               NL\n\n[5 rows x 8 columns]\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `fees.json`, `merchant_data.json`, and `payments.csv` files into dataframes to prepare for linking merchants, transactions, and fee rules."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 7167,
    "code": "import pandas as pd\nimport numpy as np\nimport json\nimport datetime\n\n# --- Helper Functions ---\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if pd.isna(value): return 0.0\n    if isinstance(value, (int, float)): return float(value)\n    s = str(value).strip().replace(',', '').replace('\u20ac', '').replace('$', '').replace('%', '')\n    # Handle comparison operators\n    if s.startswith('>='): return float(s[2:])\n    if s.startswith('<='): return float(s[2:])\n    if s.startswith('>'): return float(s[1:])\n    if s.startswith('<'): return float(s[1:])\n    try:\n        return float(s)\n    except:\n        return 0.0\n\ndef get_month(doy, year=2023):\n    \"\"\"Returns month (1-12) from day of year.\"\"\"\n    # Simple approximation for non-leap year 2023\n    date = datetime.datetime(year, 1, 1) + datetime.timedelta(days=int(doy) - 1)\n    return date.month\n\ndef parse_range(range_str):\n    \"\"\"Parses range strings like '100k-1m', '>5', '<3', '7.7%-8.3%'.\"\"\"\n    if not isinstance(range_str, str): return None, None\n    \n    s = range_str.lower().replace('%', '').replace(',', '')\n    \n    # Handle k/m suffixes\n    def parse_val(v):\n        try:\n            if 'k' in v: return float(v.replace('k', '')) * 1000\n            if 'm' in v: return float(v.replace('m', '')) * 1000000\n            return float(v)\n        except:\n            return 0.0\n\n    if '-' in s:\n        parts = s.split('-')\n        return parse_val(parts[0]), parse_val(parts[1])\n    elif '>' in s:\n        val = parse_val(s.replace('>', '').replace('=', ''))\n        return val, float('inf')\n    elif '<' in s:\n        val = parse_val(s.replace('<', '').replace('=', ''))\n        return float('-inf'), val\n    else:\n        try:\n            val = parse_val(s)\n            return val, val\n        except:\n            return None, None\n\ndef check_capture_delay(merchant_delay, rule_delay):\n    \"\"\"Checks if merchant capture delay matches the rule.\"\"\"\n    if rule_delay is None: return True\n    # Exact match (e.g. 'manual' == 'manual')\n    if str(merchant_delay) == str(rule_delay): return True\n    \n    # Map numeric merchant delays to ranges\n    try:\n        delay_days = float(merchant_delay)\n        if rule_delay == '<3' and delay_days < 3: return True\n        if rule_delay == '>5' and delay_days > 5: return True\n        if rule_delay == '3-5' and 3 <= delay_days <= 5: return True\n    except:\n        pass\n    return False\n\ndef match_fee_rule(tx_context, rule):\n    \"\"\"Determines if a fee rule applies to a specific transaction context.\"\"\"\n    # 1. Card Scheme\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_context['card_scheme']:\n        return False\n        \n    # 2. Account Type (List)\n    if rule.get('account_type') and tx_context['account_type'] not in rule['account_type']:\n        return False\n        \n    # 3. Merchant Category Code (List)\n    if rule.get('merchant_category_code') and tx_context['mcc'] not in rule['merchant_category_code']:\n        return False\n        \n    # 4. ACI (List)\n    if rule.get('aci') and tx_context['aci'] not in rule['aci']:\n        return False\n        \n    # 5. Is Credit (Bool)\n    if rule.get('is_credit') is not None and rule['is_credit'] != tx_context['is_credit']:\n        return False\n        \n    # 6. Intracountry (Bool)\n    if rule.get('intracountry') is not None:\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != tx_context['intracountry']:\n            return False\n\n    # 7. Capture Delay\n    if not check_capture_delay(tx_context['capture_delay'], rule.get('capture_delay')):\n        return False\n\n    # 8. Monthly Volume\n    if rule.get('monthly_volume'):\n        min_v, max_v = parse_range(rule['monthly_volume'])\n        vol = tx_context['monthly_volume']\n        if not (min_v <= vol <= max_v):\n            return False\n\n    # 9. Monthly Fraud Level\n    if rule.get('monthly_fraud_level'):\n        min_f, max_f = parse_range(rule['monthly_fraud_level'])\n        # Fraud level in rule is %, e.g. 8.3. Context is ratio 0.083.\n        # We compare percentages: 8.3 vs 8.3\n        fraud_pct = tx_context['monthly_fraud_rate'] * 100\n        if not (min_f <= fraud_pct <= max_f):\n            return False\n            \n    return True\n\n# --- Main Execution ---\ntry:\n    # Load Data\n    payments = pd.read_csv('/output/chunk4/data/context/payments.csv')\n    merchant_data = pd.read_json('/output/chunk4/data/context/merchant_data.json')\n    with open('/output/chunk4/data/context/fees.json', 'r') as f:\n        fees = json.load(f)\n\n    # Merge payments with merchant data to get account_type, mcc, capture_delay\n    df = pd.merge(payments, merchant_data, on='merchant', how='left')\n\n    # 1. Calculate Derived Columns\n    df['intracountry'] = df['issuing_country'] == df['acquirer_country']\n    df['month'] = df['day_of_year'].apply(lambda x: get_month(x))\n\n    # 2. Calculate Monthly Stats per Merchant (Volume and Fraud Rate)\n    # Group by merchant, month\n    monthly_stats = df.groupby(['merchant', 'month']).agg(\n        total_volume=('eur_amount', 'sum'),\n        fraud_volume=('eur_amount', lambda x: x[df.loc[x.index, 'has_fraudulent_dispute']].sum())\n    ).reset_index()\n\n    monthly_stats['fraud_rate'] = monthly_stats['fraud_volume'] / monthly_stats['total_volume']\n    monthly_stats['fraud_rate'] = monthly_stats['fraud_rate'].fillna(0.0)\n\n    # Merge stats back to df\n    df = pd.merge(df, monthly_stats[['merchant', 'month', 'total_volume', 'fraud_rate']], on=['merchant', 'month'], how='left')\n\n    # 3. Filter for Target Transactions (Account Type F, GlobalCard)\n    target_df = df[\n        (df['account_type'] == 'F') & \n        (df['card_scheme'] == 'GlobalCard')\n    ].copy()\n\n    # 4. Calculate Fee for each transaction (Hypothetical 1234 EUR)\n    hypothetical_amount = 1234.0\n    calculated_fees = []\n\n    # Pre-filter fees to GlobalCard to speed up\n    global_card_fees = [f for f in fees if f['card_scheme'] == 'GlobalCard']\n\n    for idx, row in target_df.iterrows():\n        # Build context for rule matching\n        ctx = {\n            'card_scheme': row['card_scheme'],\n            'account_type': row['account_type'],\n            'mcc': row['merchant_category_code'],\n            'aci': row['aci'],\n            'is_credit': row['is_credit'],\n            'intracountry': row['intracountry'],\n            'capture_delay': row['capture_delay'],\n            'monthly_volume': row['total_volume'],\n            'monthly_fraud_rate': row['fraud_rate']\n        }\n        \n        # Find first matching rule\n        matched_rule = None\n        for rule in global_card_fees:\n            if match_fee_rule(ctx, rule):\n                matched_rule = rule\n                break\n                \n        if matched_rule:\n            # Fee = fixed + rate * amount / 10000\n            fee = matched_rule['fixed_amount'] + (matched_rule['rate'] * hypothetical_amount / 10000.0)\n            calculated_fees.append(fee)\n\n    # 5. Average\n    if calculated_fees:\n        avg_fee = sum(calculated_fees) / len(calculated_fees)\n        print(f\"{avg_fee:.6f}\")\n    else:\n        print(\"0.000000\")\n\nexcept Exception as e:\n    print(f\"Error: {e}\")",
    "execution_output": "8.345045\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `fees.json`, `merchant_data.json`, and `payments.csv` files into dataframes to prepare for linking merchants, transactions, and fee rules.",
      "Calculate the `intracountry` flag (True if `issuing_country` equals `acquirer_country`), determine the transaction month from `day_of_year`, and compute the total monthly volume and fraud rate (fraud amount / total amount) for each merchant; then, filter the data for Account Type 'F' and Card Scheme 'GlobalCard', merge the monthly stats, and aggregate the transactions by all fee-determining factors (merchant, aci, is_credit, intracountry, mcc, capture_delay, monthly stats) to prepare for fee rule matching."
    ]
  },
  {
    "round": 3,
    "plan_steps": 3,
    "code_length": 7838,
    "code": "import pandas as pd\nimport numpy as np\nimport json\nimport datetime\n\n# --- Helper Functions ---\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if pd.isna(value) or value is None: return 0.0\n    if isinstance(value, (int, float)): return float(value)\n    s = str(value).strip().replace(',', '').replace('\u20ac', '').replace('$', '').replace('%', '')\n    # Handle comparison operators\n    if s.startswith('>='): return float(s[2:])\n    if s.startswith('<='): return float(s[2:])\n    if s.startswith('>'): return float(s[1:])\n    if s.startswith('<'): return float(s[1:])\n    try:\n        return float(s)\n    except:\n        return 0.0\n\ndef get_month(doy, year=2023):\n    \"\"\"Returns month (1-12) from day of year.\"\"\"\n    # Simple approximation for non-leap year 2023\n    date = datetime.datetime(year, 1, 1) + datetime.timedelta(days=int(doy) - 1)\n    return date.month\n\ndef parse_range(range_str):\n    \"\"\"Parses range strings like '100k-1m', '>5', '<3', '7.7%-8.3%'.\"\"\"\n    if not isinstance(range_str, str): return None, None\n    \n    s = range_str.lower().replace('%', '').replace(',', '')\n    \n    # Handle k/m suffixes\n    def parse_val(v):\n        try:\n            if 'k' in v: return float(v.replace('k', '')) * 1000\n            if 'm' in v: return float(v.replace('m', '')) * 1000000\n            return float(v)\n        except:\n            return 0.0\n\n    if '-' in s:\n        parts = s.split('-')\n        return parse_val(parts[0]), parse_val(parts[1])\n    elif '>' in s:\n        val = parse_val(s.replace('>', '').replace('=', ''))\n        return val, float('inf')\n    elif '<' in s:\n        val = parse_val(s.replace('<', '').replace('=', ''))\n        return float('-inf'), val\n    else:\n        try:\n            val = parse_val(s)\n            return val, val\n        except:\n            return None, None\n\ndef check_capture_delay(merchant_delay, rule_delay):\n    \"\"\"Checks if merchant capture delay matches the rule.\"\"\"\n    if rule_delay is None: return True\n    # Exact match (e.g. 'manual' == 'manual')\n    if str(merchant_delay).lower() == str(rule_delay).lower(): return True\n    \n    # Map numeric merchant delays to ranges\n    try:\n        delay_days = float(merchant_delay)\n        if rule_delay == '<3' and delay_days < 3: return True\n        if rule_delay == '>5' and delay_days > 5: return True\n        if rule_delay == '3-5' and 3 <= delay_days <= 5: return True\n    except:\n        pass\n    return False\n\ndef match_fee_rule(tx_context, rule):\n    \"\"\"Determines if a fee rule applies to a specific transaction context.\"\"\"\n    # 1. Card Scheme\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_context['card_scheme']:\n        return False\n        \n    # 2. Account Type (List - Empty means wildcard)\n    if rule.get('account_type') and tx_context['account_type'] not in rule['account_type']:\n        return False\n        \n    # 3. Merchant Category Code (List - Empty means wildcard)\n    if rule.get('merchant_category_code') and tx_context['mcc'] not in rule['merchant_category_code']:\n        return False\n        \n    # 4. ACI (List - Empty means wildcard)\n    if rule.get('aci') and tx_context['aci'] not in rule['aci']:\n        return False\n        \n    # 5. Is Credit (Bool - None means wildcard)\n    if rule.get('is_credit') is not None and rule['is_credit'] != tx_context['is_credit']:\n        return False\n        \n    # 6. Intracountry (Bool - None means wildcard)\n    if rule.get('intracountry') is not None:\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != tx_context['intracountry']:\n            return False\n\n    # 7. Capture Delay\n    if not check_capture_delay(tx_context['capture_delay'], rule.get('capture_delay')):\n        return False\n\n    # 8. Monthly Volume\n    if rule.get('monthly_volume'):\n        min_v, max_v = parse_range(rule['monthly_volume'])\n        vol = tx_context['monthly_volume']\n        if not (min_v <= vol <= max_v):\n            return False\n\n    # 9. Monthly Fraud Level\n    if rule.get('monthly_fraud_level'):\n        min_f, max_f = parse_range(rule['monthly_fraud_level'])\n        # Fraud level in rule is %, e.g. 8.3. Context is ratio 0.083.\n        # We compare percentages: 8.3 vs 8.3\n        fraud_pct = tx_context['monthly_fraud_rate'] * 100\n        if not (min_f <= fraud_pct <= max_f):\n            return False\n            \n    return True\n\n# --- Main Execution ---\ntry:\n    # 1. Load Data\n    payments = pd.read_csv('/output/chunk4/data/context/payments.csv')\n    merchant_data = pd.read_json('/output/chunk4/data/context/merchant_data.json')\n    with open('/output/chunk4/data/context/fees.json', 'r') as f:\n        fees = json.load(f)\n\n    # 2. Merge payments with merchant data\n    # We need account_type, mcc, capture_delay from merchant_data\n    df = pd.merge(payments, merchant_data, on='merchant', how='left')\n\n    # 3. Calculate Derived Columns\n    # Intracountry: Issuer == Acquirer\n    df['intracountry'] = df['issuing_country'] == df['acquirer_country']\n    \n    # Month: From day_of_year\n    df['month'] = df['day_of_year'].apply(lambda x: get_month(x))\n\n    # 4. Calculate Monthly Stats per Merchant (Volume and Fraud Rate)\n    # Group by merchant, month\n    monthly_stats = df.groupby(['merchant', 'month']).agg(\n        total_volume=('eur_amount', 'sum'),\n        fraud_volume=('eur_amount', lambda x: x[df.loc[x.index, 'has_fraudulent_dispute']].sum())\n    ).reset_index()\n\n    # Calculate Fraud Rate (Volume Ratio)\n    monthly_stats['fraud_rate'] = monthly_stats['fraud_volume'] / monthly_stats['total_volume']\n    monthly_stats['fraud_rate'] = monthly_stats['fraud_rate'].fillna(0.0)\n\n    # Merge stats back to the main dataframe\n    df = pd.merge(df, monthly_stats[['merchant', 'month', 'total_volume', 'fraud_rate']], on=['merchant', 'month'], how='left')\n\n    # 5. Filter for Target Transactions\n    # Question: \"For account type F... card scheme GlobalCard\"\n    target_df = df[\n        (df['account_type'] == 'F') & \n        (df['card_scheme'] == 'GlobalCard')\n    ].copy()\n\n    # 6. Calculate Fee for each transaction (Hypothetical 1234 EUR)\n    hypothetical_amount = 1234.0\n    calculated_fees = []\n\n    # Pre-filter fees to GlobalCard to speed up matching\n    global_card_fees = [f for f in fees if f['card_scheme'] == 'GlobalCard']\n\n    for idx, row in target_df.iterrows():\n        # Build context for rule matching based on the ACTUAL transaction environment\n        ctx = {\n            'card_scheme': row['card_scheme'],\n            'account_type': row['account_type'],\n            'mcc': row['merchant_category_code'],\n            'aci': row['aci'],\n            'is_credit': row['is_credit'],\n            'intracountry': row['intracountry'],\n            'capture_delay': row['capture_delay'],\n            'monthly_volume': row['total_volume'],\n            'monthly_fraud_rate': row['fraud_rate']\n        }\n        \n        # Find the first matching rule\n        matched_rule = None\n        for rule in global_card_fees:\n            if match_fee_rule(ctx, rule):\n                matched_rule = rule\n                break\n                \n        if matched_rule:\n            # Fee = fixed + rate * amount / 10000\n            # Note: rate is an integer (e.g., 19), formula is rate * value / 10000\n            fee = matched_rule['fixed_amount'] + (matched_rule['rate'] * hypothetical_amount / 10000.0)\n            calculated_fees.append(fee)\n        else:\n            # If no rule matches, we skip (or could assume 0, but usually there's a fallback)\n            # In this dataset, coverage is usually complete.\n            pass\n\n    # 7. Average\n    if calculated_fees:\n        avg_fee = sum(calculated_fees) / len(calculated_fees)\n        print(f\"{avg_fee:.6f}\")\n    else:\n        print(\"0.000000\")\n\nexcept Exception as e:\n    print(f\"Error: {e}\")",
    "execution_output": "8.345045\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "sufficient",
    "temperature": 0.2,
    "plan_snapshot": [
      "Load the `fees.json`, `merchant_data.json`, and `payments.csv` files into dataframes to prepare for linking merchants, transactions, and fee rules.",
      "Calculate the `intracountry` flag (True if `issuing_country` equals `acquirer_country`), determine the transaction month from `day_of_year`, and compute the total monthly volume and fraud rate (fraud amount / total amount) for each merchant; then, filter the data for Account Type 'F' and Card Scheme 'GlobalCard', merge the monthly stats, and aggregate the transactions by all fee-determining factors (merchant, aci, is_credit, intracountry, mcc, capture_delay, monthly stats) to prepare for fee rule matching.",
      "Create a Python script to load `payments.csv`, `merchant_data.json`, and `fees.json`, filter for transactions with `account_type` 'F' and `card_scheme` 'GlobalCard', calculate derived fields (intracountry, monthly merchant volume, and monthly merchant fraud rate), match each transaction to the applicable fee rule in `fees.json` (handling ranges and wildcards), calculate the fee for a 1234 EUR transaction for each matched rule, and print the average of these fees to 6 decimal places."
    ]
  }
]