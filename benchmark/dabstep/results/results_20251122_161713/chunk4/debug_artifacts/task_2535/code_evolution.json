[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2347,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\n# Define file path\npayments_path = '/output/chunk4/data/context/payments.csv'\n\n# Load payments data\ndf_payments = pd.read_csv(payments_path)\n\n# Filter for rows where merchant is 'Crossfit_Hanna' and year is 2023\nmerchant_name = 'Crossfit_Hanna'\ntarget_year = 2023\n\nfiltered_txs = df_payments[\n    (df_payments['merchant'] == merchant_name) & \n    (df_payments['year'] == target_year)\n].copy()\n\n# Print the result to verify the step\nprint(f\"Successfully loaded and filtered transactions for {merchant_name} in {target_year}.\")\nprint(f\"Row count: {len(filtered_txs)}\")\nprint(f\"Total Volume: {filtered_txs['eur_amount'].sum():.2f}\")\nprint(\"Sample data:\")\nprint(filtered_txs.head())",
    "execution_output": "Successfully loaded and filtered transactions for Crossfit_Hanna in 2023.\nRow count: 55139\nTotal Volume: 5076636.90\nSample data:\n   psp_reference        merchant  card_scheme  year  hour_of_day  minute_of_hour  day_of_year  is_credit  eur_amount ip_country issuing_country device_type              ip_address           email_address             card_number shopper_interaction  card_bin  has_fraudulent_dispute  is_refused_by_adyen aci acquirer_country\n0    20034594130  Crossfit_Hanna       NexPay  2023           16              21           12      False      151.74         SE              SE     Windows  pKPYzJqqwB8TdpY0jiAeQw  0AKXyaTjW7H4m1hOWmOKBQ  uRofX46FuLUrSOTz8AW5UQ           Ecommerce      4802                   False                False   F               NL\n1    36926127356  Crossfit_Hanna       NexPay  2023           23              58           75      False       45.70         NL              NL       Linux  uzUknOkIqExYsWv4X14GUg  _Gm8at1k2ojYAM_wSEptNw  6vqQ89zfCeFk6s4VOoWZFQ           Ecommerce      4920                   False                False   F               NL\n3    68442235288  Crossfit_Hanna       NexPay  2023            3               5           77       True      238.42         LU              LU         iOS  3qbuXGoFldniCC6r1X8K0Q  5VW_2O6ku_0p_fLLwuC1vw  wG2VTvj2TfVG-NRDzifMHw           Ecommerce      4017                   False                False   D               NL\n4    81404384199  Crossfit_Hanna       NexPay  2023           17              30           83      False       67.13         NL              NL     Windows  9WMJJdgtop6jkkyerxMvuQ  Alb1iUIxIqlW8YUeYVGTzg  0khzuCj7aQ1e51S5vWR8gg           Ecommerce      4532                   False                False   F               NL\n5    74453982452  Crossfit_Hanna  SwiftCharge  2023            8              30           55       True       14.96         NL              NL       Linux  lRYNn2teO8RZ_ms_5Ei52Q  YunUeDIiQyoqdiDzRWvx9g  8j9y7A7UdAgWkWGV6ggaFA           Ecommerce      4017                    True                False   G               NL\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load `payments.csv` and filter for rows where `merchant` is 'Crossfit_Hanna' and `year` is 2023."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 7592,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# --- Helper Functions ---\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        return float(v)\n    return float(value)\n\ndef get_month(day_of_year):\n    \"\"\"Convert day_of_year to month (1-12) for non-leap year 2023.\"\"\"\n    # Cumulative days at start of each month\n    days = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]\n    for i, d in enumerate(days[1:], 1):\n        if day_of_year <= d:\n            return i\n    return 12\n\ndef check_volume_rule(rule_vol_str, actual_vol):\n    \"\"\"Check if actual volume falls within rule range (e.g., '100k-1m').\"\"\"\n    if not rule_vol_str:\n        return True\n    \n    s = rule_vol_str.lower().replace('\u20ac', '').strip()\n    \n    if '-' in s:\n        parts = s.split('-')\n        \n        def parse_k_m(val_str):\n            val_str = val_str.strip()\n            mult = 1\n            if 'k' in val_str:\n                mult = 1000\n                val_str = val_str.replace('k', '')\n            elif 'm' in val_str:\n                mult = 1000000\n                val_str = val_str.replace('m', '')\n            return float(val_str) * mult\n            \n        lower = parse_k_m(parts[0])\n        upper = parse_k_m(parts[1])\n        return lower <= actual_vol <= upper\n        \n    return True\n\ndef check_fraud_rule(rule_fraud_str, actual_fraud_rate):\n    \"\"\"Check if actual fraud rate falls within rule range (e.g., '>8.3%').\"\"\"\n    if not rule_fraud_str:\n        return True\n    \n    s = rule_fraud_str.strip()\n    \n    # Handle \">8.3%\"\n    if s.startswith('>'):\n        val = float(s[1:].replace('%', '')) / 100\n        return actual_fraud_rate > val\n    \n    # Handle \"7.7%-8.3%\"\n    if '-' in s:\n        parts = s.split('-')\n        low = float(parts[0].replace('%', '')) / 100\n        high = float(parts[1].replace('%', '')) / 100\n        return low <= actual_fraud_rate <= high\n        \n    return True\n\ndef match_fee_rule(ctx, rule):\n    \"\"\"Determine if a fee rule applies to a specific transaction context.\"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule['card_scheme'] != ctx['card_scheme']:\n        return False\n        \n    # 2. Account Type (List in rule: must contain ctx value)\n    if rule['account_type'] and ctx['account_type'] not in rule['account_type']:\n        return False\n            \n    # 3. Merchant Category Code (List in rule: must contain ctx value)\n    if rule['merchant_category_code'] and ctx['mcc'] not in rule['merchant_category_code']:\n        return False\n            \n    # 4. Is Credit (Bool match)\n    if rule['is_credit'] is not None and rule['is_credit'] != ctx['is_credit']:\n        return False\n            \n    # 5. ACI (List in rule: must contain ctx value)\n    if rule['aci'] and ctx['aci'] not in rule['aci']:\n        return False\n            \n    # 6. Intracountry (Bool match)\n    if rule['intracountry'] is not None and rule['intracountry'] != ctx['intracountry']:\n        return False\n            \n    # 7. Capture Delay (String/Range match)\n    if rule['capture_delay']:\n        rd = rule['capture_delay']\n        cd = str(ctx['capture_delay'])\n        \n        if rd == cd:\n            pass # Exact match (e.g., 'manual' == 'manual')\n        elif rd == '>5':\n            if not cd.isdigit() or int(cd) <= 5: return False\n        elif rd == '<3':\n            if not cd.isdigit() or int(cd) >= 3: return False\n        elif rd == '3-5':\n            if not cd.isdigit() or not (3 <= int(cd) <= 5): return False\n        elif rd in ['manual', 'immediate'] and rd != cd:\n            return False # Specific string mismatch\n        # If none of the above, assume mismatch if strings differ\n        elif rd != cd:\n            return False\n\n    # 8. Monthly Volume\n    if not check_volume_rule(rule['monthly_volume'], ctx['monthly_volume']):\n        return False\n        \n    # 9. Monthly Fraud Level\n    if not check_fraud_rule(rule['monthly_fraud_level'], ctx['monthly_fraud_rate']):\n        return False\n        \n    return True\n\ndef calculate_fee(amount, rule):\n    \"\"\"Calculate fee: Fixed + (Rate * Amount / 10000)\"\"\"\n    return rule['fixed_amount'] + (rule['rate'] * amount / 10000)\n\n# --- Main Execution ---\n\n# 1. Load Data\npayments_path = '/output/chunk4/data/context/payments.csv'\nfees_path = '/output/chunk4/data/context/fees.json'\nmerchant_path = '/output/chunk4/data/context/merchant_data.json'\n\ndf_payments = pd.read_csv(payments_path)\nwith open(fees_path, 'r') as f:\n    fees = json.load(f)\nwith open(merchant_path, 'r') as f:\n    merchant_data = json.load(f)\n\n# 2. Filter Transactions\ntarget_merchant = 'Crossfit_Hanna'\ntarget_year = 2023\ndf = df_payments[\n    (df_payments['merchant'] == target_merchant) & \n    (df_payments['year'] == target_year)\n].copy()\n\n# 3. Get Merchant Metadata\nm_info = next((m for m in merchant_data if m['merchant'] == target_merchant), None)\nif not m_info:\n    raise ValueError(f\"Merchant {target_merchant} not found in merchant_data.json\")\n\noriginal_mcc = m_info['merchant_category_code']\naccount_type = m_info['account_type']\ncapture_delay = m_info['capture_delay']\n\n# 4. Enrich Data\n# Add Month\ndf['month'] = df['day_of_year'].apply(get_month)\n\n# Add Intracountry (True if issuing == acquirer)\ndf['is_intracountry'] = df['issuing_country'] == df['acquirer_country']\n\n# Calculate Monthly Stats (Volume and Fraud Rate by Volume)\nmonthly_stats = {}\nfor month in range(1, 13):\n    month_txs = df[df['month'] == month]\n    if len(month_txs) > 0:\n        vol = month_txs['eur_amount'].sum()\n        # Fraud Rate = Fraud Volume / Total Volume (per Manual Section 7)\n        fraud_vol = month_txs[month_txs['has_fraudulent_dispute']]['eur_amount'].sum()\n        fraud_rate = fraud_vol / vol if vol > 0 else 0.0\n        \n        monthly_stats[month] = {\n            'volume': vol,\n            'fraud_rate': fraud_rate\n        }\n    else:\n        monthly_stats[month] = {'volume': 0.0, 'fraud_rate': 0.0}\n\n# 5. Calculate Fees\ntotal_fees_old = 0.0\ntotal_fees_new = 0.0\nnew_mcc = 5911\n\n# Iterate through every transaction\nfor _, row in df.iterrows():\n    month = row['month']\n    stats = monthly_stats.get(month, {'volume': 0, 'fraud_rate': 0})\n    \n    # Base Context\n    ctx = {\n        'card_scheme': row['card_scheme'],\n        'account_type': account_type,\n        'is_credit': row['is_credit'],\n        'aci': row['aci'],\n        'intracountry': row['is_intracountry'],\n        'capture_delay': capture_delay,\n        'monthly_volume': stats['volume'],\n        'monthly_fraud_rate': stats['fraud_rate'],\n        'eur_amount': row['eur_amount']\n    }\n    \n    # --- Scenario 1: Original MCC ---\n    ctx['mcc'] = original_mcc\n    fee_old = 0.0\n    for rule in fees:\n        if match_fee_rule(ctx, rule):\n            fee_old = calculate_fee(ctx['eur_amount'], rule)\n            break # Apply first matching rule\n    total_fees_old += fee_old\n    \n    # --- Scenario 2: New MCC (5911) ---\n    ctx['mcc'] = new_mcc\n    fee_new = 0.0\n    for rule in fees:\n        if match_fee_rule(ctx, rule):\n            fee_new = calculate_fee(ctx['eur_amount'], rule)\n            break # Apply first matching rule\n    total_fees_new += fee_new\n\n# 6. Calculate Delta\n# Delta = New Fees - Old Fees\ndelta = total_fees_new - total_fees_old\n\n# Output with high precision\nprint(f\"{delta:.14f}\")",
    "execution_output": "3498.80741300003865\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load `payments.csv` and filter for rows where `merchant` is 'Crossfit_Hanna' and `year` is 2023.",
      "Load `merchant_data.json` and `fees.json`, then using the filtered transaction data, calculate the monthly total volume and monthly fraud rate (fraud volume / total volume) for the merchant 'Crossfit_Hanna' in 2023, and add an 'intracountry' column (True if issuing_country equals acquirer_country) and a 'month' column to the transactions."
    ]
  },
  {
    "round": 3,
    "plan_steps": 3,
    "code_length": 8465,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# --- Helper Functions ---\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        return float(v)\n    return float(value)\n\ndef get_month(day_of_year):\n    \"\"\"Convert day_of_year to month (1-12) for non-leap year 2023.\"\"\"\n    # Cumulative days at start of each month\n    days = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]\n    for i, d in enumerate(days[1:], 1):\n        if day_of_year <= d:\n            return i\n    return 12\n\ndef check_volume_rule(rule_vol_str, actual_vol):\n    \"\"\"Check if actual volume falls within rule range (e.g., '100k-1m').\"\"\"\n    if not rule_vol_str:\n        return True\n    \n    s = rule_vol_str.lower().replace('\u20ac', '').strip()\n    \n    if '-' in s:\n        parts = s.split('-')\n        \n        def parse_k_m(val_str):\n            val_str = val_str.strip()\n            mult = 1\n            if 'k' in val_str:\n                mult = 1000\n                val_str = val_str.replace('k', '')\n            elif 'm' in val_str:\n                mult = 1000000\n                val_str = val_str.replace('m', '')\n            return float(val_str) * mult\n            \n        lower = parse_k_m(parts[0])\n        upper = parse_k_m(parts[1])\n        return lower <= actual_vol <= upper\n        \n    return True\n\ndef check_fraud_rule(rule_fraud_str, actual_fraud_rate):\n    \"\"\"Check if actual fraud rate falls within rule range (e.g., '>8.3%').\"\"\"\n    if not rule_fraud_str:\n        return True\n    \n    s = rule_fraud_str.strip()\n    \n    # Handle \">8.3%\"\n    if s.startswith('>'):\n        val = float(s[1:].replace('%', '')) / 100\n        return actual_fraud_rate > val\n    \n    # Handle \"7.7%-8.3%\"\n    if '-' in s:\n        parts = s.split('-')\n        low = float(parts[0].replace('%', '')) / 100\n        high = float(parts[1].replace('%', '')) / 100\n        return low <= actual_fraud_rate <= high\n        \n    return True\n\ndef match_fee_rule(ctx, rule):\n    \"\"\"Determine if a fee rule applies to a specific transaction context.\"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule['card_scheme'] != ctx['card_scheme']:\n        return False\n        \n    # 2. Account Type (List in rule: must contain ctx value)\n    # If rule['account_type'] is empty/null, it applies to ALL account types\n    if rule['account_type'] and ctx['account_type'] not in rule['account_type']:\n        return False\n            \n    # 3. Merchant Category Code (List in rule: must contain ctx value)\n    # If rule['merchant_category_code'] is empty/null, it applies to ALL MCCs\n    if rule['merchant_category_code'] and ctx['mcc'] not in rule['merchant_category_code']:\n        return False\n            \n    # 4. Is Credit (Bool match)\n    # If rule['is_credit'] is None, it applies to BOTH credit and debit\n    if rule['is_credit'] is not None and rule['is_credit'] != ctx['is_credit']:\n        return False\n            \n    # 5. ACI (List in rule: must contain ctx value)\n    # If rule['aci'] is empty/null, it applies to ALL ACIs\n    if rule['aci'] and ctx['aci'] not in rule['aci']:\n        return False\n            \n    # 6. Intracountry (Bool match)\n    # If rule['intracountry'] is None, it applies to BOTH\n    if rule['intracountry'] is not None:\n        # Convert rule value to bool for comparison (0.0 -> False, 1.0 -> True)\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != ctx['intracountry']:\n            return False\n            \n    # 7. Capture Delay (String/Range match)\n    if rule['capture_delay']:\n        rd = rule['capture_delay']\n        cd = str(ctx['capture_delay'])\n        \n        if rd == cd:\n            pass # Exact match (e.g., 'manual' == 'manual')\n        elif rd == '>5':\n            if not cd.isdigit() or int(cd) <= 5: return False\n        elif rd == '<3':\n            if not cd.isdigit() or int(cd) >= 3: return False\n        elif rd == '3-5':\n            if not cd.isdigit() or not (3 <= int(cd) <= 5): return False\n        elif rd in ['manual', 'immediate'] and rd != cd:\n            return False # Specific string mismatch\n        # If none of the above, assume mismatch if strings differ\n        elif rd != cd:\n            return False\n\n    # 8. Monthly Volume\n    if not check_volume_rule(rule['monthly_volume'], ctx['monthly_volume']):\n        return False\n        \n    # 9. Monthly Fraud Level\n    if not check_fraud_rule(rule['monthly_fraud_level'], ctx['monthly_fraud_rate']):\n        return False\n        \n    return True\n\ndef calculate_fee(amount, rule):\n    \"\"\"Calculate fee: Fixed + (Rate * Amount / 10000)\"\"\"\n    return rule['fixed_amount'] + (rule['rate'] * amount / 10000)\n\n# --- Main Execution ---\n\n# 1. Load Data\npayments_path = '/output/chunk4/data/context/payments.csv'\nfees_path = '/output/chunk4/data/context/fees.json'\nmerchant_path = '/output/chunk4/data/context/merchant_data.json'\n\ndf_payments = pd.read_csv(payments_path)\nwith open(fees_path, 'r') as f:\n    fees = json.load(f)\nwith open(merchant_path, 'r') as f:\n    merchant_data = json.load(f)\n\n# 2. Filter Transactions\ntarget_merchant = 'Crossfit_Hanna'\ntarget_year = 2023\ndf = df_payments[\n    (df_payments['merchant'] == target_merchant) & \n    (df_payments['year'] == target_year)\n].copy()\n\n# 3. Get Merchant Metadata\nm_info = next((m for m in merchant_data if m['merchant'] == target_merchant), None)\nif not m_info:\n    raise ValueError(f\"Merchant {target_merchant} not found in merchant_data.json\")\n\noriginal_mcc = m_info['merchant_category_code']\naccount_type = m_info['account_type']\ncapture_delay = m_info['capture_delay']\n\n# 4. Enrich Data\n# Add Month\ndf['month'] = df['day_of_year'].apply(get_month)\n\n# Add Intracountry (True if issuing == acquirer)\ndf['is_intracountry'] = df['issuing_country'] == df['acquirer_country']\n\n# Calculate Monthly Stats (Volume and Fraud Rate by Volume)\nmonthly_stats = {}\nfor month in range(1, 13):\n    month_txs = df[df['month'] == month]\n    if len(month_txs) > 0:\n        vol = month_txs['eur_amount'].sum()\n        # Fraud Rate = Fraud Volume / Total Volume (per Manual Section 7)\n        fraud_vol = month_txs[month_txs['has_fraudulent_dispute']]['eur_amount'].sum()\n        fraud_rate = fraud_vol / vol if vol > 0 else 0.0\n        \n        monthly_stats[month] = {\n            'volume': vol,\n            'fraud_rate': fraud_rate\n        }\n    else:\n        monthly_stats[month] = {'volume': 0.0, 'fraud_rate': 0.0}\n\n# 5. Calculate Fees\ntotal_fees_old = 0.0\ntotal_fees_new = 0.0\nnew_mcc = 5911\n\n# Iterate through every transaction\nfor _, row in df.iterrows():\n    month = row['month']\n    stats = monthly_stats.get(month, {'volume': 0, 'fraud_rate': 0})\n    \n    # Base Context\n    ctx = {\n        'card_scheme': row['card_scheme'],\n        'account_type': account_type,\n        'is_credit': row['is_credit'],\n        'aci': row['aci'],\n        'intracountry': row['is_intracountry'],\n        'capture_delay': capture_delay,\n        'monthly_volume': stats['volume'],\n        'monthly_fraud_rate': stats['fraud_rate'],\n        'eur_amount': row['eur_amount']\n    }\n    \n    # --- Scenario 1: Original MCC ---\n    ctx['mcc'] = original_mcc\n    fee_old = 0.0\n    found_old = False\n    for rule in fees:\n        if match_fee_rule(ctx, rule):\n            fee_old = calculate_fee(ctx['eur_amount'], rule)\n            found_old = True\n            break # Apply first matching rule\n    \n    # Fallback if no rule matches (should not happen with complete ruleset, but good for safety)\n    if not found_old:\n        # Assuming 0 or some default if no rule matches, but typically one should match.\n        # For this exercise, we assume coverage.\n        pass\n        \n    total_fees_old += fee_old\n    \n    # --- Scenario 2: New MCC (5911) ---\n    ctx['mcc'] = new_mcc\n    fee_new = 0.0\n    found_new = False\n    for rule in fees:\n        if match_fee_rule(ctx, rule):\n            fee_new = calculate_fee(ctx['eur_amount'], rule)\n            found_new = True\n            break # Apply first matching rule\n            \n    total_fees_new += fee_new\n\n# 6. Calculate Delta\n# Delta = New Fees - Old Fees\ndelta = total_fees_new - total_fees_old\n\n# Output with high precision\nprint(f\"{delta:.14f}\")",
    "execution_output": "3498.80741300003865\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "sufficient",
    "temperature": 0.2,
    "plan_snapshot": [
      "Load `payments.csv` and filter for rows where `merchant` is 'Crossfit_Hanna' and `year` is 2023.",
      "Load `merchant_data.json` and `fees.json`, then using the filtered transaction data, calculate the monthly total volume and monthly fraud rate (fraud volume / total volume) for the merchant 'Crossfit_Hanna' in 2023, and add an 'intracountry' column (True if issuing_country equals acquirer_country) and a 'month' column to the transactions.",
      "Load `payments.csv`, `merchant_data.json`, and `fees.json`, filter for 'Crossfit_Hanna' transactions in 2023, calculate monthly volume and fraud rates, then for each transaction calculate the fee difference by applying the fee rules using the original MCC versus the hypothetical MCC 5911, and finally sum these differences to find the total amount delta."
    ]
  }
]