[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2935,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\nimport json\n\n# Define file paths\npayments_path = '/output/chunk2/data/context/payments.csv'\nmerchant_data_path = '/output/chunk2/data/context/merchant_data.json'\n\n# Load payments data\ndf_payments = pd.read_csv(payments_path)\n\n# Filter for merchant 'Golfclub_Baron_Friso' and year 2023\nmerchant_name = 'Golfclub_Baron_Friso'\ntarget_year = 2023\n\nfiltered_payments = df_payments[\n    (df_payments['merchant'] == merchant_name) & \n    (df_payments['year'] == target_year)\n]\n\n# Calculate average eur_amount\naverage_amount = filtered_payments['eur_amount'].mean()\n\n# Load merchant metadata\nwith open(merchant_data_path, 'r') as f:\n    merchant_data_list = json.load(f)\n\n# Retrieve specific metadata for the merchant\nmerchant_metadata = {}\nfor entry in merchant_data_list:\n    if entry['merchant'] == merchant_name:\n        merchant_metadata = {\n            'merchant_category_code': entry.get('merchant_category_code'),\n            'account_type': entry.get('account_type'),\n            'acquirer': entry.get('acquirer')\n        }\n        break\n\n# Output the results\nprint(f\"Merchant: {merchant_name}\")\nprint(f\"Year: {target_year}\")\nprint(f\"Transaction Count: {len(filtered_payments)}\")\nprint(f\"Average EUR Amount: {average_amount}\")\nprint(f\"Metadata: {merchant_metadata}\")",
    "execution_output": "Merchant: Golfclub_Baron_Friso\nYear: 2023\nTransaction Count: 27748\nAverage EUR Amount: 92.0203481331988\nMetadata: {'merchant_category_code': 7993, 'account_type': 'F', 'acquirer': ['medici']}\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Filter the `payments.csv` dataset to include only transactions for the merchant 'Golfclub_Baron_Friso' in the year 2023, calculate the average `eur_amount`, and retrieve the merchant's metadata (specifically `merchant_category_code`, `account_type`, and `acquirer`) from `merchant_data.json`."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 7233,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ---------------------------------------------------------\n# Helper Functions\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef parse_range(range_str):\n    \"\"\"Parses a string range like '100k-1m', '<3', or '7.7%-8.3%' into (min, max).\"\"\"\n    if not isinstance(range_str, str):\n        return None, None\n    \n    s = range_str.lower().strip()\n    multiplier = 1\n    if 'k' in s: multiplier = 1000\n    if 'm' in s: multiplier = 1000000\n    \n    # Remove units for parsing\n    clean_s = s.replace('k', '').replace('m', '').replace('%', '')\n    \n    if '-' in clean_s:\n        parts = clean_s.split('-')\n        try:\n            return float(parts[0]) * multiplier, float(parts[1]) * multiplier\n        except:\n            return None, None\n    elif '<' in s: # Use original s to detect operator\n        try:\n            val = float(clean_s.replace('<', '')) * multiplier\n            return float('-inf'), val\n        except:\n            return None, None\n    elif '>' in s:\n        try:\n            val = float(clean_s.replace('>', '')) * multiplier\n            return val, float('inf')\n        except:\n            return None, None\n    elif s == 'immediate':\n        return 0, 0\n    else:\n        try:\n            val = float(clean_s) * multiplier\n            return val, val\n        except:\n            return None, None\n\ndef check_overlap(val, range_str, is_percentage=False):\n    \"\"\"Checks if a numeric value falls within a range string.\"\"\"\n    if range_str is None: return True # Wildcard matches all\n    \n    # Handle specific keywords\n    if range_str == 'immediate' and val == 0: return True\n    if range_str == 'manual': return True # Assuming manual matches manual context\n    \n    # Parse range\n    min_v, max_v = parse_range(range_str)\n    if min_v is None: return False \n    \n    # Adjust value for percentage comparison if the range was a percentage\n    check_val = val\n    if is_percentage and '%' in range_str:\n        # Example: range \"8%\", val 0.08. parse_range returns 8. check_val should be 8.\n        check_val = val * 100\n        \n    return min_v <= check_val <= max_v\n\ndef match_fee_rule(merchant_ctx, rule):\n    \"\"\"Determines if a fee rule applies to a merchant's fixed attributes.\"\"\"\n    \n    # 1. Merchant Category Code (List match)\n    if rule.get('merchant_category_code'):\n        # If rule has MCC list, merchant's MCC must be in it\n        if merchant_ctx['mcc'] not in rule['merchant_category_code']:\n            return False\n            \n    # 2. Account Type (List match)\n    if rule.get('account_type'):\n        # If rule has Account Type list, merchant's type must be in it\n        if merchant_ctx['account_type'] not in rule['account_type']:\n            return False\n            \n    # 3. Monthly Volume (Range match)\n    if rule.get('monthly_volume'):\n        if not check_overlap(merchant_ctx['monthly_volume'], rule['monthly_volume']):\n            return False\n            \n    # 4. Monthly Fraud Level (Range match)\n    if rule.get('monthly_fraud_level'):\n        if not check_overlap(merchant_ctx['fraud_rate'], rule['monthly_fraud_level'], is_percentage=True):\n            return False\n            \n    # 5. Capture Delay (Range/Exact match)\n    if rule.get('capture_delay'):\n        m_delay = merchant_ctx['capture_delay']\n        # Convert merchant delay to number if possible for comparison\n        try:\n            m_delay_num = float(m_delay)\n        except:\n            m_delay_num = 0 if m_delay == 'immediate' else 999 # 999 for manual\n            \n        if not check_overlap(m_delay_num, rule['capture_delay']):\n            return False\n\n    return True\n\n# ---------------------------------------------------------\n# Main Execution\n# ---------------------------------------------------------\n\n# File Paths\npayments_path = '/output/chunk2/data/context/payments.csv'\nmerchant_data_path = '/output/chunk2/data/context/merchant_data.json'\nfees_path = '/output/chunk2/data/context/fees.json'\nacquirer_path = '/output/chunk2/data/context/acquirer_countries.csv'\n\n# Load Data\ndf_payments = pd.read_csv(payments_path)\nwith open(merchant_data_path, 'r') as f:\n    merchant_data = json.load(f)\nwith open(fees_path, 'r') as f:\n    fees = json.load(f)\ndf_acquirer = pd.read_csv(acquirer_path)\n\n# Target\ntarget_merchant = 'Golfclub_Baron_Friso'\ntarget_year = 2023\n\n# 1. Get Merchant Metadata\nmerchant_info = next((m for m in merchant_data if m['merchant'] == target_merchant), None)\nif not merchant_info:\n    raise ValueError(f\"Merchant {target_merchant} not found in metadata.\")\n\nmcc = merchant_info['merchant_category_code']\naccount_type = merchant_info['account_type']\ncapture_delay = merchant_info['capture_delay']\n\n# 2. Calculate Merchant Statistics (2023)\n# Filter payments\ndf_m = df_payments[(df_payments['merchant'] == target_merchant) & (df_payments['year'] == target_year)]\n\n# Calculate Average Amount\navg_amount = df_m['eur_amount'].mean()\n\n# Calculate Monthly Volume (Total 2023 Volume / 12)\ntotal_volume = df_m['eur_amount'].sum()\nmonthly_volume = total_volume / 12\n\n# Calculate Fraud Rate (Count of fraud / Total txs)\nfraud_count = df_m['has_fraudulent_dispute'].sum()\ntx_count = len(df_m)\nfraud_rate = fraud_count / tx_count if tx_count > 0 else 0.0\n\n# Context for matching rules\nmerchant_ctx = {\n    'mcc': mcc,\n    'account_type': account_type,\n    'monthly_volume': monthly_volume,\n    'fraud_rate': fraud_rate,\n    'capture_delay': capture_delay\n}\n\n# 3. Evaluate Fees per Scheme\nmax_fees_by_scheme = {}\n\nfor rule in fees:\n    # Check if rule applies to the merchant's fixed profile\n    if match_fee_rule(merchant_ctx, rule):\n        scheme = rule['card_scheme']\n        \n        # Calculate Fee for this rule\n        # Fee = Fixed + (Rate * Amount / 10000)\n        fixed = rule['fixed_amount']\n        rate = rule['rate']\n        fee = fixed + (rate * avg_amount / 10000)\n        \n        # We want the MAXIMUM fee possible for this scheme.\n        # Since we are \"steering traffic\", we assume we might hit the most expensive \n        # transaction type (Credit/Debit, Domestic/Intl) allowed by the scheme's rules.\n        if scheme not in max_fees_by_scheme:\n            max_fees_by_scheme[scheme] = 0.0\n        \n        if fee > max_fees_by_scheme[scheme]:\n            max_fees_by_scheme[scheme] = fee\n\n# 4. Determine Winner\n# Sort by fee descending\nsorted_schemes = sorted(max_fees_by_scheme.items(), key=lambda x: x[1], reverse=True)\n\nif sorted_schemes:\n    winner_scheme = sorted_schemes[0][0]\n    print(winner_scheme)\nelse:\n    print(\"No applicable schemes found\")",
    "execution_output": "TransactPlus\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Filter the `payments.csv` dataset to include only transactions for the merchant 'Golfclub_Baron_Friso' in the year 2023, calculate the average `eur_amount`, and retrieve the merchant's metadata (specifically `merchant_category_code`, `account_type`, and `acquirer`) from `merchant_data.json`.",
      "Load `acquirer_countries.csv` to determine the country for the acquirer 'medici', then load `fees.json` and calculate the maximum fee for each card scheme ('NexPay', 'GlobalCard', 'SwiftCharge', 'TransactPlus') using the average transaction amount of 92.02 EUR, filtering for rules applicable to the merchant's metadata (MCC 7993, Account Type 'F')."
    ]
  },
  {
    "round": 3,
    "plan_steps": 2,
    "code_length": 8675,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ---------------------------------------------------------\n# Helper Functions\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float, np.number)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except:\n            return 0.0\n    return 0.0\n\ndef parse_range(range_str):\n    \"\"\"Parses a string range like '100k-1m', '<3', or '7.7%-8.3%' into (min, max).\"\"\"\n    if not isinstance(range_str, str):\n        return None, None\n    \n    s = range_str.lower().strip()\n    multiplier = 1\n    if 'k' in s: multiplier = 1000\n    if 'm' in s: multiplier = 1000000\n    \n    # Remove units for parsing\n    clean_s = s.replace('k', '').replace('m', '').replace('%', '')\n    \n    is_percentage = '%' in s\n    \n    if '-' in clean_s:\n        parts = clean_s.split('-')\n        try:\n            v1 = float(parts[0])\n            v2 = float(parts[1])\n            if is_percentage:\n                v1 /= 100\n                v2 /= 100\n            else:\n                v1 *= multiplier\n                v2 *= multiplier\n            return v1, v2\n        except:\n            return None, None\n    elif '<' in s:\n        try:\n            val = float(clean_s.replace('<', ''))\n            if is_percentage: val /= 100\n            else: val *= multiplier\n            return float('-inf'), val\n        except:\n            return None, None\n    elif '>' in s:\n        try:\n            val = float(clean_s.replace('>', ''))\n            if is_percentage: val /= 100\n            else: val *= multiplier\n            return val, float('inf')\n        except:\n            return None, None\n    elif s == 'immediate':\n        return 0, 0\n    else:\n        try:\n            val = float(clean_s)\n            if is_percentage: val /= 100\n            else: val *= multiplier\n            return val, val\n        except:\n            return None, None\n\ndef check_overlap(val, range_str):\n    \"\"\"Checks if a numeric value falls within a range string.\"\"\"\n    if range_str is None: return True # Wildcard matches all\n    \n    # Handle specific keywords\n    if range_str == 'immediate' and val == 0: return True\n    if range_str == 'manual': return True \n    \n    # Parse range\n    min_v, max_v = parse_range(range_str)\n    if min_v is None: return False \n    \n    return min_v <= val <= max_v\n\n# ---------------------------------------------------------\n# Main Execution\n# ---------------------------------------------------------\n\n# File Paths\npayments_path = '/output/chunk2/data/context/payments.csv'\nmerchant_data_path = '/output/chunk2/data/context/merchant_data.json'\nfees_path = '/output/chunk2/data/context/fees.json'\n\n# Load Data\ndf_payments = pd.read_csv(payments_path)\nwith open(merchant_data_path, 'r') as f:\n    merchant_data = json.load(f)\nwith open(fees_path, 'r') as f:\n    fees = json.load(f)\n\n# Target\ntarget_merchant = 'Golfclub_Baron_Friso'\ntarget_year = 2023\n\n# 1. Get Merchant Metadata\nmerchant_info = next((m for m in merchant_data if m['merchant'] == target_merchant), None)\nif not merchant_info:\n    raise ValueError(f\"Merchant {target_merchant} not found in metadata.\")\n\nmcc = merchant_info['merchant_category_code']\naccount_type = merchant_info['account_type']\ncapture_delay = merchant_info['capture_delay']\n\n# 2. Calculate Merchant Statistics (2023)\ndf_m = df_payments[(df_payments['merchant'] == target_merchant) & (df_payments['year'] == target_year)]\n\nif df_m.empty:\n    print(\"No transactions found\")\n    exit()\n\n# Calculate Monthly Volume (Total 2023 Volume / 12)\ntotal_volume = df_m['eur_amount'].sum()\nmonthly_volume = total_volume / 12\n\n# Calculate Fraud Rate (Count of fraud / Total txs)\nfraud_count = df_m['has_fraudulent_dispute'].sum()\ntx_count = len(df_m)\nfraud_rate = fraud_count / tx_count if tx_count > 0 else 0.0\n\n# Capture Delay Numeric for comparison\ncapture_delay_val = 0\nif capture_delay == 'immediate': capture_delay_val = 0\nelif capture_delay == 'manual': capture_delay_val = 999\nelse:\n    try:\n        capture_delay_val = float(capture_delay)\n    except:\n        capture_delay_val = 999\n\n# 3. Pre-filter Fees for Merchant Profile (Static Attributes)\n# This filters rules based on MCC, Account Type, Volume, Fraud, and Delay\napplicable_rules = []\nfor rule in fees:\n    # MCC\n    if rule.get('merchant_category_code') and mcc not in rule['merchant_category_code']:\n        continue\n    # Account Type\n    if rule.get('account_type') and account_type not in rule['account_type']:\n        continue\n    # Monthly Volume\n    if rule.get('monthly_volume') and not check_overlap(monthly_volume, rule['monthly_volume']):\n        continue\n    # Monthly Fraud Level\n    if rule.get('monthly_fraud_level') and not check_overlap(fraud_rate, rule['monthly_fraud_level']):\n        continue\n    # Capture Delay\n    if rule.get('capture_delay'):\n        if rule['capture_delay'] == 'manual':\n            if capture_delay != 'manual': continue\n        elif rule['capture_delay'] == 'immediate':\n            if capture_delay != 'immediate': continue\n        else:\n            if not check_overlap(capture_delay_val, rule['capture_delay']):\n                continue\n    \n    applicable_rules.append(rule)\n\n# 4. Simulate Fees for Each Scheme\n# We calculate the total fee for the merchant's 2023 transactions AS IF they were processed by each scheme.\nschemes = ['NexPay', 'GlobalCard', 'SwiftCharge', 'TransactPlus']\nscheme_totals = {s: 0.0 for s in schemes}\n\n# Group transactions for efficiency: (is_credit, aci, issuing_country, acquirer_country)\n# We need acquirer_country to determine intracountry status\ngrouped = df_m.groupby(['is_credit', 'aci', 'issuing_country', 'acquirer_country']).agg(\n    count=('eur_amount', 'count'),\n    total_amount=('eur_amount', 'sum')\n).reset_index()\n\nfor scheme in schemes:\n    scheme_rules = [r for r in applicable_rules if r['card_scheme'] == scheme]\n    total_fee = 0.0\n    \n    for _, row in grouped.iterrows():\n        is_credit = row['is_credit']\n        aci = row['aci']\n        issuing_country = row['issuing_country']\n        acquirer_country = row['acquirer_country']\n        count = row['count']\n        amount_sum = row['total_amount']\n        \n        # Determine Intracountry\n        is_intracountry = (issuing_country == acquirer_country)\n        \n        # Find best matching rule (highest fee) for this transaction group\n        best_fee_for_group = -1.0\n        matched = False\n        \n        for rule in scheme_rules:\n            # Check Transaction-Specific Conditions\n            \n            # is_credit\n            if rule.get('is_credit') is not None:\n                if rule['is_credit'] != is_credit:\n                    continue\n            \n            # aci\n            if rule.get('aci') and aci not in rule['aci']:\n                continue\n                \n            # intracountry\n            if rule.get('intracountry') is not None:\n                rule_intra = rule['intracountry']\n                # Convert JSON values (0.0/1.0) to bool\n                if rule_intra == 1.0 or rule_intra is True: rule_intra_bool = True\n                elif rule_intra == 0.0 or rule_intra is False: rule_intra_bool = False\n                else: rule_intra_bool = None\n                \n                if rule_intra_bool is not None and rule_intra_bool != is_intracountry:\n                    continue\n            \n            # Rule matches\n            matched = True\n            # Calculate total fee for this group using this rule\n            # Fee = (Fixed * Count) + (Rate * TotalAmount / 10000)\n            current_fee = (rule['fixed_amount'] * count) + (rule['rate'] * amount_sum / 10000)\n            \n            if current_fee > best_fee_for_group:\n                best_fee_for_group = current_fee\n        \n        if matched:\n            total_fee += best_fee_for_group\n    \n    scheme_totals[scheme] = total_fee\n\n# 5. Determine Winner\nsorted_schemes = sorted(scheme_totals.items(), key=lambda x: x[1], reverse=True)\n\nif sorted_schemes:\n    # Print only the name of the scheme with the highest fees\n    print(sorted_schemes[0][0])\nelse:\n    print(\"No applicable schemes found\")",
    "execution_output": "TransactPlus\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "sufficient",
    "temperature": 0.25,
    "plan_snapshot": [
      "Filter the `payments.csv` dataset to include only transactions for the merchant 'Golfclub_Baron_Friso' in the year 2023, calculate the average `eur_amount`, and retrieve the merchant's metadata (specifically `merchant_category_code`, `account_type`, and `acquirer`) from `merchant_data.json`.",
      "Load `payments.csv`, `merchant_data.json`, and `fees.json`. Filter `payments.csv` for merchant 'Golfclub_Baron_Friso' in 2023 to calculate the average transaction amount, total monthly volume, monthly fraud rate, and identify the most frequent values for `is_credit`, `aci`, and `intracountry` (based on `issuing_country` vs `acquirer_country`). Retrieve the merchant's `merchant_category_code`, `account_type`, and `capture_delay` from `merchant_data.json`. Finally, iterate through `fees.json` to find the applicable fee rule for each card scheme (matching the merchant's profile and transaction characteristics) and calculate the estimated fee per transaction to determine which scheme yields the highest fees."
    ]
  }
]