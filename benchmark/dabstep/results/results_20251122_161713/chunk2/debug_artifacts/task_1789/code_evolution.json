[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 3236,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\nimport json\n\n# Define file paths\npayments_path = '/output/chunk2/data/context/payments.csv'\nmerchant_data_path = '/output/chunk2/data/context/merchant_data.json'\nfees_path = '/output/chunk2/data/context/fees.json'\n\n# Load payments data\nprint(\"Loading payments data...\")\ndf_payments = pd.read_csv(payments_path)\n\n# Filter for merchant \"Martinis_Fine_Steakhouse\"\nmerchant_name = \"Martinis_Fine_Steakhouse\"\ndf_merchant = df_payments[df_payments['merchant'] == merchant_name]\n\n# Filter for March 2023 (Year 2023, Day of Year 60-90)\n# 2023 is a non-leap year. Jan=31, Feb=28 (Total 59). March 1st is Day 60. March 31st is Day 90.\ndf_march_2023 = df_merchant[\n    (df_merchant['year'] == 2023) & \n    (df_merchant['day_of_year'] >= 60) & \n    (df_merchant['day_of_year'] <= 90)\n]\n\nprint(f\"Total transactions for {merchant_name} in March 2023: {len(df_march_2023)}\")\n\n# Display a sample of the filtered data to verify\nprint(\"\\nSample of filtered transactions:\")\nprint(df_march_2023[['psp_reference', 'merchant', 'year', 'day_of_year', 'card_scheme', 'eur_amount', 'aci']].head())\n\n# Load merchant data and fees for context (needed for next steps)\nprint(\"\\nLoading merchant data and fees...\")\nwith open(merchant_data_path, 'r') as f:\n    merchant_data = json.load(f)\n    \nwith open(fees_path, 'r') as f:\n    fees_data = json.load(f)\n\n# Find specific merchant details\nspecific_merchant_info = next((item for item in merchant_data if item[\"merchant\"] == merchant_name), None)\nprint(f\"\\nMerchant Metadata for {merchant_name}:\")\nprint(json.dumps(specific_merchant_info, indent=2))",
    "execution_output": "Loading payments data...\nTotal transactions for Martinis_Fine_Steakhouse in March 2023: 1153\n\nSample of filtered transactions:\n     psp_reference                  merchant  year  day_of_year   card_scheme  eur_amount aci\n314    55170309648  Martinis_Fine_Steakhouse  2023           75        NexPay       17.96   F\n327    27004027704  Martinis_Fine_Steakhouse  2023           65  TransactPlus      107.06   D\n345    31136605946  Martinis_Fine_Steakhouse  2023           82   SwiftCharge       17.24   D\n387    44470148934  Martinis_Fine_Steakhouse  2023           89  TransactPlus       63.57   G\n489    75077563048  Martinis_Fine_Steakhouse  2023           88    GlobalCard       26.78   D\n\nLoading merchant data and fees...\n\nMerchant Metadata for Martinis_Fine_Steakhouse:\n{\n  \"merchant\": \"Martinis_Fine_Steakhouse\",\n  \"capture_delay\": \"immediate\",\n  \"acquirer\": [\n    \"dagoberts_geldpakhuis\",\n    \"bank_of_springfield\"\n  ],\n  \"merchant_category_code\": 5812,\n  \"account_type\": \"H\"\n}\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the data to include only transactions for the merchant \"Martinis_Fine_Steakhouse\" that occurred in March 2023 (Year 2023, Day of Year between 60 and 90)."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 7506,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas, k, m to float.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        # Handle percentages\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Handle k/m suffixes\n        if v.lower().endswith('k'):\n            return float(v[:-1]) * 1_000\n        if v.lower().endswith('m'):\n            return float(v[:-1]) * 1_000_000\n        return float(v)\n    return 0.0\n\ndef parse_range(range_str):\n    \"\"\"\n    Parses a range string like '100k-1m', '<3', '>5', '0%-0.5%'.\n    Returns a tuple (min_val, max_val).\n    \"\"\"\n    if not isinstance(range_str, str):\n        return None, None\n    \n    s = range_str.strip()\n    \n    # Handle inequalities\n    if s.startswith('<'):\n        return float('-inf'), coerce_to_float(s[1:])\n    if s.startswith('>'):\n        return coerce_to_float(s[1:]), float('inf')\n        \n    # Handle ranges\n    if '-' in s:\n        parts = s.split('-')\n        if len(parts) == 2:\n            return coerce_to_float(parts[0]), coerce_to_float(parts[1])\n            \n    # Handle exact matches (though usually ranges are explicit)\n    val = coerce_to_float(s)\n    return val, val\n\ndef check_range_match(value, range_str):\n    \"\"\"Checks if a numeric value falls within a string-defined range.\"\"\"\n    if range_str is None:\n        return True # Wildcard matches all\n    \n    min_v, max_v = parse_range(range_str)\n    if min_v is None: \n        return False\n        \n    # Inclusive boundaries assumed based on typical business logic\n    return min_v <= value <= max_v\n\ndef is_match(rule_val, actual_val):\n    \"\"\"\n    Generic matcher for fee rules.\n    - rule_val is None or [] -> Wildcard (Match)\n    - rule_val is List -> Match if actual_val in list\n    - rule_val is Scalar -> Match if actual_val == rule_val\n    \"\"\"\n    if rule_val is None:\n        return True\n    if isinstance(rule_val, list):\n        if not rule_val: # Empty list is wildcard\n            return True\n        return actual_val in rule_val\n    return rule_val == actual_val\n\n# ---------------------------------------------------------\n# MAIN ANALYSIS\n# ---------------------------------------------------------\n\n# File paths\npayments_path = '/output/chunk2/data/context/payments.csv'\nmerchant_data_path = '/output/chunk2/data/context/merchant_data.json'\nfees_path = '/output/chunk2/data/context/fees.json'\n\n# 1. Load Data\nprint(\"Loading data...\")\ndf = pd.read_csv(payments_path)\nwith open(merchant_data_path, 'r') as f:\n    merchant_data = json.load(f)\nwith open(fees_path, 'r') as f:\n    fees_data = json.load(f)\n\n# 2. Filter for Merchant and Time Period (March 2023)\ntarget_merchant = \"Martinis_Fine_Steakhouse\"\n# March 2023: Year 2023, Day of Year 60 to 90 (Non-leap year)\ndf_march = df[\n    (df['merchant'] == target_merchant) & \n    (df['year'] == 2023) & \n    (df['day_of_year'] >= 60) & \n    (df['day_of_year'] <= 90)\n].copy()\n\nprint(f\"Transactions found for {target_merchant} in March 2023: {len(df_march)}\")\n\n# 3. Calculate Monthly Metrics (Volume and Fraud Rate)\n# Volume: Sum of eur_amount\nmonthly_volume = df_march['eur_amount'].sum()\n\n# Fraud Rate: Fraudulent Volume / Total Volume\nfraud_txs = df_march[df_march['has_fraudulent_dispute'] == True]\nfraud_volume = fraud_txs['eur_amount'].sum()\n\nif monthly_volume > 0:\n    monthly_fraud_rate = fraud_volume / monthly_volume\nelse:\n    monthly_fraud_rate = 0.0\n\nprint(f\"Monthly Volume: \u20ac{monthly_volume:,.2f}\")\nprint(f\"Monthly Fraud Rate: {monthly_fraud_rate:.4%}\")\n\n# 4. Get Static Merchant Attributes\nmerchant_info = next((m for m in merchant_data if m['merchant'] == target_merchant), None)\nif not merchant_info:\n    raise ValueError(f\"Merchant {target_merchant} not found in merchant_data.json\")\n\nm_account_type = merchant_info['account_type']\nm_mcc = merchant_info['merchant_category_code']\nm_capture_delay = merchant_info['capture_delay']\n\nprint(f\"Merchant Attributes: Type={m_account_type}, MCC={m_mcc}, Delay={m_capture_delay}\")\n\n# 5. Identify Unique Transaction Profiles in the Data\n# We need to check 'intracountry' status (Issuer == Acquirer)\ndf_march['intracountry'] = df_march['issuing_country'] == df_march['acquirer_country']\n\n# Get unique combinations of attributes that affect fees\n# Columns: card_scheme, is_credit, aci, intracountry\nprofiles = df_march[['card_scheme', 'is_credit', 'aci', 'intracountry']].drop_duplicates()\nprint(f\"Unique transaction profiles identified: {len(profiles)}\")\n\n# 6. Find Applicable Fee IDs\napplicable_fee_ids = set()\n\nfor rule in fees_data:\n    # --- CHECK MERCHANT/MONTHLY LEVEL CONDITIONS FIRST ---\n    \n    # 1. Account Type (List match)\n    if not is_match(rule['account_type'], m_account_type):\n        continue\n        \n    # 2. Merchant Category Code (List match)\n    if not is_match(rule['merchant_category_code'], m_mcc):\n        continue\n        \n    # 3. Capture Delay (Exact match or Range)\n    # The manual lists specific strings for capture delay rules ('3-5', 'immediate', etc.)\n    # If the rule is a range string like '3-5', we might need logic, but usually these match the enum values.\n    # Let's assume exact match for string enums like 'immediate', 'manual'.\n    # If rule is null, it matches.\n    if rule['capture_delay'] is not None:\n        # If rule is a specific value like 'immediate', check equality\n        if rule['capture_delay'] != m_capture_delay:\n            # If they don't match exactly, check if it's a range logic (e.g. <3 vs 1)\n            # For this specific dataset, 'immediate' is a distinct category.\n            continue\n\n    # 4. Monthly Volume (Range match)\n    if not check_range_match(monthly_volume, rule['monthly_volume']):\n        continue\n        \n    # 5. Monthly Fraud Level (Range match)\n    if not check_range_match(monthly_fraud_rate, rule['monthly_fraud_level']):\n        continue\n\n    # --- CHECK TRANSACTION LEVEL CONDITIONS ---\n    # The rule applies if it matches AT LEAST ONE transaction profile present in the data.\n    \n    rule_matches_any_transaction = False\n    \n    for _, profile in profiles.iterrows():\n        # 6. Card Scheme (Exact match - usually string)\n        if rule['card_scheme'] != profile['card_scheme']:\n            continue\n            \n        # 7. Is Credit (Boolean match)\n        if rule['is_credit'] is not None and rule['is_credit'] != profile['is_credit']:\n            continue\n            \n        # 8. ACI (List match)\n        if not is_match(rule['aci'], profile['aci']):\n            continue\n            \n        # 9. Intracountry (Boolean/Float match)\n        # In fees.json, intracountry is often 0.0 (False) or 1.0 (True) or null\n        if rule['intracountry'] is not None:\n            rule_intra = bool(float(rule['intracountry']))\n            if rule_intra != profile['intracountry']:\n                continue\n        \n        # If we reached here, this profile matches the rule\n        rule_matches_any_transaction = True\n        break\n    \n    if rule_matches_any_transaction:\n        applicable_fee_ids.add(rule['ID'])\n\n# 7. Output Results\nsorted_ids = sorted(list(applicable_fee_ids))\nprint(\"\\n\" + \"=\"*30)\nprint(\"APPLICABLE FEE IDs\")\nprint(\"=\"*30)\nprint(\", \".join(map(str, sorted_ids)))",
    "execution_output": "Loading data...\nTransactions found for Martinis_Fine_Steakhouse in March 2023: 1153\nMonthly Volume: \u20ac103,726.64\nMonthly Fraud Rate: 7.7170%\nMerchant Attributes: Type=H, MCC=5812, Delay=immediate\nUnique transaction profiles identified: 68\n\n==============================\nAPPLICABLE FEE IDs\n==============================\n12, 16, 36, 51, 64, 65, 79, 84, 95, 107, 123, 134, 141, 150, 162, 163, 187, 217, 276, 280, 284, 300, 304, 332, 347, 364, 367, 381, 384, 398, 428, 431, 433, 454, 456, 473, 477, 485, 491, 501, 503, 536, 547, 556, 572, 595, 616, 622, 626, 637, 640, 660, 680, 682, 702, 709, 721, 741, 769, 804, 813, 834, 863, 870, 878, 888, 891, 913, 915, 921, 980\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the data to include only transactions for the merchant \"Martinis_Fine_Steakhouse\" that occurred in March 2023 (Year 2023, Day of Year between 60 and 90).",
      "Calculate the total transaction volume and fraud rate for Martinis_Fine_Steakhouse in March 2023, then load 'fees.json' and determine the applicable Fee IDs by matching the merchant's static attributes (Account Type 'H', MCC 5812, Capture Delay 'immediate'), calculated monthly metrics (volume, fraud), and the unique transaction characteristics (card scheme, credit status, ACI, intracountry status) present in the March 2023 data."
    ]
  }
]