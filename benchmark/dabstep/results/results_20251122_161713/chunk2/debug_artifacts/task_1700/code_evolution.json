[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 7570,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\nimport json\n\ndef execute_step():\n    # Paths\n    payments_path = '/output/chunk2/data/context/payments.csv'\n    fees_path = '/output/chunk2/data/context/fees.json'\n    merchant_data_path = '/output/chunk2/data/context/merchant_data.json'\n\n    # 1. Load Data\n    df_payments = pd.read_csv(payments_path)\n    with open(fees_path, 'r') as f:\n        fees_data = json.load(f)\n    with open(merchant_data_path, 'r') as f:\n        merchant_list = json.load(f)\n\n    # 2. Filter for Merchant and Date\n    merchant_name = \"Martinis_Fine_Steakhouse\"\n    target_year = 2023\n    target_day = 12\n\n    # Get Merchant Metadata\n    merchant_meta = next((item for item in merchant_list if item[\"merchant\"] == merchant_name), None)\n    if not merchant_meta:\n        print(f\"Merchant {merchant_name} not found.\")\n        return\n\n    mcc = merchant_meta['merchant_category_code']\n    account_type = merchant_meta['account_type']\n    capture_delay = merchant_meta['capture_delay']\n\n    # 3. Calculate Monthly Stats (Volume and Fraud) for January\n    # Day 12 is in January. Manual says \"natural months\".\n    # We use days 1-31 for January.\n    jan_mask = (df_payments['merchant'] == merchant_name) & \\\n               (df_payments['year'] == target_year) & \\\n               (df_payments['day_of_year'] >= 1) & \\\n               (df_payments['day_of_year'] <= 31)\n\n    df_jan = df_payments[jan_mask]\n\n    monthly_volume = df_jan['eur_amount'].sum()\n    fraud_volume = df_jan[df_jan['has_fraudulent_dispute']]['eur_amount'].sum()\n    monthly_fraud_rate = fraud_volume / monthly_volume if monthly_volume > 0 else 0.0\n\n    # 4. Identify Unique Transactions for Day 12\n    day_mask = (df_payments['merchant'] == merchant_name) & \\\n               (df_payments['year'] == target_year) & \\\n               (df_payments['day_of_year'] == target_day)\n\n    df_day = df_payments[day_mask]\n\n    # Attributes needed for fee matching\n    unique_txs = df_day[['card_scheme', 'is_credit', 'aci', 'issuing_country', 'acquirer_country']].drop_duplicates()\n\n    # 5. Fee Matching Logic\n    def parse_range(val_str):\n        if not val_str: return None\n        val_str = str(val_str).strip()\n        \n        is_percent = '%' in val_str\n        clean_str = val_str.replace('%', '')\n        \n        def parse_num(s):\n            s = s.lower()\n            mult = 1\n            if 'k' in s:\n                mult = 1000\n                s = s.replace('k', '')\n            elif 'm' in s:\n                mult = 1000000\n                s = s.replace('m', '')\n            try:\n                return float(s) * mult\n            except:\n                return 0.0\n\n        if '-' in clean_str:\n            low, high = clean_str.split('-')\n            l = parse_num(low)\n            h = parse_num(high)\n            if is_percent: l /= 100; h /= 100\n            return (l, h)\n        elif '<' in clean_str:\n            val = parse_num(clean_str.replace('<', ''))\n            if is_percent: val /= 100\n            return (float('-inf'), val)\n        elif '>' in clean_str:\n            val = parse_num(clean_str.replace('>', ''))\n            if is_percent: val /= 100\n            return (val, float('inf'))\n        else:\n            val = parse_num(clean_str)\n            if is_percent: val /= 100\n            return (val, val)\n\n    def check_rule(rule, tx_row, merch_mcc, merch_acct, merch_delay, m_vol, m_fraud):\n        # 1. Card Scheme\n        if rule['card_scheme'] != tx_row['card_scheme']:\n            return False\n            \n        # 2. Account Type (List) - Empty list means ALL\n        if rule['account_type'] and merch_acct not in rule['account_type']:\n            return False\n            \n        # 3. MCC (List) - Empty list means ALL\n        if rule['merchant_category_code'] and merch_mcc not in rule['merchant_category_code']:\n            return False\n            \n        # 4. Is Credit (Bool)\n        if rule['is_credit'] is not None and rule['is_credit'] != tx_row['is_credit']:\n            return False\n            \n        # 5. ACI (List) - Empty list means ALL\n        if rule['aci'] and tx_row['aci'] not in rule['aci']:\n            return False\n            \n        # 6. Intracountry (Bool/Float)\n        is_intra = (tx_row['issuing_country'] == tx_row['acquirer_country'])\n        if rule['intracountry'] is not None:\n            rule_intra = bool(rule['intracountry'])\n            if rule_intra != is_intra:\n                return False\n                \n        # 7. Capture Delay\n        if rule['capture_delay']:\n            rd = rule['capture_delay']\n            md = str(merch_delay)\n            match = False\n            if rd == md: match = True\n            elif rd == 'immediate' and md == 'immediate': match = True\n            elif rd == 'manual' and md == 'manual': match = True\n            elif rd == '<3' and md.isdigit() and float(md) < 3: match = True\n            elif rd == '>5' and md.isdigit() and float(md) > 5: match = True\n            elif rd == '3-5' and md.isdigit() and 3 <= float(md) <= 5: match = True\n            if not match: return False\n\n        # 8. Monthly Volume\n        if rule['monthly_volume']:\n            low, high = parse_range(rule['monthly_volume'])\n            if not (low <= m_vol <= high):\n                return False\n                \n        # 9. Monthly Fraud Level\n        if rule['monthly_fraud_level']:\n            low, high = parse_range(rule['monthly_fraud_level'])\n            if not (low <= m_fraud <= high):\n                return False\n                \n        return True\n\n    # 6. Iterate and Collect IDs\n    applicable_fee_ids = set()\n\n    for _, tx in unique_txs.iterrows():\n        for rule in fees_data:\n            if check_rule(rule, tx, mcc, account_type, capture_delay, monthly_volume, monthly_fraud_rate):\n                applicable_fee_ids.add(rule['ID'])\n\n    # 7. Output\n    print(sorted(list(applicable_fee_ids)))\n\nif __name__ == \"__main__\":\n    execute_step()",
    "execution_output": "[64, 84, 280, 381, 428, 454, 473, 477, 572, 660, 682, 709, 769, 813, 834, 888, 891, 913, 921]\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "sufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load `payments.csv` and filter for rows where `merchant` is \"Martinis_Fine_Steakhouse\", `year` is 2023, and `day_of_year` is 12 to identify the unique transaction attributes (such as `card_scheme`, `is_credit`, `aci`, `issuing_country`, and `acquirer_country`) present on that date."
    ]
  }
]