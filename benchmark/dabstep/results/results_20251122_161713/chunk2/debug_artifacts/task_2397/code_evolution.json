[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2539,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\ndef execute_step():\n    # Load the payments.csv file\n    file_path = '/output/chunk2/data/context/payments.csv'\n    df = pd.read_csv(file_path)\n\n    # Filter for transactions where the merchant is 'Rafa_AI'\n    # and the day_of_year corresponds to May 2023 (days 121 to 151)\n    # 2023 is a non-leap year:\n    # Jan (31) + Feb (28) + Mar (31) + Apr (30) = 120 days.\n    # May starts on day 121 and ends on day 151 (31 days).\n    \n    rafa_may_df = df[\n        (df['merchant'] == 'Rafa_AI') & \n        (df['day_of_year'] >= 121) & \n        (df['day_of_year'] <= 151)\n    ].copy()\n\n    # Print the result to verify the step\n    print(f\"Filtered DataFrame shape: {rafa_may_df.shape}\")\n    print(f\"Total EUR Amount: {rafa_may_df['eur_amount'].sum()}\")\n    print(\"\\nFirst 5 rows of filtered data:\")\n    print(rafa_may_df.head())\n\nif __name__ == \"__main__\":\n    execute_step()",
    "execution_output": "Filtered DataFrame shape: (2328, 21)\nTotal EUR Amount: 213102.7\n\nFirst 5 rows of filtered data:\n     psp_reference merchant  ... aci  acquirer_country\n41     11340236231  Rafa_AI  ...   E                NL\n52     73672607869  Rafa_AI  ...   G                NL\n168    64257353996  Rafa_AI  ...   E                NL\n170    34844183874  Rafa_AI  ...   E                NL\n189    22741743732  Rafa_AI  ...   G                NL\n\n[5 rows x 21 columns]\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter for transactions where the `merchant` is 'Rafa_AI' and the `day_of_year` corresponds to May 2023 (days 121 to 151)."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 9215,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\n# --- Custom Helpers for Fee Matching ---\n\ndef parse_vol_str(s):\n    \"\"\"Parse volume strings like '100k', '1m', '>10m'.\"\"\"\n    if not isinstance(s, str): return 0\n    s = s.lower().replace(',', '').strip()\n    s = s.replace('>', '').replace('<', '') # Remove operators for value parsing\n    mult = 1\n    if 'k' in s: mult = 1000; s = s.replace('k', '')\n    if 'm' in s: mult = 1000000; s = s.replace('m', '')\n    try:\n        return float(s) * mult\n    except:\n        return 0\n\ndef check_range(val, rule_str, is_percent=False):\n    \"\"\"Check if value fits in rule range string (e.g. '100k-1m', '>5').\"\"\"\n    if rule_str is None: return True\n    s = str(rule_str).strip()\n    \n    if is_percent:\n        # Convert val to percentage points (e.g. 0.083 -> 8.3) to match string \"8.3%\"\n        val_to_compare = val * 100\n        s = s.replace('%', '')\n    else:\n        val_to_compare = val\n\n    # Handle ranges \"min-max\"\n    if '-' in s:\n        parts = s.split('-')\n        try:\n            low = parse_vol_str(parts[0])\n            high = parse_vol_str(parts[1])\n            return low <= val_to_compare <= high\n        except:\n            return False\n            \n    # Handle inequalities\n    if s.startswith('>'):\n        try:\n            limit = parse_vol_str(s[1:])\n            return val_to_compare > limit\n        except:\n            return False\n    if s.startswith('<'):\n        try:\n            limit = parse_vol_str(s[1:])\n            return val_to_compare < limit\n        except:\n            return False\n            \n    # Exact match fallback\n    try:\n        limit = parse_vol_str(s)\n        return val_to_compare == limit\n    except:\n        return False\n\ndef check_capture_delay(merchant_val, rule_val):\n    \"\"\"Match merchant capture delay against rule.\"\"\"\n    if rule_val is None: return True\n    \n    # Direct string match\n    if str(merchant_val) == str(rule_val): return True\n    \n    # Numeric logic for ranges like '<3', '3-5'\n    # Merchant vals: '1', '2', '7', 'immediate', 'manual'\n    try:\n        days = int(merchant_val)\n        if rule_val == '<3': return days < 3\n        if rule_val == '3-5': return 3 <= days <= 5\n        if rule_val == '>5': return days > 5\n    except ValueError:\n        # merchant_val is 'immediate' or 'manual', handled by direct match above\n        pass\n    return False\n\ndef match_fee_rule_internal(ctx, rule):\n    \"\"\"\n    Check if a transaction context matches a fee rule.\n    ctx: dict containing transaction and merchant details\n    rule: dict containing fee rule details\n    \"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule.get('card_scheme') != ctx.get('card_scheme'):\n        return False\n        \n    # 2. Is Credit (Exact match, None=Wildcard)\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != ctx.get('is_credit'):\n            return False\n            \n    # 3. ACI (List match, Empty/None=Wildcard)\n    if is_not_empty(rule.get('aci')):\n        if ctx.get('aci') not in rule['aci']:\n            return False\n            \n    # 4. Intracountry (Boolean match, None=Wildcard)\n    if rule.get('intracountry') is not None:\n        # Rule value might be string \"0.0\"/\"1.0\" or float\n        rule_intra = float(rule['intracountry'])\n        is_intra = 1.0 if (ctx.get('issuing_country') == ctx.get('acquirer_country')) else 0.0\n        if rule_intra != is_intra:\n            return False\n\n    # 5. Account Type (List match, Empty/None=Wildcard)\n    if is_not_empty(rule.get('account_type')):\n        if ctx.get('account_type') not in rule['account_type']:\n            return False\n            \n    # 6. MCC (List match, Empty/None=Wildcard)\n    if is_not_empty(rule.get('merchant_category_code')):\n        if ctx.get('mcc') not in rule['merchant_category_code']:\n            return False\n            \n    # 7. Capture Delay (Custom logic)\n    if not check_capture_delay(ctx.get('capture_delay'), rule.get('capture_delay')):\n        return False\n        \n    # 8. Monthly Volume (Range match)\n    if not check_range(ctx.get('monthly_volume'), rule.get('monthly_volume'), is_percent=False):\n        return False\n        \n    # 9. Monthly Fraud Level (Range match)\n    if not check_range(ctx.get('monthly_fraud_rate'), rule.get('monthly_fraud_level'), is_percent=True):\n        return False\n        \n    return True\n\ndef execute_step():\n    # 1. Load Data\n    payments_path = '/output/chunk2/data/context/payments.csv'\n    fees_path = '/output/chunk2/data/context/fees.json'\n    merchant_path = '/output/chunk2/data/context/merchant_data.json'\n    \n    df_payments = pd.read_csv(payments_path)\n    with open(fees_path, 'r') as f:\n        fees_data = json.load(f)\n    with open(merchant_path, 'r') as f:\n        merchant_data = json.load(f)\n\n    # 2. Get Target Fee Rule (ID=787)\n    target_rule = next((f for f in fees_data if f['ID'] == 787), None)\n    if not target_rule:\n        print(\"Fee ID 787 not found.\")\n        return\n\n    # 3. Get Merchant Metadata for 'Rafa_AI'\n    merchant_info = next((m for m in merchant_data if m['merchant'] == 'Rafa_AI'), None)\n    if not merchant_info:\n        print(\"Merchant Rafa_AI not found.\")\n        return\n\n    # 4. Filter Transactions: Rafa_AI, May 2023 (Day 121-151)\n    # Note: 2023 is not a leap year.\n    # Jan=31, Feb=28, Mar=31, Apr=30 -> Sum=120. May 1st is Day 121.\n    # May has 31 days -> Ends Day 151.\n    rafa_may_txs = df_payments[\n        (df_payments['merchant'] == 'Rafa_AI') & \n        (df_payments['year'] == 2023) & \n        (df_payments['day_of_year'] >= 121) & \n        (df_payments['day_of_year'] <= 151)\n    ].copy()\n\n    if rafa_may_txs.empty:\n        print(\"No transactions found for Rafa_AI in May 2023.\")\n        return\n\n    # 5. Calculate Monthly Stats (Volume & Fraud) for Rule Matching\n    # Manual: \"Monthly volumes and rates are computed always in natural months\"\n    # Manual: \"monthly_fraud_level... ratio between monthly total volume and monthly volume notified as fraud\"\n    \n    monthly_volume = rafa_may_txs['eur_amount'].sum()\n    \n    fraud_txs = rafa_may_txs[rafa_may_txs['has_fraudulent_dispute'] == True]\n    fraud_volume = fraud_txs['eur_amount'].sum()\n    \n    monthly_fraud_rate = (fraud_volume / monthly_volume) if monthly_volume > 0 else 0.0\n\n    # 6. Identify Matching Transactions\n    matching_amounts = []\n    \n    # Pre-extract merchant static data\n    m_account_type = merchant_info.get('account_type')\n    m_mcc = merchant_info.get('merchant_category_code')\n    m_capture_delay = merchant_info.get('capture_delay')\n\n    for _, row in rafa_may_txs.iterrows():\n        # Build context for this transaction\n        ctx = {\n            'card_scheme': row['card_scheme'],\n            'is_credit': row['is_credit'],\n            'aci': row['aci'],\n            'issuing_country': row['issuing_country'],\n            'acquirer_country': row['acquirer_country'],\n            'eur_amount': row['eur_amount'],\n            \n            # Merchant static\n            'account_type': m_account_type,\n            'mcc': m_mcc,\n            'capture_delay': m_capture_delay,\n            \n            # Monthly stats\n            'monthly_volume': monthly_volume,\n            'monthly_fraud_rate': monthly_fraud_rate\n        }\n        \n        if match_fee_rule_internal(ctx, target_rule):\n            matching_amounts.append(row['eur_amount'])\n\n    # 7. Calculate Delta\n    # Formula: fee = fixed + rate * amount / 10000\n    # Delta = (New Fee - Old Fee)\n    # Since fixed amount doesn't change, Delta = (New Rate - Old Rate) * Amount / 10000\n    \n    original_rate = target_rule['rate']\n    new_rate = 1\n    total_affected_amount = sum(matching_amounts)\n    \n    delta = (new_rate - original_rate) * total_affected_amount / 10000\n    \n    # Print result with high precision\n    print(f\"{delta:.14f}\")\n\nif __name__ == \"__main__\":\n    execute_step()",
    "execution_output": "-10.48868600000000\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter for transactions where the `merchant` is 'Rafa_AI' and the `day_of_year` corresponds to May 2023 (days 121 to 151).",
      "Load `fees.json` and `merchant_data.json` to retrieve the details for fee ID 787 and the merchant 'Rafa_AI', then identify which of the May 2023 transactions match the criteria of fee ID 787 (considering attributes like card scheme, ACI, account type, and merchant stats) and calculate the total fee difference using the formula: `(1 - original_rate) * eur_amount / 10000`."
    ]
  }
]