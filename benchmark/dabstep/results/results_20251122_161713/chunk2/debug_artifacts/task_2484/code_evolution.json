[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2594,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport json\n\n# Path to the fees file\nfees_file_path = '/output/chunk2/data/context/fees.json'\n\n# Load the fees data\ntry:\n    with open(fees_file_path, 'r') as f:\n        fees_data = json.load(f)\n    \n    # Search for the rule with ID=398\n    target_rule = None\n    for rule in fees_data:\n        if rule.get('ID') == 398:\n            target_rule = rule\n            break\n            \n    if target_rule:\n        print(f\"Successfully extracted Fee Rule ID: {target_rule['ID']}\")\n        print(f\"Original Rate: {target_rule['rate']}\")\n        print(\"Full Rule Details:\")\n        print(json.dumps(target_rule, indent=4))\n    else:\n        print(\"Error: Fee rule with ID=398 not found in the dataset.\")\n\nexcept FileNotFoundError:\n    print(f\"Error: File not found at {fees_file_path}\")\nexcept json.JSONDecodeError:\n    print(f\"Error: Failed to decode JSON from {fees_file_path}\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")",
    "execution_output": "Successfully extracted Fee Rule ID: 398\nOriginal Rate: 99\nFull Rule Details:\n{\n    \"ID\": 398,\n    \"card_scheme\": \"SwiftCharge\",\n    \"account_type\": [],\n    \"capture_delay\": null,\n    \"monthly_fraud_level\": \"7.7%-8.3%\",\n    \"monthly_volume\": null,\n    \"merchant_category_code\": [],\n    \"is_credit\": true,\n    \"aci\": [\n        \"A\",\n        \"B\",\n        \"C\"\n    ],\n    \"fixed_amount\": 0.08,\n    \"rate\": 99,\n    \"intracountry\": null\n}\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `fees.json` file and extract the fee rule with `ID=398` to determine its original `rate` and the specific criteria (such as card scheme, ACI, etc.) required to match transactions."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 6661,
    "code": "import pandas as pd\nimport json\nimport numpy as np\nimport datetime\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef parse_fraud_range(range_str):\n    \"\"\"\n    Parses a fraud level range string (e.g., '7.7%-8.3%', '>5%', '<3%') \n    into a tuple (min_val, max_val).\n    \"\"\"\n    if not range_str or not isinstance(range_str, str):\n        return None, None\n    \n    s = range_str.strip().replace('%', '')\n    \n    if '-' in s:\n        try:\n            parts = s.split('-')\n            return float(parts[0])/100, float(parts[1])/100\n        except:\n            return None, None\n    elif s.startswith('>'):\n        try:\n            val = float(s[1:]) / 100\n            return val, float('inf')\n        except:\n            return None, None\n    elif s.startswith('<'):\n        try:\n            val = float(s[1:]) / 100\n            return float('-inf'), val\n        except:\n            return None, None\n    return None, None\n\ndef is_in_range(value, range_str):\n    \"\"\"Checks if a float value falls within a parsed range string.\"\"\"\n    if range_str is None:\n        return True # Wildcard matches all\n    \n    low, high = parse_fraud_range(range_str)\n    if low is not None and high is not None:\n        return low <= value <= high\n    return False\n\ndef match_fee_rule(tx_context, rule):\n    \"\"\"\n    Matches a transaction context against a fee rule.\n    tx_context must contain: \n      - card_scheme, aci, is_credit (from tx)\n      - account_type, merchant_category_code (from merchant data)\n      - monthly_fraud_rate (calculated stat)\n    \"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_context['card_scheme']:\n        return False\n        \n    # 2. Account Type (Rule has list, Tx has single)\n    if rule.get('account_type'):\n        if tx_context['account_type'] not in rule['account_type']:\n            return False\n            \n    # 3. MCC (Rule has list, Tx has single)\n    if rule.get('merchant_category_code'):\n        if tx_context['merchant_category_code'] not in rule['merchant_category_code']:\n            return False\n            \n    # 4. Is Credit (Exact match, handle boolean/null)\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != tx_context['is_credit']:\n            return False\n            \n    # 5. ACI (Rule has list, Tx has single)\n    if rule.get('aci'):\n        if tx_context['aci'] not in rule['aci']:\n            return False\n            \n    # 6. Monthly Fraud Level (Rule has range string, Tx has float)\n    if rule.get('monthly_fraud_level'):\n        if not is_in_range(tx_context['monthly_fraud_rate'], rule['monthly_fraud_level']):\n            return False\n            \n    return True\n\n# ---------------------------------------------------------\n# MAIN ANALYSIS\n# ---------------------------------------------------------\n\n# File Paths\nfees_path = '/output/chunk2/data/context/fees.json'\npayments_path = '/output/chunk2/data/context/payments.csv'\nmerchant_path = '/output/chunk2/data/context/merchant_data.json'\n\n# 1. Load Data\ntry:\n    with open(fees_path, 'r') as f:\n        fees_data = json.load(f)\n    with open(merchant_path, 'r') as f:\n        merchant_data = json.load(f)\n    df = pd.read_csv(payments_path)\nexcept Exception as e:\n    print(f\"Error loading data: {e}\")\n    exit()\n\n# 2. Extract Target Fee Rule (ID=398)\ntarget_rule = next((r for r in fees_data if r['ID'] == 398), None)\nif not target_rule:\n    print(\"Error: Fee rule ID=398 not found.\")\n    exit()\n\noriginal_rate = target_rule['rate']\nnew_rate = 99\nprint(f\"Analyzing Rule ID: {target_rule['ID']}\")\nprint(f\"Original Rate: {original_rate}\")\nprint(f\"Target New Rate: {new_rate}\")\nprint(f\"Rule Conditions: {json.dumps({k:v for k,v in target_rule.items() if k not in ['ID', 'rate', 'fixed_amount']}, indent=2)}\")\n\n# 3. Get Merchant Metadata\nmerchant_name = 'Crossfit_Hanna'\nmerchant_info = next((m for m in merchant_data if m['merchant'] == merchant_name), None)\nif not merchant_info:\n    print(f\"Error: Merchant {merchant_name} not found.\")\n    exit()\n\n# 4. Filter Transactions (Merchant + Year 2023)\ndf_mh = df[(df['merchant'] == merchant_name) & (df['year'] == 2023)].copy()\n\n# 5. Calculate Monthly Fraud Rates\n# Convert day_of_year to Month (1-12)\n# 2023 is not a leap year\ndf_mh['month'] = pd.to_datetime(df_mh['year'] * 1000 + df_mh['day_of_year'], format='%Y%j').dt.month\n\nmonthly_stats = {}\nfor month in range(1, 13):\n    month_txs = df_mh[df_mh['month'] == month]\n    if len(month_txs) == 0:\n        continue\n    \n    total_vol = month_txs['eur_amount'].sum()\n    fraud_vol = month_txs[month_txs['has_fraudulent_dispute']]['eur_amount'].sum()\n    \n    # Fraud Rate = Fraud Volume / Total Volume\n    fraud_rate = fraud_vol / total_vol if total_vol > 0 else 0.0\n    \n    monthly_stats[month] = {\n        'fraud_rate': fraud_rate,\n        'volume': total_vol\n    }\n\n# 6. Identify Matching Transactions and Calculate Delta\nmatching_amount_sum = 0.0\nmatching_count = 0\n\nfor idx, row in df_mh.iterrows():\n    month = row['month']\n    if month not in monthly_stats:\n        continue\n        \n    # Construct context for matching\n    tx_context = {\n        'card_scheme': row['card_scheme'],\n        'account_type': merchant_info['account_type'],\n        'merchant_category_code': merchant_info['merchant_category_code'],\n        'is_credit': row['is_credit'],\n        'aci': row['aci'],\n        'monthly_fraud_rate': monthly_stats[month]['fraud_rate']\n    }\n    \n    # Check if transaction matches Rule 398\n    if match_fee_rule(tx_context, target_rule):\n        matching_amount_sum += row['eur_amount']\n        matching_count += 1\n\n# 7. Calculate Final Delta\n# Formula: Delta = (New Rate - Old Rate) * Amount / 10000\ndelta = (new_rate - original_rate) * matching_amount_sum / 10000\n\nprint(\"-\" * 30)\nprint(f\"Matching Transactions: {matching_count}\")\nprint(f\"Total Matching Amount: {matching_amount_sum:.2f} EUR\")\nprint(f\"Calculated Delta: {delta:.14f}\")",
    "execution_output": "Analyzing Rule ID: 398\nOriginal Rate: 99\nTarget New Rate: 99\nRule Conditions: {\n  \"card_scheme\": \"SwiftCharge\",\n  \"account_type\": [],\n  \"capture_delay\": null,\n  \"monthly_fraud_level\": \"7.7%-8.3%\",\n  \"monthly_volume\": null,\n  \"merchant_category_code\": [],\n  \"is_credit\": true,\n  \"aci\": [\n    \"A\",\n    \"B\",\n    \"C\"\n  ],\n  \"intracountry\": null\n}\n------------------------------\nMatching Transactions: 62\nTotal Matching Amount: 5307.48 EUR\nCalculated Delta: 0.00000000000000\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `fees.json` file and extract the fee rule with `ID=398` to determine its original `rate` and the specific criteria (such as card scheme, ACI, etc.) required to match transactions.",
      "Load `payments.csv` and `fees.json`, filter for 'Crossfit_Hanna' transactions in 2023, calculate the monthly fraud volume rates to identify months falling within the \"7.7%-8.3%\" range specified in fee rule ID=398, sum the `eur_amount` of transactions in those months that match the rule's criteria (SwiftCharge, Credit, ACI in ['A','B','C']), and finally calculate the payment delta using the formula `delta = total_matching_amount * (99 - original_rate) / 10000`."
    ]
  },
  {
    "round": 3,
    "plan_steps": 2,
    "code_length": 7498,
    "code": "import pandas as pd\nimport json\nimport numpy as np\nimport datetime\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef parse_fraud_range(range_str):\n    \"\"\"\n    Parses a fraud level range string (e.g., '7.7%-8.3%', '>5%', '<3%') \n    into a tuple (min_val, max_val).\n    \"\"\"\n    if not range_str or not isinstance(range_str, str):\n        return None, None\n    \n    s = range_str.strip().replace('%', '')\n    \n    if '-' in s:\n        try:\n            parts = s.split('-')\n            # Convert percentage string to ratio (e.g. 7.7 -> 0.077)\n            return float(parts[0])/100, float(parts[1])/100\n        except:\n            return None, None\n    elif s.startswith('>'):\n        try:\n            val = float(s[1:]) / 100\n            return val, float('inf')\n        except:\n            return None, None\n    elif s.startswith('<'):\n        try:\n            val = float(s[1:]) / 100\n            return float('-inf'), val\n        except:\n            return None, None\n    return None, None\n\ndef is_in_range(value, range_str):\n    \"\"\"Checks if a float value falls within a parsed range string.\"\"\"\n    if range_str is None:\n        return True # Wildcard matches all\n    \n    low, high = parse_fraud_range(range_str)\n    if low is not None and high is not None:\n        # Use a small epsilon for float comparison if needed, but direct comparison is usually fine for these ranges\n        return low <= value <= high\n    return False\n\ndef match_fee_rule(tx_context, rule):\n    \"\"\"\n    Matches a transaction context against a fee rule.\n    tx_context must contain: \n      - card_scheme, aci, is_credit (from tx)\n      - account_type, merchant_category_code (from merchant data)\n      - monthly_fraud_rate (calculated stat)\n    \"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_context['card_scheme']:\n        return False\n        \n    # 2. Account Type (Rule has list, Tx has single)\n    # If rule['account_type'] is empty list or None, it applies to all\n    if rule.get('account_type'):\n        if tx_context['account_type'] not in rule['account_type']:\n            return False\n            \n    # 3. MCC (Rule has list, Tx has single)\n    # If rule['merchant_category_code'] is empty list or None, it applies to all\n    if rule.get('merchant_category_code'):\n        if tx_context['merchant_category_code'] not in rule['merchant_category_code']:\n            return False\n            \n    # 4. Is Credit (Exact match, handle boolean/null)\n    # If rule['is_credit'] is None, it applies to both\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != tx_context['is_credit']:\n            return False\n            \n    # 5. ACI (Rule has list, Tx has single)\n    # If rule['aci'] is empty list or None, it applies to all\n    if rule.get('aci'):\n        if tx_context['aci'] not in rule['aci']:\n            return False\n            \n    # 6. Monthly Fraud Level (Rule has range string, Tx has float)\n    if rule.get('monthly_fraud_level'):\n        if not is_in_range(tx_context['monthly_fraud_rate'], rule['monthly_fraud_level']):\n            return False\n            \n    return True\n\n# ---------------------------------------------------------\n# MAIN ANALYSIS\n# ---------------------------------------------------------\n\n# File Paths\nfees_path = '/output/chunk2/data/context/fees.json'\npayments_path = '/output/chunk2/data/context/payments.csv'\nmerchant_path = '/output/chunk2/data/context/merchant_data.json'\n\n# 1. Load Data\ntry:\n    with open(fees_path, 'r') as f:\n        fees_data = json.load(f)\n    with open(merchant_path, 'r') as f:\n        merchant_data = json.load(f)\n    df = pd.read_csv(payments_path)\nexcept Exception as e:\n    print(f\"Error loading data: {e}\")\n    exit()\n\n# 2. Extract Target Fee Rule (ID=398)\ntarget_rule = next((r for r in fees_data if r['ID'] == 398), None)\nif not target_rule:\n    print(\"Error: Fee rule ID=398 not found.\")\n    exit()\n\noriginal_rate = target_rule['rate']\nnew_rate = 99\n\n# 3. Get Merchant Metadata\nmerchant_name = 'Crossfit_Hanna'\nmerchant_info = next((m for m in merchant_data if m['merchant'] == merchant_name), None)\nif not merchant_info:\n    print(f\"Error: Merchant {merchant_name} not found.\")\n    exit()\n\n# 4. Filter Transactions (Merchant + Year 2023)\ndf_mh = df[(df['merchant'] == merchant_name) & (df['year'] == 2023)].copy()\n\n# 5. Calculate Monthly Fraud Rates\n# Convert day_of_year to Month (1-12)\n# 2023 is not a leap year\ndf_mh['month'] = pd.to_datetime(df_mh['year'] * 1000 + df_mh['day_of_year'], format='%Y%j').dt.month\n\nmonthly_stats = {}\nfor month in range(1, 13):\n    month_txs = df_mh[df_mh['month'] == month]\n    if len(month_txs) == 0:\n        monthly_stats[month] = {'fraud_rate': 0.0, 'volume': 0.0}\n        continue\n    \n    total_vol = month_txs['eur_amount'].sum()\n    fraud_vol = month_txs[month_txs['has_fraudulent_dispute']]['eur_amount'].sum()\n    \n    # Fraud Rate = Fraud Volume / Total Volume\n    fraud_rate = fraud_vol / total_vol if total_vol > 0 else 0.0\n    \n    monthly_stats[month] = {\n        'fraud_rate': fraud_rate,\n        'volume': total_vol\n    }\n\n# 6. Identify Matching Transactions and Calculate Delta\nmatching_amount_sum = 0.0\nmatching_count = 0\n\n# Optimization: Pre-filter by static fields if possible to speed up iteration\n# Rule 398 static fields: card_scheme, is_credit\nstatic_scheme = target_rule.get('card_scheme')\nstatic_credit = target_rule.get('is_credit')\n\n# Iterate\nfor idx, row in df_mh.iterrows():\n    # Quick check on static fields to avoid full context build if not needed\n    if static_scheme and row['card_scheme'] != static_scheme:\n        continue\n    if static_credit is not None and row['is_credit'] != static_credit:\n        continue\n\n    month = row['month']\n    current_fraud_rate = monthly_stats[month]['fraud_rate']\n    \n    # Construct context for matching\n    tx_context = {\n        'card_scheme': row['card_scheme'],\n        'account_type': merchant_info['account_type'],\n        'merchant_category_code': merchant_info['merchant_category_code'],\n        'is_credit': row['is_credit'],\n        'aci': row['aci'],\n        'monthly_fraud_rate': current_fraud_rate\n    }\n    \n    # Check if transaction matches Rule 398\n    if match_fee_rule(tx_context, target_rule):\n        matching_amount_sum += row['eur_amount']\n        matching_count += 1\n\n# 7. Calculate Final Delta\n# Formula: Delta = (New Rate - Old Rate) * Amount / 10000\n# Note: Rate is usually in basis points or similar, formula given in manual:\n# fee = fixed_amount + rate * transaction_value / 10000\n# Delta = (fixed + new_rate * val / 10000) - (fixed + old_rate * val / 10000)\n# Delta = (new_rate - old_rate) * val / 10000\n\ndelta = (new_rate - original_rate) * matching_amount_sum / 10000\n\nprint(f\"{delta:.14f}\")",
    "execution_output": "0.00000000000000\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "sufficient",
    "temperature": 0.25,
    "plan_snapshot": [
      "Load the `fees.json` file and extract the fee rule with `ID=398` to determine its original `rate` and the specific criteria (such as card scheme, ACI, etc.) required to match transactions.",
      "Load `fees.json` to extract the original rate and all matching conditions for fee ID 398, then load `merchant_data.json` to get Crossfit_Hanna's attributes, and finally load `payments.csv` to calculate the monthly fraud rates and volumes for Crossfit_Hanna in 2023, filtering for transactions that match all of Rule 398's criteria (including dynamic monthly thresholds) to compute the total transaction value subject to this fee and the resulting delta using the formula `(99 - original_rate) * total_value / 10000`."
    ]
  }
]