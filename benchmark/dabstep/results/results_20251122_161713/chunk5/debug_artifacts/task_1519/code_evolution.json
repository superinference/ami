[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 3120,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\ndef determine_average_scenario():\n    # Load the payments dataset\n    file_path = '/output/chunk5/data/context/payments.csv'\n    df = pd.read_csv(file_path)\n\n    # 1. Calculate the mode for 'is_credit'\n    # mode() returns a Series (in case of ties), we take the first value\n    mode_is_credit = df['is_credit'].mode()[0]\n\n    # 2. Calculate the mode for 'aci'\n    mode_aci = df['aci'].mode()[0]\n\n    # 3. Determine the most common 'intracountry' status\n    # Intracountry is True if issuing_country equals acquirer_country, False otherwise\n    # We create a boolean Series for this comparison\n    intracountry_series = df['issuing_country'] == df['acquirer_country']\n    mode_intracountry = intracountry_series.mode()[0]\n    \n    # Calculate counts for verification/context\n    intracountry_counts = intracountry_series.value_counts()\n\n    # 4. Identify the most frequent merchant (to determine MCC for the average scenario later)\n    mode_merchant = df['merchant'].mode()[0]\n\n    # Output the results\n    print(\"Average Scenario Characteristics (Modes):\")\n    print(f\"Most common is_credit: {mode_is_credit}\")\n    print(f\"Most common aci: {mode_aci}\")\n    print(f\"Most common intracountry: {mode_intracountry}\")\n    print(f\"Most common merchant: {mode_merchant}\")\n    \n    # Print breakdown for intracountry to confirm\n    print(\"\\nIntracountry Breakdown:\")\n    print(intracountry_counts)\n\nif __name__ == \"__main__\":\n    determine_average_scenario()",
    "execution_output": "Average Scenario Characteristics (Modes):\nMost common is_credit: True\nMost common aci: D\nMost common intracountry: False\nMost common merchant: Crossfit_Hanna\n\nIntracountry Breakdown:\nFalse    113577\nTrue      24659\nName: count, dtype: int64\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "To determine the cheapest card scheme for the average scenario, I need to first define what the \"average scenario\" is by identifying the most common transaction characteristics.\n\n**Step 1:** Calculate the mode (most frequent value) for the `is_credit` and `aci` columns in `payments.csv`, and determine the most common `intracountry` status by comparing `issuing_country` and `acquirer_country` for all transactions."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 8557,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# --- Helper Functions ---\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef parse_range_check(value, rule_string):\n    \"\"\"\n    Checks if a numeric value fits within a rule string.\n    Rule strings: '100k-1m', '>5', '<3', '0%-0.5%', 'immediate', 'manual'\n    \"\"\"\n    if rule_string is None:\n        return True\n    \n    # Handle string literals (e.g., 'manual', 'immediate')\n    # If the rule is a specific string like \"manual\", we require an exact match\n    if isinstance(rule_string, str) and not any(c.isdigit() for c in rule_string):\n        return str(value) == rule_string\n\n    # Convert value to float for comparison\n    try:\n        val_float = float(value)\n    except (ValueError, TypeError):\n        # If value is a string (e.g. 'manual') and rule is numeric/range, it doesn't match\n        return False\n\n    rs = str(rule_string).strip()\n    \n    # Helper to parse number with k/m/%\n    def parse_num(s):\n        s = s.strip()\n        factor = 1.0\n        if '%' in s:\n            factor = 0.01\n            s = s.replace('%', '')\n        elif 'k' in s.lower():\n            factor = 1000.0\n            s = s.lower().replace('k', '')\n        elif 'm' in s.lower():\n            factor = 1000000.0\n            s = s.lower().replace('m', '')\n        return float(s) * factor\n\n    try:\n        if '-' in rs:\n            low_str, high_str = rs.split('-')\n            low = parse_num(low_str)\n            high = parse_num(high_str)\n            return low <= val_float <= high\n        elif rs.startswith('>'):\n            limit = parse_num(rs[1:])\n            return val_float > limit\n        elif rs.startswith('<'):\n            limit = parse_num(rs[1:])\n            return val_float < limit\n        else:\n            # Exact match numeric string\n            return val_float == parse_num(rs)\n    except:\n        return False\n\ndef match_fee_rule(ctx, rule):\n    \"\"\"\n    Checks if a fee rule applies to the transaction context.\n    ctx: dict containing transaction/merchant details\n    rule: dict containing fee rule details\n    \"\"\"\n    # 1. Card Scheme\n    if rule.get('card_scheme') != ctx.get('card_scheme'):\n        return False\n\n    # 2. Account Type (List or Wildcard)\n    if rule.get('account_type'):\n        if ctx.get('account_type') not in rule['account_type']:\n            return False\n\n    # 3. Merchant Category Code (List or Wildcard)\n    if rule.get('merchant_category_code'):\n        if ctx.get('mcc') not in rule['merchant_category_code']:\n            return False\n\n    # 4. Is Credit (Bool or Wildcard)\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != ctx.get('is_credit'):\n            return False\n\n    # 5. ACI (List or Wildcard)\n    if rule.get('aci'):\n        if ctx.get('aci') not in rule['aci']:\n            return False\n\n    # 6. Intracountry (0.0/1.0 or Wildcard)\n    if rule.get('intracountry') is not None:\n        # Rule uses 0.0/1.0, ctx uses True/False\n        # Convert rule float to bool (0.0 -> False, 1.0 -> True)\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != ctx.get('intracountry'):\n            return False\n\n    # 7. Capture Delay (String/Range or Wildcard)\n    if rule.get('capture_delay'):\n        if not parse_range_check(ctx.get('capture_delay'), rule['capture_delay']):\n            return False\n\n    # 8. Monthly Volume (Range or Wildcard)\n    if rule.get('monthly_volume'):\n        if not parse_range_check(ctx.get('monthly_volume'), rule['monthly_volume']):\n            return False\n\n    # 9. Monthly Fraud Level (Range or Wildcard)\n    if rule.get('monthly_fraud_level'):\n        if not parse_range_check(ctx.get('monthly_fraud_level'), rule['monthly_fraud_level']):\n            return False\n\n    return True\n\ndef calculate_fee(amount, rule):\n    fixed = rule.get('fixed_amount', 0.0)\n    rate = rule.get('rate', 0.0)\n    return fixed + (rate * amount / 10000.0)\n\n# --- Main Analysis ---\ndef analyze():\n    # Load Data\n    payments = pd.read_csv('/output/chunk5/data/context/payments.csv')\n    with open('/output/chunk5/data/context/fees.json', 'r') as f:\n        fees = json.load(f)\n    with open('/output/chunk5/data/context/merchant_data.json', 'r') as f:\n        merchants = json.load(f)\n\n    # 1. Determine Average Scenario Parameters\n    \n    # Global Modes (Most common transaction characteristics)\n    mode_is_credit = payments['is_credit'].mode()[0]\n    mode_aci = payments['aci'].mode()[0]\n    \n    # Intracountry Mode\n    # Compare issuing_country and acquirer_country\n    is_intra = payments['issuing_country'] == payments['acquirer_country']\n    mode_intracountry = is_intra.mode()[0]\n    \n    # Most Frequent Merchant (Defines the merchant profile for the scenario)\n    mode_merchant_name = payments['merchant'].mode()[0]\n    \n    # Merchant Specifics\n    # Get merchant metadata\n    merchant_info = next((m for m in merchants if m['merchant'] == mode_merchant_name), None)\n    if not merchant_info:\n        print(f\"Error: Merchant {mode_merchant_name} not found in merchant_data.json\")\n        return\n\n    mcc = merchant_info['merchant_category_code']\n    account_type = merchant_info['account_type']\n    capture_delay = merchant_info['capture_delay']\n    \n    # Calculate Merchant Volume & Fraud\n    # Filter payments for this merchant\n    merchant_txs = payments[payments['merchant'] == mode_merchant_name]\n    \n    # Monthly Volume: Total EUR / 12 (Assuming 2023 is full year)\n    total_volume = merchant_txs['eur_amount'].sum()\n    monthly_volume = total_volume / 12.0\n    \n    # Monthly Fraud Level: Fraud Volume / Total Volume (as per manual)\n    fraud_volume = merchant_txs[merchant_txs['has_fraudulent_dispute']]['eur_amount'].sum()\n    monthly_fraud_level = fraud_volume / total_volume if total_volume > 0 else 0.0\n\n    print(f\"Scenario Parameters (Average Scenario):\")\n    print(f\"  Merchant: {mode_merchant_name}\")\n    print(f\"  Is Credit: {mode_is_credit}\")\n    print(f\"  ACI: {mode_aci}\")\n    print(f\"  Intracountry: {mode_intracountry}\")\n    print(f\"  MCC: {mcc}\")\n    print(f\"  Account Type: {account_type}\")\n    print(f\"  Capture Delay: {capture_delay}\")\n    print(f\"  Monthly Volume: {monthly_volume:,.2f}\")\n    print(f\"  Monthly Fraud Level: {monthly_fraud_level:.4%}\")\n\n    # 2. Evaluate Fees for Target Transaction\n    target_amount = 4321.0\n    schemes = ['NexPay', 'GlobalCard', 'SwiftCharge', 'TransactPlus']\n    \n    results = {}\n    \n    # Context for matching\n    ctx = {\n        'account_type': account_type,\n        'mcc': mcc,\n        'is_credit': mode_is_credit,\n        'aci': mode_aci,\n        'intracountry': mode_intracountry,\n        'capture_delay': capture_delay,\n        'monthly_volume': monthly_volume,\n        'monthly_fraud_level': monthly_fraud_level\n    }\n\n    for scheme in schemes:\n        ctx['card_scheme'] = scheme\n        \n        # Find matching rules\n        matches = []\n        for rule in fees:\n            if match_fee_rule(ctx, rule):\n                matches.append(rule)\n        \n        if not matches:\n            print(f\"No matching rule found for {scheme}\")\n            results[scheme] = float('inf')\n            continue\n            \n        # Calculate fee using the matches. \n        # If multiple rules match, we take the minimum fee (assuming best optimization)\n        fees_calculated = [calculate_fee(target_amount, m) for m in matches]\n        min_fee = min(fees_calculated)\n        results[scheme] = min_fee\n\n    # 3. Determine Cheapest\n    cheapest_scheme = min(results, key=results.get)\n    cheapest_fee = results[cheapest_scheme]\n\n    print(\"-\" * 30)\n    print(f\"Fees for 4321 EUR transaction:\")\n    for s, f in results.items():\n        print(f\"  {s}: {f:.4f} EUR\")\n    \n    print(\"-\" * 30)\n    print(f\"Cheapest Scheme: {cheapest_scheme}\")\n    \n    # Final Answer Output\n    print(cheapest_scheme)\n\nif __name__ == \"__main__\":\n    analyze()",
    "execution_output": "Scenario Parameters (Average Scenario):\n  Merchant: Crossfit_Hanna\n  Is Credit: True\n  ACI: D\n  Intracountry: False\n  MCC: 7997\n  Account Type: F\n  Capture Delay: manual\n  Monthly Volume: 423,053.07\n  Monthly Fraud Level: 8.9079%\nNo matching rule found for NexPay\n------------------------------\nFees for 4321 EUR transaction:\n  NexPay: inf EUR\n  GlobalCard: 35.8843 EUR\n  SwiftCharge: 22.1171 EUR\n  TransactPlus: 20.7508 EUR\n------------------------------\nCheapest Scheme: TransactPlus\nTransactPlus\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "To determine the cheapest card scheme for the average scenario, I need to first define what the \"average scenario\" is by identifying the most common transaction characteristics.\n\n**Step 1:** Calculate the mode (most frequent value) for the `is_credit` and `aci` columns in `payments.csv`, and determine the most common `intracountry` status by comparing `issuing_country` and `acquirer_country` for all transactions.",
      "Load `merchant_data.json` to retrieve the `merchant_category_code`, `account_type`, and `capture_delay` for 'Crossfit_Hanna', and using `payments.csv`, calculate the merchant's average monthly volume (total `eur_amount` / 12) and fraud rate (total fraudulent `eur_amount` / total `eur_amount`) to define the scenario parameters."
    ]
  }
]