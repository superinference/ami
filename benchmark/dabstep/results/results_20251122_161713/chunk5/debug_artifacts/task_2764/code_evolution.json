[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 4724,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\nimport json\n\n# Define file paths\npayments_path = '/output/chunk5/data/context/payments.csv'\nmerchant_data_path = '/output/chunk5/data/context/merchant_data.json'\n\n# 1. Load Payments Data\nprint(\"Loading payments data...\")\ndf = pd.read_csv(payments_path)\n\n# 2. Filter for 'Martinis_Fine_Steakhouse' and Year 2023\nmerchant_name = 'Martinis_Fine_Steakhouse'\ntarget_year = 2023\n\ndf_merchant = df[\n    (df['merchant'] == merchant_name) & \n    (df['year'] == target_year)\n].copy()\n\nprint(f\"Filtered data for {merchant_name} in {target_year}. Transaction count: {len(df_merchant)}\")\n\n# 3. Calculate Transaction Profile\n# A. Volume Metrics\n# Fee rules use 'monthly_volume'. We calculate the total annual volume and average it per month.\ntotal_volume_2023 = df_merchant['eur_amount'].sum()\navg_monthly_volume = total_volume_2023 / 12.0  # Assuming full year data for 2023\n\n# B. Fraud Metrics\n# Manual: \"Fraud is defined as the ratio of fraudulent volume over total volume.\"\n# Fee rules use 'monthly_fraud_level'. We calculate the overall rate.\nfraud_txs = df_merchant[df_merchant['has_fraudulent_dispute'] == True]\nfraud_volume = fraud_txs['eur_amount'].sum()\nfraud_rate = fraud_volume / total_volume_2023 if total_volume_2023 > 0 else 0.0\n\n# C. Average Transaction Amount\navg_amount = df_merchant['eur_amount'].mean()\n\n# D. Additional Profile Metrics for Fee Rules\n# Credit Ratio (for 'is_credit' rule)\ncredit_ratio = df_merchant['is_credit'].mean()\n\n# Intracountry Ratio (for 'intracountry' rule)\n# Intracountry = True if issuing_country == acquirer_country\ndf_merchant['is_intracountry'] = df_merchant['issuing_country'] == df_merchant['acquirer_country']\nintra_ratio = df_merchant['is_intracountry'].mean()\n\n# ACI Distribution (for 'aci' rule)\naci_distribution = df_merchant['aci'].value_counts(normalize=True).to_dict()\n\n# 4. Retrieve Metadata from merchant_data.json\nprint(\"Loading merchant metadata...\")\nwith open(merchant_data_path, 'r') as f:\n    merchant_metadata_list = json.load(f)\n\n# Find the specific merchant\nmerchant_meta = next((item for item in merchant_metadata_list if item[\"merchant\"] == merchant_name), None)\n\nif merchant_meta:\n    mcc = merchant_meta.get('merchant_category_code')\n    account_type = merchant_meta.get('account_type')\n    acquirers = merchant_meta.get('acquirer')\nelse:\n    mcc = None\n    account_type = None\n    acquirers = []\n    print(\"Warning: Merchant metadata not found.\")\n\n# 5. Output Results\nprint(\"\\n--- Merchant Transaction Profile (2023) ---\")\nprint(f\"Merchant Name: {merchant_name}\")\nprint(f\"Total Transactions: {len(df_merchant)}\")\nprint(f\"Total Volume (2023): \u20ac{total_volume_2023:,.2f}\")\nprint(f\"Avg Monthly Volume: \u20ac{avg_monthly_volume:,.2f}\")\nprint(f\"Fraud Rate (Volume): {fraud_rate:.4%}\")\nprint(f\"Avg Transaction Amount: \u20ac{avg_amount:.4f}\")\nprint(f\"Credit Ratio: {credit_ratio:.4f}\")\nprint(f\"Intracountry Ratio: {intra_ratio:.4f}\")\nprint(f\"ACI Distribution: {aci_distribution}\")\n\nprint(\"\\n--- Merchant Metadata ---\")\nprint(f\"MCC: {mcc}\")\nprint(f\"Account Type: {account_type}\")\nprint(f\"Acquirers: {acquirers}\")",
    "execution_output": "Loading payments data...\nFiltered data for Martinis_Fine_Steakhouse in 2023. Transaction count: 13805\nLoading merchant metadata...\n\n--- Merchant Transaction Profile (2023) ---\nMerchant Name: Martinis_Fine_Steakhouse\nTotal Transactions: 13805\nTotal Volume (2023): \u20ac1,260,227.18\nAvg Monthly Volume: \u20ac105,018.93\nFraud Rate (Volume): 9.1340%\nAvg Transaction Amount: \u20ac91.2877\nCredit Ratio: 0.7312\nIntracountry Ratio: 0.0998\nACI Distribution: {'D': 0.44875045273451647, 'F': 0.26526620789568994, 'G': 0.19594349873234335, 'C': 0.041941325606664255, 'A': 0.028830134009416877, 'B': 0.01926838102136907}\n\n--- Merchant Metadata ---\nMCC: 5812\nAccount Type: H\nAcquirers: ['dagoberts_geldpakhuis', 'bank_of_springfield']\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load `payments.csv` and filter for transactions where `merchant` is 'Martinis_Fine_Steakhouse' and `year` is 2023, then calculate the merchant's transaction profile (total monthly volume, monthly fraud rate, average transaction amount) and retrieve their metadata (MCC, account type) from `merchant_data.json`."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 9093,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef parse_volume_range(vol_str):\n    \"\"\"Parses volume strings like '100k-1m' into (min, max).\"\"\"\n    if not vol_str:\n        return (0, float('inf'))\n    \n    s = vol_str.lower().replace(',', '').replace('\u20ac', '')\n    \n    def parse_val(x):\n        x = x.strip()\n        mult = 1\n        if 'k' in x: mult = 1000; x = x.replace('k', '')\n        elif 'm' in x: mult = 1000000; x = x.replace('m', '')\n        return float(x) * mult\n\n    if '>' in s:\n        return (parse_val(s.replace('>', '')), float('inf'))\n    if '<' in s:\n        return (0, parse_val(s.replace('<', '')))\n    if '-' in s:\n        parts = s.split('-')\n        return (parse_val(parts[0]), parse_val(parts[1]))\n    \n    return (0, float('inf'))\n\ndef parse_fraud_range(fraud_str):\n    \"\"\"Parses fraud strings like '7.7%-8.3%' into (min, max).\"\"\"\n    if not fraud_str:\n        return (0, float('inf'))\n    \n    s = fraud_str.replace('%', '')\n    \n    def parse_val(x):\n        return float(x.strip()) / 100.0\n\n    if '>' in s:\n        return (parse_val(s.replace('>', '')), float('inf'))\n    if '<' in s:\n        return (0, parse_val(s.replace('<', '')))\n    if '-' in s:\n        parts = s.split('-')\n        return (parse_val(parts[0]), parse_val(parts[1]))\n        \n    return (0, float('inf'))\n\ndef check_rule_match(rule, merchant_profile, transaction):\n    \"\"\"\n    Checks if a fee rule applies to a specific transaction given the merchant profile.\n    \"\"\"\n    # 1. Static Merchant Checks (Pre-validated in main loop, but good for safety)\n    # (Skipping here as we will pre-filter for efficiency)\n\n    # 2. Transaction Specific Checks\n    # Is Credit\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != transaction['is_credit']:\n            return False\n            \n    # ACI (Authorization Characteristics Indicator)\n    # Rule ACI is a list of allowed values. If None/Empty, it applies to all.\n    if rule.get('aci'):\n        if transaction['aci'] not in rule['aci']:\n            return False\n            \n    # Intracountry\n    # Rule intracountry is boolean. If None, applies to all.\n    if rule.get('intracountry') is not None:\n        # Intracountry definition: Issuer Country == Acquirer Country\n        is_intra = transaction['issuing_country'] == transaction['acquirer_country']\n        # Note: fees.json uses 0.0/1.0 or boolean for this field sometimes? \n        # Let's handle the type safely.\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != is_intra:\n            return False\n\n    return True\n\ndef calculate_fee(amount, rule):\n    \"\"\"Calculates fee based on fixed amount and rate.\"\"\"\n    # Formula: fee = fixed_amount + rate * transaction_value / 10000\n    fixed = float(rule.get('fixed_amount', 0))\n    rate = float(rule.get('rate', 0))\n    return fixed + (rate * amount / 10000.0)\n\n# ---------------------------------------------------------\n# MAIN EXECUTION\n# ---------------------------------------------------------\n\n# File Paths\npayments_path = '/output/chunk5/data/context/payments.csv'\nmerchant_data_path = '/output/chunk5/data/context/merchant_data.json'\nfees_path = '/output/chunk5/data/context/fees.json'\n\n# 1. Load Data\nprint(\"Loading data...\")\ndf = pd.read_csv(payments_path)\nwith open(merchant_data_path, 'r') as f:\n    merchant_data = json.load(f)\nwith open(fees_path, 'r') as f:\n    fees_data = json.load(f)\n\n# 2. Filter for Merchant and Year\ntarget_merchant = 'Martinis_Fine_Steakhouse'\ntarget_year = 2023\n\ndf_merchant = df[(df['merchant'] == target_merchant) & (df['year'] == target_year)].copy()\nprint(f\"Transactions found: {len(df_merchant)}\")\n\n# 3. Build Merchant Profile\n# Get Metadata\nmerchant_meta = next((m for m in merchant_data if m['merchant'] == target_merchant), None)\nif not merchant_meta:\n    raise ValueError(f\"Merchant {target_merchant} not found in metadata.\")\n\nmcc = merchant_meta.get('merchant_category_code')\naccount_type = merchant_meta.get('account_type')\ncapture_delay = merchant_meta.get('capture_delay')\n\n# Calculate Dynamic Metrics\n# Volume: Monthly Average\ntotal_volume = df_merchant['eur_amount'].sum()\navg_monthly_volume = total_volume / 12.0\n\n# Fraud: Ratio of Fraud Volume / Total Volume\nfraud_txs = df_merchant[df_merchant['has_fraudulent_dispute'] == True]\nfraud_volume = fraud_txs['eur_amount'].sum()\nfraud_rate = fraud_volume / total_volume if total_volume > 0 else 0.0\n\nprint(f\"Profile - MCC: {mcc}, Account: {account_type}, Capture: {capture_delay}\")\nprint(f\"Profile - Avg Monthly Vol: \u20ac{avg_monthly_volume:,.2f}, Fraud Rate: {fraud_rate:.4%}\")\n\n# 4. Pre-filter Fee Rules based on Merchant Profile\n# We only keep rules that *could* apply to this merchant (ignoring tx-specific fields for now)\napplicable_rules = []\n\nfor rule in fees_data:\n    # Check MCC (Rule list must contain MCC or be empty)\n    if rule.get('merchant_category_code') and mcc not in rule['merchant_category_code']:\n        continue\n        \n    # Check Account Type (Rule list must contain Account Type or be empty)\n    if rule.get('account_type') and account_type not in rule['account_type']:\n        continue\n        \n    # Check Capture Delay (Rule must match or be null)\n    if rule.get('capture_delay') and rule['capture_delay'] != capture_delay:\n        continue\n        \n    # Check Monthly Volume (Merchant vol must be in range or rule is null)\n    if rule.get('monthly_volume'):\n        min_v, max_v = parse_volume_range(rule['monthly_volume'])\n        if not (min_v <= avg_monthly_volume <= max_v):\n            continue\n            \n    # Check Monthly Fraud Level (Merchant fraud must be in range or rule is null)\n    if rule.get('monthly_fraud_level'):\n        min_f, max_f = parse_fraud_range(rule['monthly_fraud_level'])\n        if not (min_f <= fraud_rate <= max_f):\n            continue\n            \n    applicable_rules.append(rule)\n\nprint(f\"Applicable rules found: {len(applicable_rules)}\")\n\n# 5. Simulate Costs per Scheme\n# Identify available schemes in the filtered rules\nschemes = set(r['card_scheme'] for r in applicable_rules)\nscheme_costs = {}\n\n# Pre-calculate transaction fields needed for matching to speed up loop\n# We need: is_credit, aci, issuing_country, acquirer_country, eur_amount\n# Note: acquirer_country is in the CSV.\ntx_records = df_merchant[['is_credit', 'aci', 'issuing_country', 'acquirer_country', 'eur_amount']].to_dict('records')\n\nfor scheme in schemes:\n    # Get rules for this specific scheme\n    scheme_rules = [r for r in applicable_rules if r['card_scheme'] == scheme]\n    \n    total_scheme_fee = 0.0\n    covered_transactions = 0\n    \n    for tx in tx_records:\n        # Find matching rule for this transaction\n        matched_rule = None\n        for rule in scheme_rules:\n            if check_rule_match(rule, None, tx):\n                matched_rule = rule\n                break # Assume first match wins (standard rule engine logic)\n        \n        if matched_rule:\n            fee = calculate_fee(tx['eur_amount'], matched_rule)\n            total_scheme_fee += fee\n            covered_transactions += 1\n        else:\n            # If a scheme cannot process a transaction (no rule), it's technically not a valid option\n            # for \"steering ALL traffic\". However, for comparison, we might penalize or ignore.\n            # Given the problem type, we assume the valid scheme covers the traffic.\n            # If coverage is low, we'll note it.\n            pass\n\n    # Only consider schemes that cover 100% of transactions (or very close)\n    # to ensure a fair comparison.\n    if covered_transactions == len(tx_records):\n        scheme_costs[scheme] = total_scheme_fee\n        print(f\"Scheme: {scheme} | Total Fee: \u20ac{total_scheme_fee:,.2f} | Coverage: 100%\")\n    else:\n        print(f\"Scheme: {scheme} | Incomplete Coverage ({covered_transactions}/{len(tx_records)}) - Discarded\")\n\n# 6. Determine Winner\nif not scheme_costs:\n    print(\"No schemes found that cover all transactions.\")\nelse:\n    best_scheme = min(scheme_costs, key=scheme_costs.get)\n    min_fee = scheme_costs[best_scheme]\n    print(f\"\\nRecommended Scheme: {best_scheme}\")\n    print(f\"Minimum Total Fees: \u20ac{min_fee:,.2f}\")\n    \n    # Output just the name as requested by the goal\n    print(best_scheme)",
    "execution_output": "Loading data...\nTransactions found: 13805\nProfile - MCC: 5812, Account: H, Capture: immediate\nProfile - Avg Monthly Vol: \u20ac105,018.93, Fraud Rate: 9.1340%\nApplicable rules found: 87\nScheme: SwiftCharge | Incomplete Coverage (11208/13805) - Discarded\nScheme: TransactPlus | Total Fee: \u20ac12,439.55 | Coverage: 100%\nScheme: GlobalCard | Incomplete Coverage (5242/13805) - Discarded\nScheme: NexPay | Incomplete Coverage (4190/13805) - Discarded\n\nRecommended Scheme: TransactPlus\nMinimum Total Fees: \u20ac12,439.55\nTransactPlus\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load `payments.csv` and filter for transactions where `merchant` is 'Martinis_Fine_Steakhouse' and `year` is 2023, then calculate the merchant's transaction profile (total monthly volume, monthly fraud rate, average transaction amount) and retrieve their metadata (MCC, account type) from `merchant_data.json`.",
      "Load `fees.json` and filter for rules applicable to 'Martinis_Fine_Steakhouse' based on its metadata (MCC 5812, Account Type 'H', Capture Delay 'immediate', Monthly Volume '100k-1m', Monthly Fraud Level '>8.3%'), then calculate the weighted average fee per transaction for each card scheme using the merchant's transaction profile (73.12% credit, 9.98% intracountry, \u20ac91.29 average amount, and the specific ACI distribution)."
    ]
  }
]