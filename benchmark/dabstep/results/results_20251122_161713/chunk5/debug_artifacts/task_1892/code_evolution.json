[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2399,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\n# Load the payments dataset\nfile_path = '/output/chunk5/data/context/payments.csv'\ndf = pd.read_csv(file_path)\n\n# Filter the dataframe for the specific merchant 'Belles_cookbook_store'\n# and the time period March 2023 (Day of Year 60 to 90)\n# Note: 2023 is not a leap year. Jan (31) + Feb (28) = 59 days. \n# So March 1st is day 60, and March 31st is day 90.\nfiltered_df = df[\n    (df['merchant'] == 'Belles_cookbook_store') & \n    (df['day_of_year'] >= 60) & \n    (df['day_of_year'] <= 90)\n]\n\n# Print the results to verify the filter\nprint(f\"Number of transactions found: {len(filtered_df)}\")\nprint(f\"Total transaction volume: {filtered_df['eur_amount'].sum()}\")\nprint(\"\\nFirst 5 rows of filtered data:\")\nprint(filtered_df.head())",
    "execution_output": "Number of transactions found: 1277\nTotal transaction volume: 116436.32\n\nFirst 5 rows of filtered data:\n     psp_reference               merchant   card_scheme  year  hour_of_day  minute_of_hour  day_of_year  is_credit  eur_amount ip_country issuing_country device_type              ip_address           email_address             card_number shopper_interaction  card_bin  has_fraudulent_dispute  is_refused_by_adyen aci acquirer_country\n10     11539582857  Belles_cookbook_store    GlobalCard  2023           14               7           77      False       54.94         SE              SE     Android  v4QmydqCskH7TYu-B_KbNg  I2FVI0bgarR2FcTwB-pp3w  X2wgYLwKBQ-tVhTptskgdg           Ecommerce      4556                   False                False   F               US\n354    79855645555  Belles_cookbook_store        NexPay  2023           19              50           85       True       41.16         IT              IT     Android  Pf4hqvlpcgKCZoDL5-QIVQ  gwGkAP9mVQsmm5oxF7BfRg  Ptx0nqjk05MEohrSdQltOw           Ecommerce      4645                   False                False   D               US\n373    56551532215  Belles_cookbook_store  TransactPlus  2023           23              31           77       True       10.51         SE              SE       Other  -ddbJnLSBlcULW51-SEqGQ  zy0hEmNjqW5XcUn9v8OfDg  cDF5jx2wi1FFxM68M46cKw           Ecommerce      4920                   False                False   D               US\n392    13346482193  Belles_cookbook_store        NexPay  2023            8              22           90       True      175.15         BE              BE     Android                     NaN  uJxTQurTjlQJfkxtWTCpoQ  O7lSySKjh9f7Pp6osfr9Ug           Ecommerce      4133                   False                False   D               US\n644    83759521313  Belles_cookbook_store   SwiftCharge  2023            9              43           61       True      109.41         BE              BE       MacOS                     NaN  n-VzgnCreliXkr19b-R2dg  -sVMyFu7--I8lczbuNFkYA           Ecommerce      4571                   False                 True   G               US\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the dataframe to include only transactions where the `merchant` is 'Belles_cookbook_store' and the `day_of_year` is between 60 and 90 (representing March 2023)."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 7802,
    "code": "import pandas as pd\nimport json\nimport re\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if pd.isna(value) or value is None:\n        return 0.0\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean if forced, but usually handled by parsers\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except ValueError:\n            return 0.0\n    return 0.0\n\ndef parse_range(range_str):\n    \"\"\"Parses range strings like '100k-1m', '>5', '<3', '7.7%-8.3%'.\"\"\"\n    if not isinstance(range_str, str):\n        return None, None\n    \n    s = range_str.lower().strip()\n    \n    # Handle k/m suffixes\n    def parse_val(v):\n        v = v.strip()\n        mult = 1\n        if 'k' in v:\n            mult = 1000\n            v = v.replace('k', '')\n        elif 'm' in v:\n            mult = 1000000\n            v = v.replace('m', '')\n        \n        is_pct = '%' in v\n        v = v.replace('%', '')\n        \n        try:\n            val = float(v) * mult\n            if is_pct:\n                val /= 100\n            return val\n        except:\n            return None\n\n    if '>' in s:\n        val = parse_val(s.replace('>', ''))\n        return val, float('inf')\n    elif '<' in s:\n        val = parse_val(s.replace('<', ''))\n        return float('-inf'), val\n    elif '-' in s:\n        parts = s.split('-')\n        if len(parts) == 2:\n            return parse_val(parts[0]), parse_val(parts[1])\n            \n    # Exact value or fallback\n    val = parse_val(s)\n    return val, val\n\ndef match_fee_rule(tx_ctx, rule):\n    \"\"\"\n    Checks if a transaction context matches a fee rule.\n    tx_ctx: dict containing transaction and merchant details\n    rule: dict from fees.json\n    \"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_ctx.get('card_scheme'):\n        return False\n\n    # 2. Account Type (List match, empty list = wildcard)\n    if rule.get('account_type'):\n        if tx_ctx.get('account_type') not in rule['account_type']:\n            return False\n\n    # 3. Merchant Category Code (List match, empty list = wildcard)\n    if rule.get('merchant_category_code'):\n        if tx_ctx.get('mcc') not in rule['merchant_category_code']:\n            return False\n\n    # 4. Is Credit (Boolean match, None = wildcard)\n    if rule.get('is_credit') is not None:\n        # Ensure boolean comparison\n        rule_credit = bool(rule['is_credit'])\n        tx_credit = bool(tx_ctx.get('is_credit'))\n        if rule_credit != tx_credit:\n            return False\n\n    # 5. ACI (List match, empty list = wildcard)\n    if rule.get('aci'):\n        if tx_ctx.get('aci') not in rule['aci']:\n            return False\n\n    # 6. Intracountry (Boolean match, None = wildcard)\n    if rule.get('intracountry') is not None:\n        # Intracountry means Issuer Country == Acquirer Country\n        is_intra = tx_ctx.get('issuing_country') == tx_ctx.get('acquirer_country')\n        # Handle string '0.0'/'1.0' or float 0.0/1.0 in JSON\n        rule_intra_val = rule['intracountry']\n        if isinstance(rule_intra_val, str):\n            rule_intra = (float(rule_intra_val) == 1.0)\n        else:\n            rule_intra = (float(rule_intra_val) == 1.0)\n            \n        if rule_intra != is_intra:\n            return False\n\n    # 7. Monthly Volume (Range match)\n    if rule.get('monthly_volume'):\n        min_v, max_v = parse_range(rule['monthly_volume'])\n        vol = tx_ctx.get('monthly_volume', 0)\n        if min_v is not None and vol < min_v:\n            return False\n        if max_v is not None and vol > max_v:\n            return False\n\n    # 8. Monthly Fraud Level (Range match)\n    if rule.get('monthly_fraud_level'):\n        min_f, max_f = parse_range(rule['monthly_fraud_level'])\n        fraud = tx_ctx.get('monthly_fraud_level', 0)\n        if min_f is not None and fraud < min_f:\n            return False\n        if max_f is not None and fraud > max_f:\n            return False\n\n    return True\n\n# ---------------------------------------------------------\n# MAIN SCRIPT\n# ---------------------------------------------------------\n\n# 1. Load Data\npayments_path = '/output/chunk5/data/context/payments.csv'\nfees_path = '/output/chunk5/data/context/fees.json'\nmerchant_path = '/output/chunk5/data/context/merchant_data.json'\n\ndf = pd.read_csv(payments_path)\nwith open(fees_path, 'r') as f:\n    fees = json.load(f)\nwith open(merchant_path, 'r') as f:\n    merchant_data = json.load(f)\n\n# 2. Setup Target Variables\ntarget_merchant = 'Belles_cookbook_store'\ntarget_fee_id = 384\nnew_rate = 99\n\n# 3. Get Merchant Profile\nmerchant_profile = next((m for m in merchant_data if m['merchant'] == target_merchant), None)\nif not merchant_profile:\n    raise ValueError(f\"Merchant {target_merchant} not found in merchant_data.json\")\n\nmerchant_account_type = merchant_profile.get('account_type')\nmerchant_mcc = merchant_profile.get('merchant_category_code')\n\n# 4. Get Fee Rule\nfee_rule = next((f for f in fees if f['ID'] == target_fee_id), None)\nif not fee_rule:\n    raise ValueError(f\"Fee ID {target_fee_id} not found in fees.json\")\n\nold_rate = fee_rule['rate']\n\n# 5. Filter Transactions for March 2023\n# March 2023 (non-leap): Jan(31) + Feb(28) = 59. March 1 is Day 60. March 31 is Day 90.\nmarch_txs = df[\n    (df['merchant'] == target_merchant) &\n    (df['year'] == 2023) &\n    (df['day_of_year'] >= 60) &\n    (df['day_of_year'] <= 90)\n].copy()\n\n# 6. Calculate Monthly Stats for Matching\n# Manual: \"Monthly volumes and rates are computed always in natural months\"\n# We use the stats from the filtered month (March) to determine rule applicability.\nmonthly_volume = march_txs['eur_amount'].sum()\nmonthly_fraud_count = march_txs['has_fraudulent_dispute'].sum()\nmonthly_tx_count = len(march_txs)\nmonthly_fraud_level = (monthly_fraud_count / monthly_tx_count) if monthly_tx_count > 0 else 0.0\n\n# 7. Identify Matching Transactions and Calculate Affected Volume\naffected_volume = 0.0\nmatching_count = 0\n\nfor _, tx in march_txs.iterrows():\n    # Build context for this specific transaction\n    tx_context = {\n        'card_scheme': tx['card_scheme'],\n        'account_type': merchant_account_type,\n        'mcc': merchant_mcc,\n        'is_credit': tx['is_credit'],\n        'aci': tx['aci'],\n        'issuing_country': tx['issuing_country'],\n        'acquirer_country': tx['acquirer_country'],\n        'monthly_volume': monthly_volume,\n        'monthly_fraud_level': monthly_fraud_level\n    }\n    \n    if match_fee_rule(tx_context, fee_rule):\n        affected_volume += tx['eur_amount']\n        matching_count += 1\n\n# 8. Calculate Delta\n# Delta = (New Fee - Old Fee)\n# Fee = Fixed + (Rate * Amount / 10000)\n# Delta = (Fixed + NewRate*Amt/10000) - (Fixed + OldRate*Amt/10000)\n# Delta = (NewRate - OldRate) * Amt / 10000\nrate_diff = new_rate - old_rate\ndelta = rate_diff * affected_volume / 10000\n\n# 9. Output\nprint(f\"Merchant: {target_merchant}\")\nprint(f\"Month: March 2023\")\nprint(f\"Fee ID: {target_fee_id}\")\nprint(f\"Old Rate: {old_rate}\")\nprint(f\"New Rate: {new_rate}\")\nprint(f\"Matching Transactions: {matching_count}\")\nprint(f\"Affected Volume: {affected_volume:.2f}\")\nprint(f\"Delta: {delta:.14f}\")",
    "execution_output": "Merchant: Belles_cookbook_store\nMonth: March 2023\nFee ID: 384\nOld Rate: 14\nNew Rate: 99\nMatching Transactions: 13\nAffected Volume: 742.35\nDelta: 6.30997500000000\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the dataframe to include only transactions where the `merchant` is 'Belles_cookbook_store' and the `day_of_year` is between 60 and 90 (representing March 2023).",
      "Load `fees.json` and `merchant_data.json` to retrieve the details for fee ID=384 and the profile for 'Belles_cookbook_store', then filter the previously identified March 2023 transactions to find those matching the fee rule's criteria (considering card scheme, ACI, account type, MCC, and intracountry status), and finally calculate the payment delta using the formula `(99 - original_rate) * matching_transaction_volume / 10000`."
    ]
  }
]