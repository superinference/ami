[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 3541,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\nimport json\n\n# Define file paths\npayments_path = '/output/chunk5/data/context/payments.csv'\nfees_path = '/output/chunk5/data/context/fees.json'\nmerchant_data_path = '/output/chunk5/data/context/merchant_data.json'\nacquirer_countries_path = '/output/chunk5/data/context/acquirer_countries.csv'\n\n# Load the datasets\ntry:\n    # Load payments.csv\n    df_payments = pd.read_csv(payments_path)\n    print(f\"Successfully loaded payments.csv. Shape: {df_payments.shape}\")\n    \n    # Load fees.json\n    # Loading as a list of dicts first is often safer for complex nested structures, \n    # then converting to DataFrame for display/filtering if needed.\n    with open(fees_path, 'r') as f:\n        fees_data = json.load(f)\n    df_fees = pd.DataFrame(fees_data)\n    print(f\"Successfully loaded fees.json. Shape: {df_fees.shape}\")\n    \n    # Load merchant_data.json\n    df_merchant_data = pd.read_json(merchant_data_path)\n    print(f\"Successfully loaded merchant_data.json. Shape: {df_merchant_data.shape}\")\n    \n    # Load acquirer_countries.csv\n    df_acquirer_countries = pd.read_csv(acquirer_countries_path)\n    print(f\"Successfully loaded acquirer_countries.csv. Shape: {df_acquirer_countries.shape}\")\n\n    # Display a preview of the payments data to verify columns (especially 'merchant', 'year', 'day_of_year', 'eur_amount')\n    print(\"\\n--- Payments Data Preview ---\")\n    print(df_payments[['merchant', 'year', 'day_of_year', 'eur_amount', 'acquirer_country']].head())\n\n    # Display a preview of the fees data to verify structure (nested lists like 'merchant_category_code', 'aci')\n    print(\"\\n--- Fees Data Preview ---\")\n    print(df_fees[['card_scheme', 'merchant_category_code', 'aci', 'fixed_amount', 'rate']].head())\n\nexcept FileNotFoundError as e:\n    print(f\"Error: File not found - {e}\")\nexcept Exception as e:\n    print(f\"An error occurred during data loading: {e}\")",
    "execution_output": "Successfully loaded payments.csv. Shape: (138236, 21)\nSuccessfully loaded fees.json. Shape: (1000, 12)\nSuccessfully loaded merchant_data.json. Shape: (30, 5)\nSuccessfully loaded acquirer_countries.csv. Shape: (8, 3)\n\n--- Payments Data Preview ---\n                merchant  year  day_of_year  eur_amount acquirer_country\n0         Crossfit_Hanna  2023           12      151.74               NL\n1         Crossfit_Hanna  2023           75       45.70               NL\n2  Belles_cookbook_store  2023           96       14.11               US\n3         Crossfit_Hanna  2023           77      238.42               NL\n4         Crossfit_Hanna  2023           83       67.13               NL\n\n--- Fees Data Preview ---\n    card_scheme                            merchant_category_code     aci  fixed_amount  rate\n0  TransactPlus  [8000, 8011, 8021, 8031, 8041, 7299, 9399, 8742]  [C, B]          0.10    19\n1    GlobalCard  [3000, 3001, 3002, 3003, 7011, 7032, 7512, 7513]     [B]          0.13    86\n2  TransactPlus  [4111, 4121, 4131, 4411, 4511, 4789, 7513, 7523]  [C, A]          0.09    16\n3        NexPay        [8062, 8011, 8021, 7231, 7298, 7991, 8049]  [C, A]          0.11    25\n4    GlobalCard  [5411, 5412, 5499, 5912, 5812, 5813, 5911, 5983]      []          0.13    69\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv`, `fees.json`, `merchant_data.json`, and `acquirer_countries.csv` files into pandas DataFrames to prepare for filtering transactions and calculating fees."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 7957,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except:\n            return 0.0\n    return float(value)\n\ndef parse_range_tuple(range_str):\n    \"\"\"Parses a range string into (min, max).\"\"\"\n    if range_str is None:\n        return (-float('inf'), float('inf'))\n    \n    s = str(range_str).strip().lower()\n    if s == 'immediate': return ('immediate', 'immediate')\n    if s == 'manual': return ('manual', 'manual')\n    \n    # Clean string\n    s = s.replace('%', '').replace(',', '').replace('\u20ac', '').replace('$', '')\n    \n    # Helper to parse number with k/m\n    def p(n):\n        n = n.strip()\n        mult = 1\n        if n.endswith('k'): mult = 1000; n = n[:-1]\n        elif n.endswith('m'): mult = 1000000; n = n[:-1]\n        try: return float(n) * mult\n        except: return 0.0\n\n    if '-' in s:\n        parts = s.split('-')\n        return (p(parts[0]), p(parts[1]))\n    elif s.startswith('>'):\n        return (p(s[1:]), float('inf'))\n    elif s.startswith('<'):\n        return (-float('inf'), p(s[1:]))\n    else:\n        val = p(s)\n        return (val, val)\n\ndef check_rule_match(tx_context, rule):\n    \"\"\"\n    Checks if a fee rule applies to a specific transaction context.\n    \"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_context['card_scheme']:\n        return False\n        \n    # 2. Account Type (List contains)\n    # If rule list is empty or None, it matches all.\n    if rule.get('account_type'):\n        if tx_context['account_type'] not in rule['account_type']:\n            return False\n            \n    # 3. Merchant Category Code (List contains)\n    if rule.get('merchant_category_code'):\n        if tx_context['mcc'] not in rule['merchant_category_code']:\n            return False\n            \n    # 4. Is Credit (Bool match)\n    # Rule is_credit can be None (wildcard), True, False\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != tx_context['is_credit']:\n            return False\n            \n    # 5. ACI (List contains)\n    if rule.get('aci'):\n        if tx_context['aci'] not in rule['aci']:\n            return False\n            \n    # 6. Intracountry (Bool/Float match)\n    # Rule intracountry: None, 0.0 (False), 1.0 (True)\n    if rule.get('intracountry') is not None:\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != tx_context['is_intracountry']:\n            return False\n            \n    # 7. Capture Delay (Range match)\n    cd_val = tx_context['capture_delay']\n    cd_rule = rule.get('capture_delay')\n    if cd_rule:\n        # If rule is specific string\n        if cd_rule in ['immediate', 'manual']:\n            if cd_val != cd_rule: return False\n        elif cd_val in ['immediate', 'manual']:\n             if cd_val != cd_rule: return False\n        else:\n            # Numeric comparison\n            try:\n                val_float = float(cd_val)\n                low, high = parse_range_tuple(cd_rule)\n                if not (low <= val_float <= high):\n                    return False\n            except:\n                pass \n                \n    # 8. Monthly Volume (Range match)\n    if rule.get('monthly_volume'):\n        vol = tx_context['monthly_volume']\n        low, high = parse_range_tuple(rule['monthly_volume'])\n        if not (low <= vol <= high):\n            return False\n            \n    # 9. Monthly Fraud Level (Range match)\n    if rule.get('monthly_fraud_level'):\n        # Fraud level in rule is usually %, e.g. \"8.3%\". parse_range_tuple returns 8.3\n        # Context fraud is 0.083. Need to scale to percentage (0-100) for comparison\n        fraud_pct = tx_context['monthly_fraud_rate'] * 100.0\n        low, high = parse_range_tuple(rule['monthly_fraud_level'])\n        if not (low <= fraud_pct <= high):\n            return False\n            \n    return True\n\ndef calculate_belles_fees():\n    # Define file paths\n    payments_path = '/output/chunk5/data/context/payments.csv'\n    fees_path = '/output/chunk5/data/context/fees.json'\n    merchant_data_path = '/output/chunk5/data/context/merchant_data.json'\n\n    try:\n        # Load data\n        df_pay = pd.read_csv(payments_path)\n        with open(fees_path, 'r') as f:\n            fees = json.load(f)\n        df_merch = pd.read_json(merchant_data_path)\n        \n        # Filter for Belles_cookbook_store, September 2023\n        # September 2023 is Day 244 to 273 (Non-leap year)\n        merchant_name = 'Belles_cookbook_store'\n        mask = (\n            (df_pay['merchant'] == merchant_name) & \n            (df_pay['year'] == 2023) & \n            (df_pay['day_of_year'] >= 244) & \n            (df_pay['day_of_year'] <= 273)\n        )\n        df_belles = df_pay[mask].copy()\n        \n        if df_belles.empty:\n            print(\"No transactions found for Belles_cookbook_store in September 2023.\")\n            return\n\n        # Get Merchant Static Data\n        merch_info = df_merch[df_merch['merchant'] == merchant_name].iloc[0]\n        mcc = int(merch_info['merchant_category_code'])\n        account_type = merch_info['account_type']\n        capture_delay = str(merch_info['capture_delay']) \n        \n        # Calculate Monthly Stats (Volume & Fraud) for September 2023\n        monthly_volume = df_belles['eur_amount'].sum()\n        \n        fraud_count = df_belles['has_fraudulent_dispute'].sum()\n        total_count = len(df_belles)\n        monthly_fraud_rate = fraud_count / total_count if total_count > 0 else 0.0\n        \n        # Pre-calculate intracountry for all rows\n        df_belles['is_intracountry'] = df_belles['issuing_country'] == df_belles['acquirer_country']\n        \n        total_fees = 0.0\n        \n        # Iterate transactions to calculate fees\n        for idx, row in df_belles.iterrows():\n            # Build context for rule matching\n            ctx = {\n                'card_scheme': row['card_scheme'],\n                'is_credit': row['is_credit'],\n                'aci': row['aci'],\n                'is_intracountry': row['is_intracountry'],\n                'eur_amount': row['eur_amount'],\n                'mcc': mcc,\n                'account_type': account_type,\n                'capture_delay': capture_delay,\n                'monthly_volume': monthly_volume,\n                'monthly_fraud_rate': monthly_fraud_rate\n            }\n            \n            # Find matching rule (First match wins)\n            matched_rule = None\n            for rule in fees:\n                if check_rule_match(ctx, rule):\n                    matched_rule = rule\n                    break \n            \n            if matched_rule:\n                # Calculate fee: fixed + (rate * amount / 10000)\n                fixed = float(matched_rule['fixed_amount'])\n                rate = float(matched_rule['rate'])\n                fee = fixed + (rate * row['eur_amount'] / 10000.0)\n                total_fees += fee\n            else:\n                # Fallback or warning if no rule matches (should not happen with complete ruleset)\n                pass\n                \n        # Output the final result\n        print(f\"{total_fees:.2f}\")\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    calculate_belles_fees()",
    "execution_output": "217.67\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv`, `fees.json`, `merchant_data.json`, and `acquirer_countries.csv` files into pandas DataFrames to prepare for filtering transactions and calculating fees.",
      "Filter the `payments` DataFrame for 'Belles_cookbook_store' and the month of September 2023 (day_of_year 244 to 273), then calculate the merchant's total monthly volume and fraud rate (needed for fee rules), retrieve the merchant's static attributes (MCC, account type, capture delay) from `merchant_data`, and add an `intracountry` column to the transactions."
    ]
  }
]