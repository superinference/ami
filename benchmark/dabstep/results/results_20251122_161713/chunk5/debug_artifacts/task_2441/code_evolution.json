[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 3534,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\nimport json\n\n# Define file paths\npayments_path = '/output/chunk5/data/context/payments.csv'\nfees_path = '/output/chunk5/data/context/fees.json'\nmerchant_data_path = '/output/chunk5/data/context/merchant_data.json'\n\n# Load data\nprint(\"Loading data files...\")\ntry:\n    payments_df = pd.read_csv(payments_path)\n    with open(fees_path, 'r') as f:\n        fees_data = json.load(f)\n    with open(merchant_data_path, 'r') as f:\n        merchant_data = json.load(f)\n    print(\"Files loaded successfully.\")\nexcept FileNotFoundError as e:\n    print(f\"Error loading files: {e}\")\n    exit()\n\n# Filter criteria\ntarget_merchant = 'Rafa_AI'\ntarget_year = 2023\nstart_day = 274  # October 1st\nend_day = 304    # October 31st\n\n# Apply filtering\nprint(f\"Filtering for merchant '{target_merchant}' in October {target_year} (Day {start_day}-{end_day})...\")\nfiltered_df = payments_df[\n    (payments_df['merchant'] == target_merchant) &\n    (payments_df['year'] == target_year) &\n    (payments_df['day_of_year'] >= start_day) &\n    (payments_df['day_of_year'] <= end_day)\n].copy()\n\n# Verification\nprint(f\"\\nFiltered Dataset Summary:\")\nprint(f\"Total transactions found: {len(filtered_df)}\")\nprint(f\"Day of year range: {filtered_df['day_of_year'].min()} to {filtered_df['day_of_year'].max()}\")\n\n# Display sample rows to verify against ground truth\n# Columns chosen to match the ground truth sample format: Scheme, Credit, Amount, Issuing, ACI, Acquirer\nprint(\"\\nSample transactions (first 10):\")\nsample_cols = ['card_scheme', 'is_credit', 'eur_amount', 'issuing_country', 'aci', 'acquirer_country']\nprint(filtered_df[sample_cols].head(10))\n\n# Check if the count matches the expected 2369\nif len(filtered_df) == 2369:\n    print(\"\\nSUCCESS: Transaction count matches expected volume (2369).\")\nelse:\n    print(f\"\\nWARNING: Transaction count ({len(filtered_df)}) differs from expected (2369).\")",
    "execution_output": "Loading data files...\nFiles loaded successfully.\nFiltering for merchant 'Rafa_AI' in October 2023 (Day 274-304)...\n\nFiltered Dataset Summary:\nTotal transactions found: 2369\nDay of year range: 274 to 304\n\nSample transactions (first 10):\n      card_scheme  is_credit  eur_amount issuing_country aci acquirer_country\n47     GlobalCard       True       27.04              IT   E               NL\n51   TransactPlus       True       45.61              SE   E               NL\n75     GlobalCard       True       80.14              IT   E               NL\n108        NexPay       True       60.41              SE   E               NL\n136    GlobalCard       True       56.21              BE   E               NL\n143   SwiftCharge       True       46.07              FR   G               NL\n173    GlobalCard       True       17.57              BE   E               NL\n183        NexPay      False      100.68              NL   E               NL\n365   SwiftCharge       True       43.53              FR   C               NL\n389        NexPay       True      417.13              GR   C               NL\n\nSUCCESS: Transaction count matches expected volume (2369).\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv`, `fees.json`, and `merchant_data.json` files, and filter the `payments.csv` dataset to include only transactions where the `merchant` is 'Rafa_AI' and the date falls within October 2023 (specifically, `year` is 2023 and `day_of_year` is between 274 and 304)."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 7901,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# --- HELPER FUNCTIONS ---\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef check_range(value, rule_str):\n    \"\"\"Checks if numeric value fits in rule_str (e.g. '>5', '100k-1m', '8.3%').\"\"\"\n    if rule_str is None:\n        return True\n    \n    s = str(rule_str).strip().lower().replace(',', '')\n    \n    # Handle percentages\n    is_pct = '%' in s\n    if is_pct:\n        s = s.replace('%', '')\n        \n    # Handle k/m suffixes\n    mult = 1\n    if 'k' in s: mult = 1000; s = s.replace('k', '')\n    elif 'm' in s: mult = 1000000; s = s.replace('m', '')\n    \n    try:\n        if '-' in s:\n            parts = s.split('-')\n            low = float(parts[0]) * mult\n            high = float(parts[1]) * mult\n            if is_pct: low/=100; high/=100\n            return low <= value <= high\n        elif s.startswith('>'):\n            limit = float(s[1:]) * mult\n            if is_pct: limit/=100\n            return value > limit\n        elif s.startswith('<'):\n            limit = float(s[1:]) * mult\n            if is_pct: limit/=100\n            return value < limit\n        else:\n            target = float(s) * mult\n            if is_pct: target/=100\n            return value == target\n    except:\n        return False\n\ndef match_fee_rule(tx_ctx, rule):\n    \"\"\"\n    Matches a transaction context against a fee rule.\n    tx_ctx: dict containing transaction and merchant details\n    rule: dict representing a fee rule\n    \"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_ctx.get('card_scheme'):\n        return False\n\n    # 2. Account Type (List match - wildcard if empty)\n    if is_not_empty(rule.get('account_type')):\n        if tx_ctx.get('account_type') not in rule['account_type']:\n            return False\n\n    # 3. Merchant Category Code (List match - wildcard if empty)\n    if is_not_empty(rule.get('merchant_category_code')):\n        # Ensure types match (int vs str)\n        try:\n            mcc_rule = [int(x) for x in rule['merchant_category_code']]\n            if int(tx_ctx.get('mcc')) not in mcc_rule:\n                return False\n        except:\n            return False\n\n    # 4. Capture Delay (Mixed match)\n    if rule.get('capture_delay'):\n        r_cd = str(rule['capture_delay']).lower()\n        t_cd = str(tx_ctx.get('capture_delay')).lower()\n        \n        # Exact string match first (e.g. 'manual', 'immediate')\n        if r_cd == t_cd:\n            pass \n        # Check if rule is a range/inequality\n        elif any(x in r_cd for x in ['<', '>', '-']):\n            try:\n                t_val = float(t_cd)\n                if not check_range(t_val, r_cd):\n                    return False\n            except ValueError:\n                # Tx is 'manual' but rule is numeric range -> No match\n                return False\n        else:\n            # Rule is specific value but didn't match string above\n            if r_cd != t_cd:\n                return False\n\n    # 5. Monthly Fraud Level (Range match)\n    if rule.get('monthly_fraud_level'):\n        if not check_range(tx_ctx.get('monthly_fraud_percent', 0), rule['monthly_fraud_level']):\n            return False\n\n    # 6. Monthly Volume (Range match)\n    if rule.get('monthly_volume'):\n        if not check_range(tx_ctx.get('monthly_volume', 0), rule['monthly_volume']):\n            return False\n\n    # 7. Is Credit (Bool match)\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != tx_ctx.get('is_credit'):\n            return False\n\n    # 8. ACI (List match)\n    if is_not_empty(rule.get('aci')):\n        if tx_ctx.get('aci') not in rule['aci']:\n            return False\n\n    # 9. Intracountry (Bool match)\n    if rule.get('intracountry') is not None:\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != tx_ctx.get('intracountry'):\n            return False\n\n    return True\n\n# --- MAIN SCRIPT ---\n\n# 1. Load Data\npayments_path = '/output/chunk5/data/context/payments.csv'\nfees_path = '/output/chunk5/data/context/fees.json'\nmerchant_data_path = '/output/chunk5/data/context/merchant_data.json'\n\ntry:\n    payments_df = pd.read_csv(payments_path)\n    with open(fees_path, 'r') as f:\n        fees_data = json.load(f)\n    with open(merchant_data_path, 'r') as f:\n        merchant_data = json.load(f)\nexcept FileNotFoundError as e:\n    print(f\"Error loading files: {e}\")\n    exit()\n\n# 2. Filter for Rafa_AI in October 2023\ntarget_merchant = 'Rafa_AI'\ntarget_year = 2023\nstart_day = 274\nend_day = 304\n\ndf_oct = payments_df[\n    (payments_df['merchant'] == target_merchant) &\n    (payments_df['year'] == target_year) &\n    (payments_df['day_of_year'] >= start_day) &\n    (payments_df['day_of_year'] <= end_day)\n].copy()\n\n# 3. Get Merchant Attributes\nmerch_info = next((m for m in merchant_data if m['merchant'] == target_merchant), None)\nif not merch_info:\n    print(\"Merchant not found\")\n    exit()\n\n# 4. Calculate Monthly Stats (Volume & Fraud)\n# Volume in EUR\nmonthly_vol = df_oct['eur_amount'].sum()\n# Fraud Rate (Ratio)\nfraud_count = df_oct['has_fraudulent_dispute'].sum()\ntotal_count = len(df_oct)\nmonthly_fraud_ratio = fraud_count / total_count if total_count > 0 else 0.0\n\n# 5. Get Target Fee Rule (ID 384)\ntarget_rule_id = 384\ntarget_rule = next((r for r in fees_data if r['ID'] == target_rule_id), None)\nif not target_rule:\n    print(f\"Fee ID {target_rule_id} not found\")\n    exit()\n\nold_rate = target_rule['rate']\nnew_rate = 1\n\n# 6. Identify Affected Transactions\n# Iterate through transactions and find which ones resolve to ID 384 as the FIRST matching rule.\naffected_amount_sum = 0.0\ncount_affected = 0\n\n# Pre-calculate merchant context parts that don't change per transaction\nbase_ctx = {\n    'account_type': merch_info['account_type'],\n    'mcc': merch_info['merchant_category_code'],\n    'capture_delay': merch_info['capture_delay'],\n    'monthly_volume': monthly_vol,\n    'monthly_fraud_percent': monthly_fraud_ratio\n}\n\nfor _, tx in df_oct.iterrows():\n    # Build full context\n    is_intra = (tx['issuing_country'] == tx['acquirer_country'])\n    \n    ctx = base_ctx.copy()\n    ctx.update({\n        'card_scheme': tx['card_scheme'],\n        'is_credit': tx['is_credit'],\n        'aci': tx['aci'],\n        'intracountry': is_intra\n    })\n    \n    # Find winning rule\n    winning_rule_id = None\n    for rule in fees_data:\n        if match_fee_rule(ctx, rule):\n            winning_rule_id = rule['ID']\n            break # First match wins\n            \n    if winning_rule_id == target_rule_id:\n        affected_amount_sum += tx['eur_amount']\n        count_affected += 1\n\n# 7. Calculate Delta\n# Fee = Fixed + (Rate * Amount / 10000)\n# Delta = New_Fee - Old_Fee\n#       = (Fixed + New_Rate*Amt/10000) - (Fixed + Old_Rate*Amt/10000)\n#       = (New_Rate - Old_Rate) * Amt / 10000\n\ndelta = (new_rate - old_rate) * affected_amount_sum / 10000\n\n# Output result with high precision\nprint(f\"{delta:.14f}\")",
    "execution_output": "-2.87721200000000\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv`, `fees.json`, and `merchant_data.json` files, and filter the `payments.csv` dataset to include only transactions where the `merchant` is 'Rafa_AI' and the date falls within October 2023 (specifically, `year` is 2023 and `day_of_year` is between 274 and 304).",
      "Calculate the total monthly transaction volume and fraud rate for 'Rafa_AI' in October 2023 from the filtered data, extract 'Rafa_AI's attributes (merchant_category_code, account_type, capture_delay) from `merchant_data.json`, and retrieve the details of fee rule ID=384 from `fees.json`."
    ]
  },
  {
    "round": 3,
    "plan_steps": 2,
    "code_length": 7206,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# --- HELPER FUNCTIONS ---\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if value is None:\n        return 0.0\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except:\n            return 0.0\n    return 0.0\n\ndef is_not_empty(obj):\n    \"\"\"Check if list/array is not empty/None.\"\"\"\n    if obj is None:\n        return False\n    if isinstance(obj, list):\n        return len(obj) > 0\n    if hasattr(obj, 'size'):\n        return obj.size > 0\n    return False\n\ndef check_range(value, rule_str):\n    \"\"\"Checks if numeric value fits in rule_str (e.g. '>5', '100k-1m', '8.3%').\"\"\"\n    if rule_str is None:\n        return True\n    \n    s = str(rule_str).strip().lower().replace(',', '')\n    \n    # Handle percentages\n    is_pct = '%' in s\n    if is_pct:\n        s = s.replace('%', '')\n        \n    # Handle k/m suffixes\n    mult = 1\n    if 'k' in s: mult = 1000; s = s.replace('k', '')\n    elif 'm' in s: mult = 1000000; s = s.replace('m', '')\n    \n    try:\n        if '-' in s:\n            parts = s.split('-')\n            low = float(parts[0]) * mult\n            high = float(parts[1]) * mult\n            if is_pct: low/=100; high/=100\n            return low <= value <= high\n        elif s.startswith('>'):\n            limit = float(s[1:]) * mult\n            if is_pct: limit/=100\n            return value > limit\n        elif s.startswith('<'):\n            limit = float(s[1:]) * mult\n            if is_pct: limit/=100\n            return value < limit\n        else:\n            target = float(s) * mult\n            if is_pct: target/=100\n            return value == target\n    except:\n        return False\n\ndef match_fee_rule(tx_ctx, rule):\n    \"\"\"\n    Matches a transaction context against a fee rule.\n    tx_ctx keys: card_scheme, account_type, mcc, capture_delay, monthly_fraud_percent, \n                 monthly_volume, is_credit, aci, intracountry\n    \"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_ctx.get('card_scheme'):\n        return False\n\n    # 2. Account Type (List match - wildcard if empty)\n    if is_not_empty(rule.get('account_type')):\n        if tx_ctx.get('account_type') not in rule['account_type']:\n            return False\n\n    # 3. Merchant Category Code (List match - wildcard if empty)\n    if is_not_empty(rule.get('merchant_category_code')):\n        try:\n            if int(tx_ctx.get('mcc')) not in [int(x) for x in rule['merchant_category_code']]:\n                return False\n        except:\n            return False\n\n    # 4. Capture Delay (Mixed match)\n    if rule.get('capture_delay'):\n        r_cd = str(rule['capture_delay']).lower()\n        t_cd = str(tx_ctx.get('capture_delay')).lower()\n        \n        if any(x in r_cd for x in ['<', '>', '-']):\n            try:\n                t_val = float(t_cd)\n                if not check_range(t_val, r_cd):\n                    return False\n            except ValueError:\n                return False\n        else:\n            if r_cd != t_cd:\n                return False\n\n    # 5. Monthly Fraud Level (Range match)\n    if rule.get('monthly_fraud_level'):\n        if not check_range(tx_ctx.get('monthly_fraud_percent', 0), rule['monthly_fraud_level']):\n            return False\n\n    # 6. Monthly Volume (Range match)\n    if rule.get('monthly_volume'):\n        if not check_range(tx_ctx.get('monthly_volume', 0), rule['monthly_volume']):\n            return False\n\n    # 7. Is Credit (Bool match)\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != tx_ctx.get('is_credit'):\n            return False\n\n    # 8. ACI (List match)\n    if is_not_empty(rule.get('aci')):\n        if tx_ctx.get('aci') not in rule['aci']:\n            return False\n\n    # 9. Intracountry (Bool match)\n    if rule.get('intracountry') is not None:\n        r_intra = bool(rule['intracountry'])\n        if r_intra != tx_ctx.get('intracountry'):\n            return False\n\n    return True\n\n# --- MAIN SCRIPT ---\npayments_path = '/output/chunk5/data/context/payments.csv'\nfees_path = '/output/chunk5/data/context/fees.json'\nmerchant_data_path = '/output/chunk5/data/context/merchant_data.json'\n\n# 1. Load Data\ntry:\n    df = pd.read_csv(payments_path)\n    with open(fees_path, 'r') as f:\n        fees = json.load(f)\n    with open(merchant_data_path, 'r') as f:\n        merchants = json.load(f)\nexcept Exception as e:\n    print(f\"Error loading files: {e}\")\n    exit()\n\n# 2. Filter for Rafa_AI in October 2023 (Day 274-304)\ntarget_merchant = 'Rafa_AI'\ndf_oct = df[\n    (df['merchant'] == target_merchant) &\n    (df['year'] == 2023) &\n    (df['day_of_year'] >= 274) &\n    (df['day_of_year'] <= 304)\n].copy()\n\nif df_oct.empty:\n    print(\"0.00000000000000\")\n    exit()\n\n# 3. Get Merchant Attributes\nmerch_info = next((m for m in merchants if m['merchant'] == target_merchant), None)\nif not merch_info:\n    print(\"Merchant not found\")\n    exit()\n\n# 4. Calculate Monthly Stats (Volume & Fraud)\n# Manual: \"monthly_fraud_level... ratio between monthly total volume and monthly volume notified as fraud\"\nmonthly_vol = df_oct['eur_amount'].sum()\nfraud_vol = df_oct[df_oct['has_fraudulent_dispute']]['eur_amount'].sum()\nmonthly_fraud_ratio = fraud_vol / monthly_vol if monthly_vol > 0 else 0.0\n\n# 5. Get Target Rule (ID 384)\ntarget_rule_id = 384\ntarget_rule = next((r for r in fees if r['ID'] == target_rule_id), None)\nif not target_rule:\n    print(\"Rule 384 not found\")\n    exit()\n\nold_rate = target_rule['rate']\nnew_rate = 1\n\n# 6. Iterate transactions to find matches\naffected_amount = 0.0\n\n# Pre-compute static context\nstatic_ctx = {\n    'account_type': merch_info['account_type'],\n    'mcc': merch_info['merchant_category_code'],\n    'capture_delay': merch_info['capture_delay'],\n    'monthly_volume': monthly_vol,\n    'monthly_fraud_percent': monthly_fraud_ratio\n}\n\n# Sort fees by ID to ensure correct priority (assuming ID 1 is highest priority)\nfees.sort(key=lambda x: x['ID'])\n\nfor _, tx in df_oct.iterrows():\n    # Dynamic context\n    is_intra = (tx['issuing_country'] == tx['acquirer_country'])\n    ctx = static_ctx.copy()\n    ctx.update({\n        'card_scheme': tx['card_scheme'],\n        'is_credit': tx['is_credit'],\n        'aci': tx['aci'],\n        'intracountry': is_intra\n    })\n    \n    # Find first matching rule\n    matched_id = None\n    for rule in fees:\n        if match_fee_rule(ctx, rule):\n            matched_id = rule['ID']\n            break\n            \n    if matched_id == target_rule_id:\n        affected_amount += tx['eur_amount']\n\n# 7. Calculate Delta\n# Delta = (New Rate - Old Rate) * Amount / 10000\ndelta = (new_rate - old_rate) * affected_amount / 10000\n\nprint(f\"{delta:.14f}\")",
    "execution_output": "-2.87721200000000\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "sufficient",
    "temperature": 0.25,
    "plan_snapshot": [
      "Load the `payments.csv`, `fees.json`, and `merchant_data.json` files, and filter the `payments.csv` dataset to include only transactions where the `merchant` is 'Rafa_AI' and the date falls within October 2023 (specifically, `year` is 2023 and `day_of_year` is between 274 and 304).",
      "Load `payments.csv`, `fees.json`, and `merchant_data.json`. Filter `payments` for merchant 'Rafa_AI' in October 2023 (days 274-304). Calculate the merchant's total monthly volume and fraud rate for October. Then, for each transaction, determine the applicable fee rule by iterating through `fees.json` in order and matching all criteria (card scheme, account type, MCC, ACI, is_credit, capture delay, intracountry, monthly volume, and fraud level), treating nulls as wildcards. Identify transactions where the applicable rule ID is 384. For these transactions, calculate the total delta using the formula: sum((1 - original_rate) * eur_amount / 10000)."
    ]
  }
]