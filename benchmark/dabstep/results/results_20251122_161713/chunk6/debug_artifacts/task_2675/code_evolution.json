[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2429,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\n# Define file path\npayments_path = '/output/chunk6/data/context/payments.csv'\n\n# Load the payments data\ndf = pd.read_csv(payments_path)\n\n# Filter for merchant 'Rafa_AI'\nmerchant_mask = df['merchant'] == 'Rafa_AI'\n\n# Filter for October (day_of_year between 274 and 304 inclusive)\n# Note: 274 is Oct 1st, 304 is Oct 31st in a non-leap year (2023 is non-leap)\ndate_mask = (df['day_of_year'] >= 274) & (df['day_of_year'] <= 304)\n\n# Apply filters\nfiltered_df = df[merchant_mask & date_mask].copy()\n\n# Display verification stats\nprint(f\"Total rows in dataset: {len(df)}\")\nprint(f\"Rows for Rafa_AI in October: {len(filtered_df)}\")\nprint(\"\\nSample of filtered data:\")\nprint(filtered_df[['psp_reference', 'merchant', 'day_of_year', 'eur_amount', 'card_scheme']].head())",
    "execution_output": "Total rows in dataset: 138236\nRows for Rafa_AI in October: 2369\n\nSample of filtered data:\n     psp_reference merchant  day_of_year  eur_amount   card_scheme\n47     66523455495  Rafa_AI          282       27.04    GlobalCard\n51     62233380230  Rafa_AI          276       45.61  TransactPlus\n75     12774624141  Rafa_AI          303       80.14    GlobalCard\n108    43256077269  Rafa_AI          285       60.41        NexPay\n136    73126567613  Rafa_AI          285       56.21    GlobalCard\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the dataframe to include only rows where the `merchant` column is 'Rafa_AI' and the `day_of_year` column is between 274 and 304 (representing the month of October)."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 7253,
    "code": "import pandas as pd\nimport json\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas, k, m to float.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if value is None:\n        return 0.0\n    if isinstance(value, str):\n        v = value.strip().lower().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        if 'k' in v:\n            return float(v.replace('k', '')) * 1000\n        if 'm' in v:\n            return float(v.replace('m', '')) * 1000000\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except ValueError:\n            return 0.0\n    return float(value)\n\ndef check_range(rule_value, actual_value):\n    \"\"\"\n    Check if actual_value fits in rule_value range (string).\n    Handles formats like \"100k-1m\", \">5\", \"7.7%-8.3%\", etc.\n    \"\"\"\n    if rule_value is None:\n        return True\n    \n    # Clean rule string\n    rv = str(rule_value).strip().lower().replace(',', '').replace('%', '')\n    \n    # Helper to parse k/m suffixes\n    def parse_val(x):\n        if 'k' in x: return float(x.replace('k','')) * 1000\n        if 'm' in x: return float(x.replace('m','')) * 1000000\n        return float(x)\n\n    try:\n        if '-' in rv:\n            low, high = map(parse_val, rv.split('-'))\n            return low <= actual_value <= high\n        if rv.startswith('>='):\n            limit = parse_val(rv[2:])\n            return actual_value >= limit\n        if rv.startswith('<='):\n            limit = parse_val(rv[2:])\n            return actual_value <= limit\n        if rv.startswith('>'):\n            limit = parse_val(rv[1:])\n            return actual_value > limit\n        if rv.startswith('<'):\n            limit = parse_val(rv[1:])\n            return actual_value < limit\n        # Exact match\n        return actual_value == parse_val(rv)\n    except:\n        return False\n\ndef match_fee_rule(tx, rule):\n    \"\"\"\n    Check if a fee rule applies to a transaction context.\n    \"\"\"\n    # 1. Card Scheme\n    if rule['card_scheme'] != tx['card_scheme']:\n        return False\n\n    # 2. Account Type (List in rule)\n    if rule['account_type'] and tx['account_type'] not in rule['account_type']:\n        return False\n\n    # 3. Merchant Category Code (List in rule)\n    if rule['merchant_category_code'] and tx['mcc'] not in rule['merchant_category_code']:\n        return False\n\n    # 4. Capture Delay\n    if rule['capture_delay']:\n        if rule['capture_delay'] in ['immediate', 'manual']:\n            if tx['capture_delay'] != rule['capture_delay']:\n                return False\n        else:\n            # Numeric range check for days\n            if tx['capture_delay'] in ['immediate', 'manual']:\n                return False\n            try:\n                delay_days = float(tx['capture_delay'])\n                if not check_range(rule['capture_delay'], delay_days):\n                    return False\n            except:\n                return False\n\n    # 5. Monthly Volume (Range string vs Float)\n    if rule['monthly_volume']:\n        if not check_range(rule['monthly_volume'], tx['monthly_volume']):\n            return False\n\n    # 6. Monthly Fraud Level (Range string vs Float Percentage)\n    if rule['monthly_fraud_level']:\n        # Rule is like \"7.7%-8.3%\". tx['monthly_fraud_level'] is ratio (e.g. 0.08).\n        # check_range strips %. We pass percentage (8.0) to match \"7.7-8.3\".\n        fraud_pct = tx['monthly_fraud_level'] * 100\n        if not check_range(rule['monthly_fraud_level'], fraud_pct):\n            return False\n\n    # 7. Is Credit\n    if rule['is_credit'] is not None:\n        if rule['is_credit'] != tx['is_credit']:\n            return False\n\n    # 8. ACI (List in rule)\n    if rule['aci'] and tx['aci'] not in rule['aci']:\n        return False\n\n    # 9. Intracountry\n    if rule['intracountry'] is not None:\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != tx['intracountry']:\n            return False\n\n    return True\n\ndef calculate_fee(amount, rule):\n    return rule['fixed_amount'] + (rule['rate'] * amount / 10000)\n\n# ---------------------------------------------------------\n# MAIN SCRIPT\n# ---------------------------------------------------------\n\n# 1. Load Data\npayments_path = '/output/chunk6/data/context/payments.csv'\nfees_path = '/output/chunk6/data/context/fees.json'\nmerchant_path = '/output/chunk6/data/context/merchant_data.json'\n\ndf = pd.read_csv(payments_path)\nwith open(fees_path, 'r') as f:\n    fees = json.load(f)\nwith open(merchant_path, 'r') as f:\n    merchant_data = json.load(f)\n\n# 2. Filter for Rafa_AI and October (Day 274-304)\nmerchant_name = 'Rafa_AI'\ndf_oct = df[\n    (df['merchant'] == merchant_name) & \n    (df['day_of_year'] >= 274) & \n    (df['day_of_year'] <= 304)\n].copy()\n\n# 3. Get Merchant Attributes\nm_info = next((m for m in merchant_data if m['merchant'] == merchant_name), None)\nif not m_info:\n    raise ValueError(f\"Merchant {merchant_name} not found\")\n\nmcc = m_info['merchant_category_code']\naccount_type = m_info['account_type']\ncapture_delay = m_info['capture_delay']\n\n# 4. Calculate Monthly Stats (Volume & Fraud)\ntotal_volume = df_oct['eur_amount'].sum()\nfraud_volume = df_oct[df_oct['has_fraudulent_dispute']]['eur_amount'].sum()\nfraud_rate = fraud_volume / total_volume if total_volume > 0 else 0.0\n\n# 5. Pre-calculate Intracountry status\n# Intracountry = Issuing Country matches Acquirer Country\ndf_oct['intracountry'] = df_oct['issuing_country'] == df_oct['acquirer_country']\n\n# 6. Simulate Fees for Each Scheme\nschemes = ['NexPay', 'GlobalCard', 'SwiftCharge', 'TransactPlus']\nscheme_totals = {}\n\nfor scheme in schemes:\n    total_fee = 0.0\n    \n    for _, row in df_oct.iterrows():\n        # Construct transaction context, forcing the current scheme\n        tx_ctx = {\n            'card_scheme': scheme,\n            'account_type': account_type,\n            'mcc': mcc,\n            'capture_delay': capture_delay,\n            'monthly_volume': total_volume,\n            'monthly_fraud_level': fraud_rate,\n            'is_credit': row['is_credit'],\n            'aci': row['aci'],\n            'intracountry': row['intracountry']\n        }\n        \n        # Find applicable rule\n        matched_rule = None\n        for rule in fees:\n            if match_fee_rule(tx_ctx, rule):\n                matched_rule = rule\n                break\n        \n        if matched_rule:\n            total_fee += calculate_fee(row['eur_amount'], matched_rule)\n            \n    scheme_totals[scheme] = total_fee\n\n# 7. Determine Winner\nmax_scheme = max(scheme_totals, key=scheme_totals.get)\n\nprint(f\"Merchant: {merchant_name}\")\nprint(f\"October Volume: \u20ac{total_volume:,.2f}\")\nprint(f\"October Fraud Rate: {fraud_rate:.2%}\")\nprint(\"-\" * 30)\nprint(\"Projected Total Fees by Scheme:\")\nfor s, f in scheme_totals.items():\n    print(f\"{s}: \u20ac{f:,.2f}\")\nprint(\"-\" * 30)\nprint(max_scheme)",
    "execution_output": "Merchant: Rafa_AI\nOctober Volume: \u20ac210,706.07\nOctober Fraud Rate: 10.61%\n------------------------------\nProjected Total Fees by Scheme:\nNexPay: \u20ac1,006.26\nGlobalCard: \u20ac478.25\nSwiftCharge: \u20ac899.80\nTransactPlus: \u20ac2,182.84\n------------------------------\nTransactPlus\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file and filter the dataframe to include only rows where the `merchant` column is 'Rafa_AI' and the `day_of_year` column is between 274 and 304 (representing the month of October).",
      "Load `merchant_data.json` and `fees.json` to retrieve the merchant's attributes (MCC, account type, capture delay) and fee rules. Using the filtered October data, calculate the total transaction volume and fraud rate (fraudulent volume divided by total volume) to determine the applicable volume and fraud buckets, and add an `intracountry` column (True if `issuing_country` equals `acquirer_country`, else False)."
    ]
  }
]