[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2243,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\n# Define file path\npayments_path = '/output/chunk6/data/context/payments.csv'\n\n# Load the payments data\ndf_payments = pd.read_csv(payments_path)\n\n# Filter for merchant 'Crossfit_Hanna' and year 2023\n# Note: The 'year' column is numeric based on the schema provided.\nfiltered_df = df_payments[\n    (df_payments['merchant'] == 'Crossfit_Hanna') & \n    (df_payments['year'] == 2023)\n]\n\n# Display the result to verify the step\nprint(f\"Total transactions loaded: {len(df_payments)}\")\nprint(f\"Transactions for Crossfit_Hanna in 2023: {len(filtered_df)}\")\nprint(filtered_df.head())",
    "execution_output": "Total transactions loaded: 138236\nTransactions for Crossfit_Hanna in 2023: 55139\n   psp_reference        merchant  ... aci  acquirer_country\n0    20034594130  Crossfit_Hanna  ...   F                NL\n1    36926127356  Crossfit_Hanna  ...   F                NL\n3    68442235288  Crossfit_Hanna  ...   D                NL\n4    81404384199  Crossfit_Hanna  ...   F                NL\n5    74453982452  Crossfit_Hanna  ...   G                NL\n\n[5 rows x 21 columns]\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter the rows where the `merchant` column is 'Crossfit_Hanna' and the `year` column is 2023 to isolate the relevant transactions."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 9572,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if value is None:\n        return None\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        # Handle percentages\n        if '%' in v:\n            try:\n                return float(v.replace('%', '')) / 100.0\n            except:\n                pass\n        # Handle k/m suffixes\n        if v.lower().endswith('k'):\n            try:\n                return float(v[:-1]) * 1000\n            except:\n                pass\n        if v.lower().endswith('m'):\n            try:\n                return float(v[:-1]) * 1000000\n            except:\n                pass\n        # Handle comparison operators for direct conversion if needed (though usually handled in range check)\n        v_clean = v.lstrip('><\u2264\u2265=')\n        try:\n            return float(v_clean)\n        except:\n            pass\n    return None\n\ndef check_range(rule_value, actual_value):\n    \"\"\"\n    Checks if actual_value fits into rule_value range string.\n    rule_value examples: '100k-1m', '>5', '<3', '7.7%-8.3%', '>8.3%'\n    \"\"\"\n    if rule_value is None:\n        return True\n    if actual_value is None:\n        return False\n        \n    s = str(rule_value).strip()\n    \n    # Handle ranges with '-'\n    if '-' in s:\n        parts = s.split('-')\n        if len(parts) == 2:\n            min_val = coerce_to_float(parts[0])\n            max_val = coerce_to_float(parts[1])\n            if min_val is not None and max_val is not None:\n                return min_val <= actual_value <= max_val\n    \n    # Handle inequalities\n    if s.startswith('>='):\n        val = coerce_to_float(s[2:])\n        return actual_value >= val if val is not None else False\n    elif s.startswith('>'):\n        val = coerce_to_float(s[1:])\n        return actual_value > val if val is not None else False\n    elif s.startswith('<='):\n        val = coerce_to_float(s[2:])\n        return actual_value <= val if val is not None else False\n    elif s.startswith('<'):\n        val = coerce_to_float(s[1:])\n        return actual_value < val if val is not None else False\n        \n    # Handle exact match (rare for these fields but possible)\n    val = coerce_to_float(s)\n    if val is not None:\n        return actual_value == val\n        \n    return False\n\ndef get_month_from_doy(doy, year=2023):\n    \"\"\"Returns month (1-12) from day of year.\"\"\"\n    # 2023 is not a leap year\n    cumulative_days = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]\n    for i, d in enumerate(cumulative_days):\n        if doy <= d:\n            return i\n    return 12 # Should not happen for valid doy\n\ndef calculate_fee(transaction, fee_rules, merchant_context, monthly_stats):\n    \"\"\"\n    Calculates fee for a single transaction based on the first matching rule.\n    \n    merchant_context: dict containing 'account_type', 'capture_delay', 'mcc'\n    monthly_stats: dict containing 'volume' and 'fraud_rate' for the transaction's month\n    \"\"\"\n    \n    # Extract transaction details\n    tx_card_scheme = transaction['card_scheme']\n    tx_is_credit = transaction['is_credit']\n    tx_aci = transaction['aci']\n    tx_amount = transaction['eur_amount']\n    \n    # Determine intracountry\n    # \"True if the issuer country and the acquiring country are the same\"\n    is_intracountry = (transaction['issuing_country'] == transaction['acquirer_country'])\n    \n    # Extract context\n    m_account_type = merchant_context['account_type']\n    m_capture_delay = merchant_context['capture_delay']\n    m_mcc = merchant_context['mcc']\n    \n    # Extract monthly stats\n    month_vol = monthly_stats['volume']\n    month_fraud = monthly_stats['fraud_rate']\n    \n    for rule in fee_rules:\n        # 1. Card Scheme (Exact match required usually, or wildcard if not present)\n        if rule.get('card_scheme') and rule['card_scheme'] != tx_card_scheme:\n            continue\n            \n        # 2. Account Type (List match or Wildcard)\n        # rule['account_type'] is a list. If not empty, merchant's type must be in it.\n        if rule.get('account_type') and m_account_type not in rule['account_type']:\n            continue\n            \n        # 3. Capture Delay (Exact match or Wildcard)\n        if rule.get('capture_delay') and rule['capture_delay'] != m_capture_delay:\n            continue\n            \n        # 4. Merchant Category Code (List match or Wildcard)\n        # rule['merchant_category_code'] is a list of ints.\n        if rule.get('merchant_category_code') and m_mcc not in rule['merchant_category_code']:\n            continue\n            \n        # 5. Is Credit (Bool match or Wildcard)\n        if rule.get('is_credit') is not None and rule['is_credit'] != tx_is_credit:\n            continue\n            \n        # 6. ACI (List match or Wildcard)\n        if rule.get('aci') and tx_aci not in rule['aci']:\n            continue\n            \n        # 7. Intracountry (Bool match or Wildcard)\n        if rule.get('intracountry') is not None:\n            # Compare bools. Note: 0.0/1.0 in JSON might be loaded as floats\n            rule_intra = bool(rule['intracountry'])\n            if rule_intra != is_intracountry:\n                continue\n                \n        # 8. Monthly Volume (Range match or Wildcard)\n        if not check_range(rule.get('monthly_volume'), month_vol):\n            continue\n            \n        # 9. Monthly Fraud Level (Range match or Wildcard)\n        if not check_range(rule.get('monthly_fraud_level'), month_fraud):\n            continue\n            \n        # MATCH FOUND\n        fixed = rule.get('fixed_amount', 0.0)\n        rate = rule.get('rate', 0.0)\n        \n        # Fee formula: fixed + rate * amount / 10000\n        fee = fixed + (rate * tx_amount / 10000.0)\n        return fee\n        \n    return 0.0 # Should not happen if there's a default rule, but safe fallback\n\n# ---------------------------------------------------------\n# MAIN EXECUTION\n# ---------------------------------------------------------\n\n# File paths\npayments_path = '/output/chunk6/data/context/payments.csv'\nmerchant_path = '/output/chunk6/data/context/merchant_data.json'\nfees_path = '/output/chunk6/data/context/fees.json'\n\n# 1. Load Data\ndf_payments = pd.read_csv(payments_path)\nwith open(merchant_path, 'r') as f:\n    merchant_data = json.load(f)\nwith open(fees_path, 'r') as f:\n    fees_data = json.load(f)\n\n# 2. Filter for Target Merchant and Year\ntarget_merchant = 'Crossfit_Hanna'\ndf_target = df_payments[\n    (df_payments['merchant'] == target_merchant) & \n    (df_payments['year'] == 2023)\n].copy()\n\n# 3. Get Merchant Attributes\nmerchant_info = next((item for item in merchant_data if item[\"merchant\"] == target_merchant), None)\nif not merchant_info:\n    raise ValueError(f\"Merchant {target_merchant} not found in merchant_data.json\")\n\noriginal_mcc = merchant_info['merchant_category_code']\naccount_type = merchant_info['account_type']\ncapture_delay = merchant_info['capture_delay']\n\n# 4. Calculate Monthly Stats (Volume and Fraud Rate)\n# Add month column\ndf_target['month'] = df_target['day_of_year'].apply(get_month_from_doy)\n\nmonthly_stats = {}\nfor month in range(1, 13):\n    df_month = df_target[df_target['month'] == month]\n    if len(df_month) == 0:\n        monthly_stats[month] = {'volume': 0.0, 'fraud_rate': 0.0}\n        continue\n        \n    vol = df_month['eur_amount'].sum()\n    # Fraud rate is ratio of fraudulent volume over total volume? \n    # Manual says: \"Fraud is defined as the ratio of fraudulent volume over total volume.\" (Section 7)\n    # Wait, let's check Section 5: \"monthly_fraud_level... ratio between monthly total volume and monthly volume notified as fraud.\"\n    # Actually, usually it's count or volume. Let's re-read carefully.\n    # Section 5: \"monthly_fraud_level... rule that specifies the fraud levels measured as ratio between monthly total volume and monthly volume notified as fraud.\"\n    # This phrasing is slightly ambiguous (\"ratio between A and B\" usually means A/B or B/A).\n    # \"For example '7.7%-8.3%'\".\n    # Standard industry practice is Fraud Volume / Total Volume.\n    # Let's check the data types. 'has_fraudulent_dispute' is boolean.\n    # Let's calculate Fraud Volume / Total Volume.\n    \n    fraud_vol = df_month[df_month['has_fraudulent_dispute']]['eur_amount'].sum()\n    fraud_rate = fraud_vol / vol if vol > 0 else 0.0\n    \n    monthly_stats[month] = {\n        'volume': vol,\n        'fraud_rate': fraud_rate\n    }\n\n# 5. Calculate Fees for Both Scenarios\ntotal_fee_original = 0.0\ntotal_fee_new = 0.0\n\n# Contexts\ncontext_original = {\n    'account_type': account_type,\n    'capture_delay': capture_delay,\n    'mcc': original_mcc\n}\n\ncontext_new = {\n    'account_type': account_type,\n    'capture_delay': capture_delay,\n    'mcc': 5411  # The hypothetical new MCC\n}\n\n# Iterate transactions\nfor _, tx in df_target.iterrows():\n    month = tx['month']\n    stats = monthly_stats[month]\n    \n    # Calculate Original Fee\n    fee_orig = calculate_fee(tx, fees_data, context_original, stats)\n    total_fee_original += fee_orig\n    \n    # Calculate New Fee\n    fee_new = calculate_fee(tx, fees_data, context_new, stats)\n    total_fee_new += fee_new\n\n# 6. Calculate Delta\ndelta = total_fee_new - total_fee_original\n\n# Output result\nprint(f\"{delta:.14f}\")",
    "execution_output": "3548.02549900003942\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter the rows where the `merchant` column is 'Crossfit_Hanna' and the `year` column is 2023 to isolate the relevant transactions.",
      "Load `merchant_data.json` to get the original attributes for 'Crossfit_Hanna' and `fees.json` for the fee rules, then calculate the total fees for 2023 under the original MCC and the hypothetical MCC (5411) by matching transactions to fee rules based on all criteria (including monthly volume and fraud levels), and finally compute the difference."
    ]
  }
]