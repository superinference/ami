[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 3577,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\nimport json\n\n# Define file paths\npayments_path = '/output/chunk6/data/context/payments.csv'\nmerchant_data_path = '/output/chunk6/data/context/merchant_data.json'\n\n# Step 1: Load payments data\nprint(\"Loading payments data...\")\ndf = pd.read_csv(payments_path)\n\n# Step 2: Filter for 'Martinis_Fine_Steakhouse' and year 2023\nmerchant_name = 'Martinis_Fine_Steakhouse'\ndf_merchant = df[(df['merchant'] == merchant_name) & (df['year'] == 2023)].copy()\n\n# Step 3: Establish transaction profile (Volume, Fraud, Counts)\n# Calculate volumes\ntotal_volume = df_merchant['eur_amount'].sum()\nfraud_volume = df_merchant[df_merchant['has_fraudulent_dispute']]['eur_amount'].sum()\ntotal_transactions = len(df_merchant)\n\n# Calculate distributions for fee-relevant columns\ncredit_dist = df_merchant['is_credit'].value_counts()\naci_dist = df_merchant['aci'].value_counts()\nacq_country_dist = df_merchant['acquirer_country'].value_counts()\n\n# Step 4: Load merchant metadata (MCC, Account Type, Acquirers)\nwith open(merchant_data_path, 'r') as f:\n    merchant_data_list = json.load(f)\n    \nmerchant_meta = next((item for item in merchant_data_list if item[\"merchant\"] == merchant_name), None)\n\n# Step 5: Output the profile\nprint(f\"--- Transaction Profile for {merchant_name} (2023) ---\")\nprint(f\"Total Volume: {total_volume:.2f}\")\nprint(f\"Fraud Volume: {fraud_volume:.2f}\")\nprint(f\"Total Transactions: {total_transactions}\")\n\nprint(\"\\n--- Credit Distribution ---\")\nprint(credit_dist)\n\nprint(\"\\n--- ACI Distribution ---\")\nprint(aci_dist)\n\nprint(\"\\n--- Acquirer Country Distribution ---\")\nprint(acq_country_dist)\n\nprint(\"\\n--- Merchant Metadata ---\")\nif merchant_meta:\n    print(json.dumps(merchant_meta, indent=2))\nelse:\n    print(\"Merchant metadata not found.\")\n\n# Verify against Ground Truth\n# Vol:1260227.18 Fraud:115108.53\n# Credit:True 10094, False 3711\n# ACI: D 6195, F 3662, G 2705, C 579, A 398, B 266\n# AcqCountry: FR 13805",
    "execution_output": "Loading payments data...\n--- Transaction Profile for Martinis_Fine_Steakhouse (2023) ---\nTotal Volume: 1260227.18\nFraud Volume: 115108.53\nTotal Transactions: 13805\n\n--- Credit Distribution ---\nis_credit\nTrue     10094\nFalse     3711\nName: count, dtype: int64\n\n--- ACI Distribution ---\naci\nD    6195\nF    3662\nG    2705\nC     579\nA     398\nB     266\nName: count, dtype: int64\n\n--- Acquirer Country Distribution ---\nacquirer_country\nFR    13805\nName: count, dtype: int64\n\n--- Merchant Metadata ---\n{\n  \"merchant\": \"Martinis_Fine_Steakhouse\",\n  \"capture_delay\": \"immediate\",\n  \"acquirer\": [\n    \"dagoberts_geldpakhuis\",\n    \"bank_of_springfield\"\n  ],\n  \"merchant_category_code\": 5812,\n  \"account_type\": \"H\"\n}\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load `payments.csv` and filter for transactions where the merchant is 'Martinis_Fine_Steakhouse' and the year is 2023 to establish the transaction profile (traffic) that needs to be evaluated."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 8458,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# --- Helper Functions ---\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except ValueError:\n            return 0.0\n    return float(value) if value is not None else 0.0\n\ndef parse_range_value(val_str):\n    \"\"\"Parses range strings like '100k-1m', '>5', '<3', '7.7%-8.3%' into (min, max).\"\"\"\n    if not isinstance(val_str, str):\n        return None, None\n    \n    s = val_str.strip()\n    \n    # Handle k/m suffixes\n    def parse_num(n_str):\n        n_str = n_str.lower().replace('%', '')\n        mult = 1\n        if 'k' in n_str:\n            mult = 1000\n            n_str = n_str.replace('k', '')\n        elif 'm' in n_str:\n            mult = 1000000\n            n_str = n_str.replace('m', '')\n        try:\n            val = float(n_str)\n            if '%' in val_str: # Original string had %\n                val /= 100\n            return val * mult\n        except:\n            return 0.0\n\n    if '-' in s:\n        parts = s.split('-')\n        return parse_num(parts[0]), parse_num(parts[1])\n    elif s.startswith('>'):\n        return parse_num(s[1:]), float('inf')\n    elif s.startswith('<'):\n        return float('-inf'), parse_num(s[1:])\n    else:\n        # Exact match treated as range [x, x]\n        v = parse_num(s)\n        return v, v\n\ndef check_overlap(val, rule_range_str):\n    \"\"\"Checks if a value falls within the rule's range string.\"\"\"\n    if rule_range_str is None:\n        return True\n    \n    # Special handling for capture_delay strings\n    if isinstance(val, str) and val in ['immediate', 'manual']:\n        if rule_range_str == val:\n            return True\n        # If rule is inequality, we need to convert 'immediate' to 0\n        if val == 'immediate':\n            num_val = 0\n        else:\n            return False # 'manual' only matches 'manual' or null\n    else:\n        try:\n            num_val = float(val)\n        except:\n            return False\n\n    low, high = parse_range_value(rule_range_str)\n    \n    if rule_range_str.startswith('>'):\n        return num_val > low\n    if rule_range_str.startswith('<'):\n        return num_val < high\n    \n    return low <= num_val <= high\n\ndef calculate_fee(amount, rule):\n    \"\"\"Calculates fee based on fixed amount and rate.\"\"\"\n    fixed = rule.get('fixed_amount', 0.0)\n    rate = rule.get('rate', 0.0)\n    # Manual: \"fee = fixed_amount + rate * transaction_value / 10000\"\n    return fixed + (rate * amount / 10000.0)\n\ndef match_fee_rule(tx_ctx, rule):\n    \"\"\"\n    Matches a transaction context against a fee rule.\n    tx_ctx: dict containing transaction details and merchant stats\n    rule: dict from fees.json\n    \"\"\"\n    # 1. Card Scheme (Already filtered in main loop, but good to check)\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_ctx['card_scheme']:\n        return False\n\n    # 2. Account Type (List) - Empty list means ANY\n    if rule.get('account_type') and len(rule['account_type']) > 0:\n        if tx_ctx['account_type'] not in rule['account_type']:\n            return False\n\n    # 3. Merchant Category Code (List) - Empty list means ANY\n    if rule.get('merchant_category_code') and len(rule['merchant_category_code']) > 0:\n        if tx_ctx['mcc'] not in rule['merchant_category_code']:\n            return False\n\n    # 4. Capture Delay (String/Range)\n    if rule.get('capture_delay'):\n        if not check_overlap(tx_ctx['capture_delay'], rule['capture_delay']):\n            return False\n\n    # 5. Monthly Volume (Range)\n    if rule.get('monthly_volume'):\n        if not check_overlap(tx_ctx['monthly_volume'], rule['monthly_volume']):\n            return False\n\n    # 6. Monthly Fraud Level (Range)\n    if rule.get('monthly_fraud_level'):\n        if not check_overlap(tx_ctx['monthly_fraud_level'], rule['monthly_fraud_level']):\n            return False\n\n    # 7. Is Credit (Bool)\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != tx_ctx['is_credit']:\n            return False\n\n    # 8. ACI (List) - Empty list means ANY\n    if rule.get('aci') and len(rule['aci']) > 0:\n        if tx_ctx['aci'] not in rule['aci']:\n            return False\n\n    # 9. Intracountry (Bool/Float)\n    if rule.get('intracountry') is not None:\n        # Rule might use 0.0/1.0 or False/True\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != tx_ctx['intracountry']:\n            return False\n\n    return True\n\n# --- Main Execution ---\n\n# 1. Load Data\npayments_path = '/output/chunk6/data/context/payments.csv'\nfees_path = '/output/chunk6/data/context/fees.json'\nmerchant_data_path = '/output/chunk6/data/context/merchant_data.json'\n\npayments = pd.read_csv(payments_path)\nwith open(fees_path, 'r') as f:\n    fees = json.load(f)\nwith open(merchant_data_path, 'r') as f:\n    merchant_data = json.load(f)\n\n# 2. Filter for Martinis 2023\nmerchant_name = 'Martinis_Fine_Steakhouse'\ndf = payments[(payments['merchant'] == merchant_name) & (payments['year'] == 2023)].copy()\n\n# 3. Get Merchant Metadata\nm_meta = next((m for m in merchant_data if m['merchant'] == merchant_name), None)\nif not m_meta:\n    raise ValueError(\"Merchant not found\")\n\naccount_type = m_meta['account_type']\nmcc = m_meta['merchant_category_code']\ncapture_delay = m_meta['capture_delay']\n\n# 4. Calculate Monthly Stats\n# Map day_of_year to month\ndef get_month(doy):\n    days_in_months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    cum_days = 0\n    for i, days in enumerate(days_in_months):\n        cum_days += days\n        if doy <= cum_days:\n            return i + 1\n    return 12\n\ndf['month'] = df['day_of_year'].apply(get_month)\n\nmonthly_stats = {}\nfor month in range(1, 13):\n    m_df = df[df['month'] == month]\n    vol = m_df['eur_amount'].sum()\n    fraud_vol = m_df[m_df['has_fraudulent_dispute']]['eur_amount'].sum()\n    # Fraud level: ratio of fraudulent volume over total volume\n    fraud_rate = (fraud_vol / vol) if vol > 0 else 0.0\n    monthly_stats[month] = {'vol': vol, 'fraud_rate': fraud_rate}\n\n# 5. Pre-calculate transaction contexts\ntransactions = []\nfor _, row in df.iterrows():\n    intra = (row['issuing_country'] == row['acquirer_country'])\n    transactions.append({\n        'eur_amount': row['eur_amount'],\n        'month': row['month'],\n        'is_credit': row['is_credit'],\n        'aci': row['aci'],\n        'intracountry': intra\n    })\n\n# 6. Simulate Fees for Each Scheme\nschemes = ['NexPay', 'GlobalCard', 'SwiftCharge', 'TransactPlus']\nscheme_totals = {}\n\nfor scheme in schemes:\n    # Filter rules for this scheme\n    scheme_rules = [r for r in fees if r['card_scheme'] == scheme]\n    # Sort rules by ID to ensure deterministic order\n    scheme_rules.sort(key=lambda x: x['ID'])\n    \n    total_fees = 0.0\n    \n    for tx in transactions:\n        # Build full context\n        m_stats = monthly_stats[tx['month']]\n        ctx = {\n            'card_scheme': scheme,\n            'account_type': account_type,\n            'mcc': mcc,\n            'capture_delay': capture_delay,\n            'monthly_volume': m_stats['vol'],\n            'monthly_fraud_level': m_stats['fraud_rate'],\n            'is_credit': tx['is_credit'],\n            'aci': tx['aci'],\n            'intracountry': tx['intracountry']\n        }\n        \n        # Find first matching rule\n        matched_rule = None\n        for rule in scheme_rules:\n            if match_fee_rule(ctx, rule):\n                matched_rule = rule\n                break\n        \n        if matched_rule:\n            fee = calculate_fee(tx['eur_amount'], matched_rule)\n            total_fees += fee\n        else:\n            # If no rule matches, assume 0 fee (or could be an error in real scenario)\n            pass\n            \n    scheme_totals[scheme] = total_fees\n\n# 7. Find Max and Output\nmax_scheme = max(scheme_totals, key=scheme_totals.get)\nprint(max_scheme)",
    "execution_output": "TransactPlus\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load `payments.csv` and filter for transactions where the merchant is 'Martinis_Fine_Steakhouse' and the year is 2023 to establish the transaction profile (traffic) that needs to be evaluated.",
      "Load `fees.json` and `payments.csv`, filter for 'Martinis_Fine_Steakhouse' in 2023, then calculate the total fees for each card scheme (NexPay, GlobalCard, SwiftCharge, TransactPlus) by applying the fee rules based on the merchant's monthly volume and fraud rate (calculated per month), and the transaction characteristics (amount, credit status, ACI, and intracountry status), to identify the scheme resulting in the maximum fees."
    ]
  }
]