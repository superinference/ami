[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2446,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\n# Load the payments data\npayments_path = '/output/chunk6/data/context/payments.csv'\ndf_payments = pd.read_csv(payments_path)\n\n# Filter for 'Belles_cookbook_store' and year 2023\n# Note: 'year' is numeric based on schema, 'merchant' is string\nfiltered_df = df_payments[\n    (df_payments['merchant'] == 'Belles_cookbook_store') & \n    (df_payments['year'] == 2023)\n]\n\n# Display verification of the filter\nprint(f\"Original shape: {df_payments.shape}\")\nprint(f\"Filtered shape: {filtered_df.shape}\")\nprint(\"\\nFirst 5 rows of filtered data:\")\nprint(filtered_df.head())\n\n# Verify unique values in filtered columns to ensure correctness\nprint(\"\\nUnique merchants in filtered data:\", filtered_df['merchant'].unique())\nprint(\"Unique years in filtered data:\", filtered_df['year'].unique())",
    "execution_output": "Original shape: (138236, 21)\nFiltered shape: (13848, 21)\n\nFirst 5 rows of filtered data:\n    psp_reference               merchant  ... aci  acquirer_country\n2     31114608278  Belles_cookbook_store  ...   F                US\n10    11539582857  Belles_cookbook_store  ...   F                US\n18    16900553593  Belles_cookbook_store  ...   G                US\n23    79488939497  Belles_cookbook_store  ...   D                US\n26    27927426581  Belles_cookbook_store  ...   G                US\n\n[5 rows x 21 columns]\n\nUnique merchants in filtered data: ['Belles_cookbook_store']\nUnique years in filtered data: [2023]\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter the rows to include only transactions where the `merchant` column is 'Belles_cookbook_store' and the `year` column is 2023."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 7605,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ==========================================\n# HELPER FUNCTIONS\n# ==========================================\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if value is None:\n        return 0.0\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except ValueError:\n            return 0.0\n    return float(value)\n\ndef parse_range(range_str):\n    \"\"\"Parses strings like '100k-1m', '<3', '>5', '8.3%' into min/max tuple.\"\"\"\n    if not isinstance(range_str, str):\n        return None, None\n    \n    s = range_str.lower().strip()\n    \n    def parse_val(val_s):\n        val_s = val_s.strip()\n        mult = 1\n        if val_s.endswith('%'):\n            val_s = val_s[:-1]\n            mult = 0.01\n        elif val_s.endswith('k'):\n            val_s = val_s[:-1]\n            mult = 1000\n        elif val_s.endswith('m'):\n            val_s = val_s[:-1]\n            mult = 1000000\n        return float(val_s) * mult\n\n    if '-' in s:\n        parts = s.split('-')\n        return parse_val(parts[0]), parse_val(parts[1])\n    elif s.startswith('>'):\n        return parse_val(s[1:]), float('inf')\n    elif s.startswith('<'):\n        return float('-inf'), parse_val(s[1:])\n    else:\n        try:\n            v = parse_val(s)\n            return v, v\n        except:\n            return None, None\n\ndef check_capture_delay(tx_delay, rule_delay):\n    \"\"\"Matches merchant capture delay (str) against rule delay (str).\"\"\"\n    if rule_delay is None:\n        return True\n    \n    t = str(tx_delay).lower()\n    r = str(rule_delay).lower()\n    \n    if r == t:\n        return True\n    \n    if any(x in r for x in ['<', '>', '-']):\n        try:\n            t_val = float(t)\n        except ValueError:\n            return False\n            \n        min_v, max_v = parse_range(r)\n        if min_v is None: return False\n        \n        if r.startswith('<'):\n            return t_val < max_v\n        if r.startswith('>'):\n            return t_val > min_v\n        if '-' in r:\n            return min_v <= t_val <= max_v\n            \n    return False\n\ndef match_fee_rule(tx_ctx, rule):\n    \"\"\"Checks if a fee rule applies to a transaction context.\"\"\"\n    # 1. Card Scheme\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_ctx['card_scheme']:\n        return False\n        \n    # 2. Account Type\n    if rule.get('account_type'):\n        if tx_ctx['account_type'] not in rule['account_type']:\n            return False\n            \n    # 3. Merchant Category Code\n    if rule.get('merchant_category_code'):\n        if tx_ctx['mcc'] not in rule['merchant_category_code']:\n            return False\n            \n    # 4. ACI\n    if rule.get('aci'):\n        if tx_ctx['aci'] not in rule['aci']:\n            return False\n            \n    # 5. Is Credit\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != tx_ctx['is_credit']:\n            return False\n            \n    # 6. Intracountry\n    if rule.get('intracountry') is not None:\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != tx_ctx['intracountry']:\n            return False\n            \n    # 7. Capture Delay\n    if rule.get('capture_delay'):\n        if not check_capture_delay(tx_ctx['capture_delay'], rule['capture_delay']):\n            return False\n            \n    # 8. Monthly Volume\n    if rule.get('monthly_volume'):\n        min_v, max_v = parse_range(rule['monthly_volume'])\n        vol = tx_ctx['monthly_volume']\n        if not (min_v <= vol <= max_v):\n            return False\n            \n    # 9. Monthly Fraud Level\n    if rule.get('monthly_fraud_level'):\n        min_f, max_f = parse_range(rule['monthly_fraud_level'])\n        fraud = tx_ctx['monthly_fraud_level']\n        if not (min_f <= fraud <= max_f):\n            return False\n            \n    return True\n\ndef calculate_fee(amount, rule):\n    \"\"\"Calculates fee amount based on rule.\"\"\"\n    fixed = rule.get('fixed_amount', 0.0)\n    rate = rule.get('rate', 0.0)\n    return fixed + (rate * amount / 10000.0)\n\n# ==========================================\n# MAIN LOGIC\n# ==========================================\n\n# 1. Load Data\npayments_path = '/output/chunk6/data/context/payments.csv'\nfees_path = '/output/chunk6/data/context/fees.json'\nmerchant_path = '/output/chunk6/data/context/merchant_data.json'\n\ndf_payments = pd.read_csv(payments_path)\nwith open(fees_path, 'r') as f:\n    fees_data = json.load(f)\nwith open(merchant_path, 'r') as f:\n    merchant_data = json.load(f)\n\n# 2. Filter for Merchant and Year\ntarget_merchant = 'Belles_cookbook_store'\ntarget_year = 2023\n\ndf = df_payments[\n    (df_payments['merchant'] == target_merchant) & \n    (df_payments['year'] == target_year)\n].copy()\n\n# 3. Get Merchant Metadata\nmerchant_info = next((item for item in merchant_data if item[\"merchant\"] == target_merchant), None)\nif not merchant_info:\n    raise ValueError(f\"Merchant {target_merchant} not found in merchant_data.json\")\n\naccount_type = merchant_info['account_type']\ncapture_delay = merchant_info['capture_delay']\noriginal_mcc = merchant_info['merchant_category_code']\nnew_mcc = 7523\n\n# 4. Pre-calculate Monthly Stats\n# Map day_of_year to month (1-12)\nbins = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 366]\nlabels = range(1, 13)\ndf['month'] = pd.cut(df['day_of_year'], bins=bins, labels=labels).astype(int)\n\nmonthly_stats = {}\nfor month in range(1, 13):\n    month_df = df[df['month'] == month]\n    if month_df.empty:\n        monthly_stats[month] = {'vol': 0.0, 'fraud_rate': 0.0}\n        continue\n    \n    total_vol = month_df['eur_amount'].sum()\n    # Fraud rate is volume of fraudulent txs / total volume\n    fraud_vol = month_df[month_df['has_fraudulent_dispute'] == True]['eur_amount'].sum()\n    fraud_rate = fraud_vol / total_vol if total_vol > 0 else 0.0\n    \n    monthly_stats[month] = {\n        'vol': total_vol,\n        'fraud_rate': fraud_rate\n    }\n\n# 5. Calculate Fees\ntotal_fee_original = 0.0\ntotal_fee_new = 0.0\n\nfor idx, row in df.iterrows():\n    month = row['month']\n    stats = monthly_stats[month]\n    \n    # Intracountry check: Issuer == Acquirer\n    is_intracountry = (row['issuing_country'] == row['acquirer_country'])\n    \n    tx_ctx = {\n        'card_scheme': row['card_scheme'],\n        'account_type': account_type,\n        'capture_delay': capture_delay,\n        'is_credit': row['is_credit'],\n        'aci': row['aci'],\n        'intracountry': is_intracountry,\n        'monthly_volume': stats['vol'],\n        'monthly_fraud_level': stats['fraud_rate'],\n        # MCC will be set below\n    }\n    \n    # --- Original Fee ---\n    tx_ctx['mcc'] = original_mcc\n    for rule in fees_data:\n        if match_fee_rule(tx_ctx, rule):\n            total_fee_original += calculate_fee(row['eur_amount'], rule)\n            break \n    \n    # --- New Fee ---\n    tx_ctx['mcc'] = new_mcc\n    for rule in fees_data:\n        if match_fee_rule(tx_ctx, rule):\n            total_fee_new += calculate_fee(row['eur_amount'], rule)\n            break \n\n# 6. Calculate Delta\ndelta = total_fee_new - total_fee_original\n\n# 7. Output\nprint(f\"{delta:.14f}\")",
    "execution_output": "2076.52156299999206\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter the rows to include only transactions where the `merchant` column is 'Belles_cookbook_store' and the `year` column is 2023.",
      "Load `merchant_data.json` and `fees.json` to extract the current `merchant_category_code`, `account_type`, and `capture_delay` for 'Belles_cookbook_store', then add an `intracountry` column to the filtered payments dataframe and calculate the merchant's monthly total volume and monthly fraud rate (based on `eur_amount` and `has_fraudulent_dispute`) to prepare for fee rule matching."
    ]
  },
  {
    "round": 3,
    "plan_steps": 3,
    "code_length": 8198,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ==========================================\n# HELPER FUNCTIONS\n# ==========================================\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if value is None:\n        return 0.0\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')\n        if '%' in v:\n            try:\n                return float(v.replace('%', '')) / 100\n            except ValueError:\n                return 0.0\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except ValueError:\n            return 0.0\n    return float(value)\n\ndef parse_range(range_str):\n    \"\"\"Parses strings like '100k-1m', '<3', '>5', '8.3%' into min/max tuple.\"\"\"\n    if not isinstance(range_str, str):\n        return None, None\n    \n    s = range_str.lower().strip()\n    \n    def parse_val(val_s):\n        val_s = val_s.strip()\n        mult = 1\n        if val_s.endswith('%'):\n            val_s = val_s[:-1]\n            mult = 0.01\n        elif val_s.endswith('k'):\n            val_s = val_s[:-1]\n            mult = 1000\n        elif val_s.endswith('m'):\n            val_s = val_s[:-1]\n            mult = 1000000\n        return float(val_s) * mult\n\n    if '-' in s:\n        parts = s.split('-')\n        try:\n            return parse_val(parts[0]), parse_val(parts[1])\n        except:\n            return None, None\n    elif s.startswith('>'):\n        try:\n            return parse_val(s[1:]), float('inf')\n        except:\n            return None, None\n    elif s.startswith('<'):\n        try:\n            return float('-inf'), parse_val(s[1:])\n        except:\n            return None, None\n    else:\n        try:\n            v = parse_val(s)\n            return v, v\n        except:\n            return None, None\n\ndef check_capture_delay(tx_delay, rule_delay):\n    \"\"\"Matches merchant capture delay (str) against rule delay (str).\"\"\"\n    if rule_delay is None:\n        return True\n    \n    t = str(tx_delay).lower()\n    r = str(rule_delay).lower()\n    \n    if r == t:\n        return True\n    \n    if any(x in r for x in ['<', '>', '-']):\n        t_val = None\n        if t == 'immediate':\n            t_val = 0.0\n        elif t == 'manual':\n            t_val = 999.0\n        else:\n            try:\n                t_val = float(t)\n            except ValueError:\n                return False\n            \n        min_v, max_v = parse_range(r)\n        if min_v is None: return False\n        \n        return min_v <= t_val <= max_v\n            \n    return False\n\ndef match_fee_rule(tx_ctx, rule):\n    \"\"\"Checks if a fee rule applies to a transaction context.\"\"\"\n    # 1. Card Scheme\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_ctx['card_scheme']:\n        return False\n        \n    # 2. Account Type (Rule has list, tx has string)\n    if rule.get('account_type'):\n        if tx_ctx['account_type'] not in rule['account_type']:\n            return False\n            \n    # 3. Merchant Category Code (Rule has list, tx has int)\n    if rule.get('merchant_category_code'):\n        if tx_ctx['mcc'] not in rule['merchant_category_code']:\n            return False\n            \n    # 4. ACI (Rule has list, tx has string)\n    if rule.get('aci'):\n        if tx_ctx['aci'] not in rule['aci']:\n            return False\n            \n    # 5. Is Credit (Rule has bool or None)\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != tx_ctx['is_credit']:\n            return False\n            \n    # 6. Intracountry (Rule has bool or None)\n    if rule.get('intracountry') is not None:\n        r_intra = rule['intracountry']\n        # Handle 0.0/1.0 as booleans\n        if r_intra == 1.0: r_intra = True\n        elif r_intra == 0.0: r_intra = False\n        \n        if r_intra != tx_ctx['intracountry']:\n            return False\n            \n    # 7. Capture Delay\n    if rule.get('capture_delay'):\n        if not check_capture_delay(tx_ctx['capture_delay'], rule['capture_delay']):\n            return False\n            \n    # 8. Monthly Volume\n    if rule.get('monthly_volume'):\n        min_v, max_v = parse_range(rule['monthly_volume'])\n        vol = tx_ctx['monthly_volume']\n        if min_v is not None and not (min_v <= vol <= max_v):\n            return False\n            \n    # 9. Monthly Fraud Level\n    if rule.get('monthly_fraud_level'):\n        min_f, max_f = parse_range(rule['monthly_fraud_level'])\n        fraud = tx_ctx['monthly_fraud_level']\n        if min_f is not None and not (min_f <= fraud <= max_f):\n            return False\n            \n    return True\n\ndef calculate_fee(amount, rule):\n    \"\"\"Calculates fee amount based on rule.\"\"\"\n    fixed = rule.get('fixed_amount', 0.0)\n    rate = rule.get('rate', 0.0)\n    return fixed + (rate * amount / 10000.0)\n\n# ==========================================\n# MAIN LOGIC\n# ==========================================\n\n# 1. Load Data\npayments_path = '/output/chunk6/data/context/payments.csv'\nfees_path = '/output/chunk6/data/context/fees.json'\nmerchant_path = '/output/chunk6/data/context/merchant_data.json'\n\ndf_payments = pd.read_csv(payments_path)\nwith open(fees_path, 'r') as f:\n    fees_data = json.load(f)\nwith open(merchant_path, 'r') as f:\n    merchant_data = json.load(f)\n\n# 2. Filter for Merchant and Year\ntarget_merchant = 'Belles_cookbook_store'\ntarget_year = 2023\n\ndf = df_payments[\n    (df_payments['merchant'] == target_merchant) & \n    (df_payments['year'] == target_year)\n].copy()\n\n# 3. Get Merchant Metadata\nmerchant_info = next((item for item in merchant_data if item[\"merchant\"] == target_merchant), None)\nif not merchant_info:\n    raise ValueError(f\"Merchant {target_merchant} not found\")\n\naccount_type = merchant_info['account_type']\ncapture_delay = merchant_info['capture_delay']\noriginal_mcc = merchant_info['merchant_category_code']\nnew_mcc = 7523\n\n# 4. Pre-calculate Monthly Stats\n# Map day_of_year to month (1-12)\nbins = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 366]\nlabels = range(1, 13)\ndf['month'] = pd.cut(df['day_of_year'], bins=bins, labels=labels).astype(int)\n\nmonthly_stats = {}\nfor month in range(1, 13):\n    month_df = df[df['month'] == month]\n    if month_df.empty:\n        monthly_stats[month] = {'vol': 0.0, 'fraud_rate': 0.0}\n        continue\n    \n    total_vol = month_df['eur_amount'].sum()\n    \n    # Fraud volume (sum of amounts where has_fraudulent_dispute is True)\n    fraud_vol = month_df[month_df['has_fraudulent_dispute'] == True]['eur_amount'].sum()\n    \n    # Fraud rate = fraud_vol / total_vol\n    fraud_rate = fraud_vol / total_vol if total_vol > 0 else 0.0\n    \n    monthly_stats[month] = {\n        'vol': total_vol,\n        'fraud_rate': fraud_rate\n    }\n\n# 5. Calculate Fees\ntotal_fee_original = 0.0\ntotal_fee_new = 0.0\n\nfor row in df.itertuples():\n    month = row.month\n    stats = monthly_stats[month]\n    \n    # Intracountry check: Issuer == Acquirer\n    is_intracountry = (row.issuing_country == row.acquirer_country)\n    \n    tx_ctx = {\n        'card_scheme': row.card_scheme,\n        'account_type': account_type,\n        'capture_delay': capture_delay,\n        'is_credit': row.is_credit,\n        'aci': row.aci,\n        'intracountry': is_intracountry,\n        'monthly_volume': stats['vol'],\n        'monthly_fraud_level': stats['fraud_rate'],\n        # MCC will be set below\n    }\n    \n    # --- Original Fee ---\n    tx_ctx['mcc'] = original_mcc\n    for rule in fees_data:\n        if match_fee_rule(tx_ctx, rule):\n            total_fee_original += calculate_fee(row.eur_amount, rule)\n            break \n    \n    # --- New Fee ---\n    tx_ctx['mcc'] = new_mcc\n    for rule in fees_data:\n        if match_fee_rule(tx_ctx, rule):\n            total_fee_new += calculate_fee(row.eur_amount, rule)\n            break \n\n# 6. Calculate Delta\ndelta = total_fee_new - total_fee_original\n\n# 7. Output\nprint(f\"{delta:.14f}\")",
    "execution_output": "2076.52156299999206\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "sufficient",
    "temperature": 0.2,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter the rows to include only transactions where the `merchant` column is 'Belles_cookbook_store' and the `year` column is 2023.",
      "Load `merchant_data.json` and `fees.json` to extract the current `merchant_category_code`, `account_type`, and `capture_delay` for 'Belles_cookbook_store', then add an `intracountry` column to the filtered payments dataframe and calculate the merchant's monthly total volume and monthly fraud rate (based on `eur_amount` and `has_fraudulent_dispute`) to prepare for fee rule matching.",
      "Load `payments.csv`, `merchant_data.json`, and `fees.json`, filter for 'Belles_cookbook_store' transactions in 2023, then calculate the total fees for the year using the merchant's original MCC and the hypothetical MCC 7523 by matching each transaction to the correct fee rule (considering card scheme, account type, capture delay, monthly volume/fraud stats, ACI, is_credit, and intracountry status), and finally compute the difference between the two totals."
    ]
  }
]