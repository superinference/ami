[
  {
    "round": 1,
    "plan_steps": 1,
    "code_length": 2314,
    "code": "# Helper functions for robust data processing\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef safe_get(df, column, default=None):\n    \"\"\"Safely get column from DataFrame, return default if not exists.\"\"\"\n    if isinstance(df, dict):\n        return df.get(column, default)\n    elif hasattr(df, 'columns') and column in df.columns:\n        return df[column]\n    return default\n\ndef is_not_empty(array):\n    \"\"\"Check if array/list is not empty. Handles numpy arrays safely.\"\"\"\n    if array is None:\n        return False\n    if hasattr(array, 'size'):  # numpy array\n        return array.size > 0\n    try:\n        return len(array) > 0\n    except TypeError:\n        return False\n\ndef safe_index(array, idx, default=None):\n    \"\"\"Safely get array element at index, return default if out of bounds.\"\"\"\n    try:\n        if 0 <= idx < len(array):\n            return array[idx]\n        return default\n    except (IndexError, TypeError, AttributeError):\n        return default\n\n\nimport pandas as pd\n\n# Load the payments data\ndf = pd.read_csv('/output/chunk6/data/context/payments.csv')\n\n# Define filter criteria\nmerchant_name = 'Martinis_Fine_Steakhouse'\nstart_day = 121\nend_day = 151\n\n# Apply filters\nfiltered_df = df[\n    (df['merchant'] == merchant_name) & \n    (df['day_of_year'] >= start_day) & \n    (df['day_of_year'] <= end_day)\n]\n\n# Display results to verify the step\nprint(f\"Total rows loaded: {len(df)}\")\nprint(f\"Rows for {merchant_name} in May (days {start_day}-{end_day}): {len(filtered_df)}\")\nprint(\"\\nSample of filtered data:\")\nprint(filtered_df[['merchant', 'day_of_year', 'eur_amount', 'card_scheme', 'aci', 'is_credit']].head())",
    "execution_output": "Total rows loaded: 138236\nRows for Martinis_Fine_Steakhouse in May (days 121-151): 1194\n\nSample of filtered data:\n                     merchant  day_of_year  ...  aci is_credit\n50   Martinis_Fine_Steakhouse          131  ...    D      True\n221  Martinis_Fine_Steakhouse          144  ...    F     False\n293  Martinis_Fine_Steakhouse          131  ...    F     False\n519  Martinis_Fine_Steakhouse          138  ...    G      True\n614  Martinis_Fine_Steakhouse          145  ...    D      True\n\n[5 rows x 6 columns]\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.1,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter for rows where the `merchant` is 'Martinis_Fine_Steakhouse' and the `day_of_year` is between 121 and 151 (representing May 2023)."
    ]
  },
  {
    "round": 2,
    "plan_steps": 2,
    "code_length": 8499,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            return float(v.replace('%', '')) / 100\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        return float(v)\n    return float(value)\n\ndef parse_range(range_str, value_type='float'):\n    \"\"\"\n    Parses a range string like '100k-1m' or '7.7%-8.3%' or '>5'.\n    Returns (min_val, max_val).\n    \"\"\"\n    if not isinstance(range_str, str):\n        return None, None\n    \n    s = range_str.lower().strip()\n    \n    # Handle k/m suffixes for volume\n    def parse_val(x):\n        x = x.strip()\n        if x.endswith('%'):\n            return float(x.replace('%', '')) / 100.0\n        factor = 1\n        if x.endswith('k'):\n            factor = 1000\n            x = x[:-1]\n        elif x.endswith('m'):\n            factor = 1000000\n            x = x[:-1]\n        return float(x) * factor\n\n    if '>' in s:\n        val = parse_val(s.replace('>', ''))\n        return val, float('inf')\n    if '<' in s:\n        val = parse_val(s.replace('<', ''))\n        return float('-inf'), val\n    \n    if '-' in s:\n        parts = s.split('-')\n        if len(parts) == 2:\n            return parse_val(parts[0]), parse_val(parts[1])\n            \n    # Exact match or immediate/manual (handled elsewhere usually, but for numeric ranges)\n    try:\n        val = parse_val(s)\n        return val, val\n    except:\n        return None, None\n\ndef check_range(value, range_str):\n    \"\"\"Checks if a value falls within a range string.\"\"\"\n    if range_str is None:\n        return True\n    min_v, max_v = parse_range(range_str)\n    if min_v is None: # Not a standard range string, maybe categorical like 'immediate'\n        return str(value).lower() == str(range_str).lower()\n    return min_v <= value <= max_v\n\ndef match_fee_rule(tx_context, rule):\n    \"\"\"\n    Determines if a fee rule applies to a specific transaction context.\n    tx_context must contain:\n      - card_scheme\n      - account_type\n      - merchant_category_code\n      - capture_delay\n      - monthly_volume\n      - monthly_fraud_level\n      - is_credit\n      - aci\n      - intracountry\n    \"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_context['card_scheme']:\n        return False\n\n    # 2. Account Type (List match)\n    if rule.get('account_type') and tx_context['account_type'] not in rule['account_type']:\n        return False\n\n    # 3. Merchant Category Code (List match)\n    if rule.get('merchant_category_code') and tx_context['merchant_category_code'] not in rule['merchant_category_code']:\n        return False\n\n    # 4. Capture Delay (Exact match or wildcard)\n    # Note: capture_delay in fees.json can be ranges like '>5', but merchant data is usually specific 'immediate', 'manual', '1'.\n    # However, looking at fees.json, capture_delay values are '3-5', '>5', '<3', 'immediate', 'manual'.\n    # Merchant data has 'immediate', 'manual', '1', '2', '7'.\n    # We need to map merchant specific days to the rule categories if necessary, or just string match.\n    # Let's handle the numeric mapping for days.\n    \n    rule_delay = rule.get('capture_delay')\n    if rule_delay:\n        merch_delay = str(tx_context['capture_delay'])\n        if merch_delay.isdigit():\n            days = int(merch_delay)\n            if rule_delay == '>5' and days > 5: pass\n            elif rule_delay == '<3' and days < 3: pass\n            elif rule_delay == '3-5' and 3 <= days <= 5: pass\n            else: return False # Numeric mismatch\n        else:\n            # String match (immediate, manual)\n            if rule_delay != merch_delay:\n                return False\n\n    # 5. Monthly Volume (Range match)\n    if rule.get('monthly_volume'):\n        if not check_range(tx_context['monthly_volume'], rule['monthly_volume']):\n            return False\n\n    # 6. Monthly Fraud Level (Range match)\n    if rule.get('monthly_fraud_level'):\n        if not check_range(tx_context['monthly_fraud_level'], rule['monthly_fraud_level']):\n            return False\n\n    # 7. Is Credit (Boolean match)\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != tx_context['is_credit']:\n            return False\n\n    # 8. ACI (List match)\n    if rule.get('aci') and tx_context['aci'] not in rule['aci']:\n        return False\n\n    # 9. Intracountry (Boolean match)\n    # In fees.json, intracountry is 0.0 (False) or 1.0 (True) or null\n    if rule.get('intracountry') is not None:\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != tx_context['intracountry']:\n            return False\n\n    return True\n\n# ---------------------------------------------------------\n# MAIN LOGIC\n# ---------------------------------------------------------\n\n# 1. Load Data\ndf_payments = pd.read_csv('/output/chunk6/data/context/payments.csv')\nwith open('/output/chunk6/data/context/fees.json', 'r') as f:\n    fees_data = json.load(f)\nwith open('/output/chunk6/data/context/merchant_data.json', 'r') as f:\n    merchant_data = json.load(f)\n\n# 2. Define Context\ntarget_merchant = 'Martinis_Fine_Steakhouse'\ntarget_year = 2023\n# May is days 121 to 151 (non-leap year)\nstart_day = 121\nend_day = 151\n\n# 3. Filter Payments for Merchant and Month\n# We need the whole month to calculate volume/fraud stats correctly\ndf_month = df_payments[\n    (df_payments['merchant'] == target_merchant) &\n    (df_payments['year'] == target_year) &\n    (df_payments['day_of_year'] >= start_day) &\n    (df_payments['day_of_year'] <= end_day)\n].copy()\n\nif df_month.empty:\n    print(\"No transactions found for this merchant in May 2023.\")\nelse:\n    # 4. Calculate Monthly Stats (Volume & Fraud)\n    # Manual Section 7: \"Fraud is defined as the ratio of fraudulent volume over total volume.\"\n    total_volume = df_month['eur_amount'].sum()\n    fraud_volume = df_month[df_month['has_fraudulent_dispute']]['eur_amount'].sum()\n    \n    monthly_fraud_ratio = fraud_volume / total_volume if total_volume > 0 else 0.0\n    \n    # 5. Get Static Merchant Attributes\n    merch_info = next((item for item in merchant_data if item[\"merchant\"] == target_merchant), None)\n    if not merch_info:\n        print(f\"Merchant {target_merchant} not found in merchant_data.json\")\n        exit()\n\n    # 6. Identify Applicable Fee IDs\n    # We must check every transaction because fees depend on dynamic attributes (scheme, credit, aci, intracountry)\n    applicable_fee_ids = set()\n\n    # Optimization: Get unique transaction profiles to reduce iterations\n    # Profile keys: card_scheme, is_credit, aci, issuing_country, acquirer_country\n    # We need issuing/acquirer to determine intracountry\n    df_month['intracountry'] = df_month['issuing_country'] == df_month['acquirer_country']\n    \n    unique_tx_profiles = df_month[[\n        'card_scheme', 'is_credit', 'aci', 'intracountry'\n    ]].drop_duplicates()\n\n    for _, tx in unique_tx_profiles.iterrows():\n        # Build context for matching\n        context = {\n            'card_scheme': tx['card_scheme'],\n            'account_type': merch_info['account_type'],\n            'merchant_category_code': merch_info['merchant_category_code'],\n            'capture_delay': merch_info['capture_delay'],\n            'monthly_volume': total_volume,\n            'monthly_fraud_level': monthly_fraud_ratio,\n            'is_credit': tx['is_credit'],\n            'aci': tx['aci'],\n            'intracountry': tx['intracountry']\n        }\n        \n        # Check against all rules\n        for rule in fees_data:\n            if match_fee_rule(context, rule):\n                applicable_fee_ids.add(rule['ID'])\n\n    # 7. Output Result\n    # Sort IDs for consistent output\n    sorted_ids = sorted(list(applicable_fee_ids))\n    \n    # Print simply the list of IDs as requested by \"What were the applicable Fee IDs\"\n    print(\", \".join(map(str, sorted_ids)))",
    "execution_output": "12, 36, 38, 51, 64, 79, 84, 107, 123, 134, 150, 162, 163, 187, 217, 276, 280, 284, 300, 304, 332, 347, 364, 367, 381, 384, 428, 431, 433, 454, 456, 473, 477, 491, 501, 503, 536, 547, 556, 572, 595, 612, 616, 622, 626, 637, 640, 660, 678, 680, 682, 702, 709, 721, 741, 769, 804, 813, 834, 849, 858, 861, 863, 870, 878, 888, 891, 913, 915, 921, 980, 996\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "insufficient",
    "temperature": 0.15000000000000002,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter for rows where the `merchant` is 'Martinis_Fine_Steakhouse' and the `day_of_year` is between 121 and 151 (representing May 2023).",
      "Calculate the total monthly volume and fraud rate from the filtered payments data, load `merchant_data.json` to retrieve the merchant's static attributes (MCC, account type, capture delay), and identify all unique combinations of transaction attributes (`card_scheme`, `is_credit`, `aci`, `issuing_country`, `acquirer_country`) present in the filtered data."
    ]
  },
  {
    "round": 3,
    "plan_steps": 2,
    "code_length": 10006,
    "code": "import pandas as pd\nimport json\nimport numpy as np\n\n# ---------------------------------------------------------\n# HELPER FUNCTIONS\n# ---------------------------------------------------------\n\ndef coerce_to_float(value):\n    \"\"\"Convert string with %, $, commas to float. Handles common formats.\"\"\"\n    if value is None:\n        return 0.0\n    if isinstance(value, (int, float)):\n        return float(value)\n    if isinstance(value, str):\n        v = value.strip().replace(',', '').replace('\u20ac', '').replace('$', '')\n        v = v.lstrip('><\u2264\u2265')  # Remove comparison operators\n        if '%' in v:\n            try:\n                return float(v.replace('%', '')) / 100\n            except ValueError:\n                return 0.0\n        # Range handling (e.g., \"50-60\") - return mean\n        if '-' in v and len(v.split('-')) == 2:\n            try:\n                parts = v.split('-')\n                return (float(parts[0]) + float(parts[1])) / 2\n            except:\n                pass\n        try:\n            return float(v)\n        except ValueError:\n            return 0.0\n    return 0.0\n\ndef parse_range(range_str):\n    \"\"\"\n    Parses a range string like '100k-1m', '7.7%-8.3%', '>5', '<3'.\n    Returns (min_val, max_val).\n    \"\"\"\n    if not isinstance(range_str, str):\n        return None, None\n    \n    s = range_str.lower().strip()\n    \n    # Helper to parse individual values with suffixes\n    def parse_val(x):\n        x = x.strip()\n        if x.endswith('%'):\n            return float(x.replace('%', '')) / 100.0\n        factor = 1\n        if x.endswith('k'):\n            factor = 1000\n            x = x[:-1]\n        elif x.endswith('m'):\n            factor = 1000000\n            x = x[:-1]\n        try:\n            return float(x) * factor\n        except ValueError:\n            return 0.0\n\n    if '>' in s:\n        val = parse_val(s.replace('>', ''))\n        return val, float('inf') # >5 means (5, inf) - strictly greater usually, but for fees often inclusive boundary logic varies. Let's assume standard math.\n        # Actually, usually >5 means 6 onwards for integers, or 5.0001. Let's use val as exclusive lower bound if possible, or inclusive if logic dictates.\n        # For simplicity in fee rules, >5 usually implies >= 6 if integer days, or > 5.0.\n        # Let's treat it as strictly greater for float comparison.\n        # However, standard implementation often treats > as >= for safety or uses epsilon.\n        # Let's stick to strict >.\n        return val, float('inf')\n\n    if '<' in s:\n        val = parse_val(s.replace('<', ''))\n        return float('-inf'), val\n\n    if '-' in s:\n        parts = s.split('-')\n        if len(parts) == 2:\n            return parse_val(parts[0]), parse_val(parts[1])\n            \n    # Exact match numeric string\n    try:\n        val = parse_val(s)\n        return val, val\n    except:\n        return None, None\n\ndef check_range(value, range_str):\n    \"\"\"Checks if a value falls within a range string.\"\"\"\n    if range_str is None:\n        return True\n    \n    # Handle exact string matches for non-numeric ranges (e.g. 'immediate')\n    if isinstance(range_str, str) and not any(c.isdigit() for c in range_str):\n        return str(value).lower() == range_str.lower()\n\n    min_v, max_v = parse_range(range_str)\n    \n    # If parsing failed, fall back to string equality\n    if min_v is None: \n        return str(value).lower() == str(range_str).lower()\n    \n    # Handle strict inequalities if needed, but usually inclusive is safer for ranges like 3-5\n    # For >5, min_v is 5, max_v is inf. value 7 -> 5 <= 7 <= inf.\n    # Wait, parse_range returns (5, inf) for >5.\n    # If logic is strictly >, we need to adjust.\n    # But usually '3-5' is inclusive.\n    # Let's refine check:\n    \n    if '>' in range_str:\n        return value > min_v\n    if '<' in range_str:\n        return value < max_v\n        \n    return min_v <= value <= max_v\n\ndef match_fee_rule(tx_context, rule):\n    \"\"\"\n    Determines if a fee rule applies to a specific transaction context.\n    \"\"\"\n    # 1. Card Scheme (Exact match)\n    if rule.get('card_scheme') and rule['card_scheme'] != tx_context['card_scheme']:\n        return False\n\n    # 2. Account Type (List match - rule['account_type'] is a list of allowed types)\n    # If rule list is empty, it applies to all.\n    if rule.get('account_type'):\n        if tx_context['account_type'] not in rule['account_type']:\n            return False\n\n    # 3. Merchant Category Code (List match)\n    # If rule list is empty, it applies to all.\n    if rule.get('merchant_category_code'):\n        if tx_context['merchant_category_code'] not in rule['merchant_category_code']:\n            return False\n\n    # 4. Capture Delay\n    # Merchant has specific value (e.g., '1', 'immediate'). Rule has range/value (e.g., '<3', 'immediate').\n    rule_delay = rule.get('capture_delay')\n    if rule_delay:\n        merch_delay = str(tx_context['capture_delay'])\n        \n        # Case A: Both are words\n        if not merch_delay[0].isdigit() and not rule_delay[0].isdigit() and not rule_delay.startswith(('>', '<')):\n            if merch_delay.lower() != rule_delay.lower():\n                return False\n        \n        # Case B: Merchant is numeric (days), Rule is range/numeric\n        elif merch_delay.isdigit():\n            days = int(merch_delay)\n            if not check_range(days, rule_delay):\n                return False\n        \n        # Case C: Mismatch types (e.g. Merchant 'immediate' vs Rule '<3') -> False\n        else:\n            # If one is numeric-like and other is word-like, they don't match\n            # Unless 'immediate' implies 0 days? Usually treated as distinct category.\n            return False\n\n    # 5. Monthly Volume (Range match)\n    if rule.get('monthly_volume'):\n        if not check_range(tx_context['monthly_volume'], rule['monthly_volume']):\n            return False\n\n    # 6. Monthly Fraud Level (Range match)\n    if rule.get('monthly_fraud_level'):\n        if not check_range(tx_context['monthly_fraud_level'], rule['monthly_fraud_level']):\n            return False\n\n    # 7. Is Credit (Boolean match)\n    # If rule is None, applies to both.\n    if rule.get('is_credit') is not None:\n        if rule['is_credit'] != tx_context['is_credit']:\n            return False\n\n    # 8. ACI (List match)\n    # If rule list is empty, applies to all.\n    if rule.get('aci'):\n        if tx_context['aci'] not in rule['aci']:\n            return False\n\n    # 9. Intracountry (Boolean match)\n    # Rule: 1.0 (True), 0.0 (False), None (Any)\n    if rule.get('intracountry') is not None:\n        rule_intra = bool(rule['intracountry'])\n        if rule_intra != tx_context['intracountry']:\n            return False\n\n    return True\n\n# ---------------------------------------------------------\n# MAIN LOGIC\n# ---------------------------------------------------------\n\ndef main():\n    # 1. Load Data\n    try:\n        df_payments = pd.read_csv('/output/chunk6/data/context/payments.csv')\n        with open('/output/chunk6/data/context/fees.json', 'r') as f:\n            fees_data = json.load(f)\n        with open('/output/chunk6/data/context/merchant_data.json', 'r') as f:\n            merchant_data = json.load(f)\n    except FileNotFoundError as e:\n        print(f\"Error loading files: {e}\")\n        return\n\n    # 2. Define Context\n    target_merchant = 'Martinis_Fine_Steakhouse'\n    target_year = 2023\n    # May is days 121 to 151 (non-leap year)\n    start_day = 121\n    end_day = 151\n\n    # 3. Filter Payments for Merchant and Month\n    df_month = df_payments[\n        (df_payments['merchant'] == target_merchant) &\n        (df_payments['year'] == target_year) &\n        (df_payments['day_of_year'] >= start_day) &\n        (df_payments['day_of_year'] <= end_day)\n    ].copy()\n\n    if df_month.empty:\n        print(\"No transactions found for this merchant in May 2023.\")\n        return\n\n    # 4. Calculate Monthly Stats (Volume & Fraud)\n    # Manual Section 7: \"Fraud is defined as the ratio of fraudulent volume over total volume.\"\n    total_volume = df_month['eur_amount'].sum()\n    fraud_volume = df_month[df_month['has_fraudulent_dispute']]['eur_amount'].sum()\n    \n    monthly_fraud_ratio = fraud_volume / total_volume if total_volume > 0 else 0.0\n    \n    # Debug stats\n    # print(f\"Total Volume: {total_volume}\")\n    # print(f\"Fraud Ratio: {monthly_fraud_ratio}\")\n\n    # 5. Get Static Merchant Attributes\n    merch_info = next((item for item in merchant_data if item[\"merchant\"] == target_merchant), None)\n    if not merch_info:\n        print(f\"Merchant {target_merchant} not found in merchant_data.json\")\n        return\n\n    # 6. Identify Applicable Fee IDs\n    # We need to check every unique transaction profile that occurred\n    \n    # Calculate intracountry for each transaction\n    # Intracountry = (issuing_country == acquirer_country)\n    df_month['intracountry'] = df_month['issuing_country'] == df_month['acquirer_country']\n    \n    # Get unique profiles\n    unique_tx_profiles = df_month[[\n        'card_scheme', 'is_credit', 'aci', 'intracountry'\n    ]].drop_duplicates()\n\n    applicable_fee_ids = set()\n\n    for _, tx in unique_tx_profiles.iterrows():\n        # Build context for matching\n        context = {\n            'card_scheme': tx['card_scheme'],\n            'account_type': merch_info['account_type'],\n            'merchant_category_code': merch_info['merchant_category_code'],\n            'capture_delay': merch_info['capture_delay'],\n            'monthly_volume': total_volume,\n            'monthly_fraud_level': monthly_fraud_ratio,\n            'is_credit': tx['is_credit'],\n            'aci': tx['aci'],\n            'intracountry': tx['intracountry']\n        }\n        \n        # Check against all rules\n        for rule in fees_data:\n            if match_fee_rule(context, rule):\n                applicable_fee_ids.add(rule['ID'])\n\n    # 7. Output Result\n    sorted_ids = sorted(list(applicable_fee_ids))\n    print(\", \".join(map(str, sorted_ids)))\n\nif __name__ == \"__main__\":\n    main()",
    "execution_output": "12, 36, 38, 51, 64, 79, 84, 107, 123, 134, 150, 162, 163, 187, 217, 276, 280, 284, 300, 304, 332, 347, 364, 367, 381, 384, 428, 431, 433, 454, 456, 473, 477, 491, 501, 503, 536, 547, 556, 572, 595, 612, 616, 622, 626, 637, 640, 660, 678, 680, 682, 702, 709, 721, 741, 769, 804, 813, 834, 849, 858, 861, 863, 870, 878, 888, 891, 913, 915, 921, 980, 996\n",
    "original_error": null,
    "debugger_used": false,
    "verification": "sufficient",
    "temperature": 0.25,
    "plan_snapshot": [
      "Load the `payments.csv` file into a dataframe and filter for rows where the `merchant` is 'Martinis_Fine_Steakhouse' and the `day_of_year` is between 121 and 151 (representing May 2023).",
      "Load `fees.json`, `merchant_data.json`, and `payments.csv`. Filter `payments.csv` for 'Martinis_Fine_Steakhouse' transactions in May 2023 (day_of_year 121-151). Calculate the merchant's monthly volume and fraud rate for this period. Identify the unique combinations of transaction attributes (`card_scheme`, `is_credit`, `aci`, and `intracountry` status) present in the filtered data. Finally, iterate through `fees.json` to identify and list all Fee IDs where the rule's criteria (matching the merchant's calculated volume, fraud rate, MCC, account type, capture delay) and transaction attributes match the merchant's profile and at least one of their transaction types."
    ]
  }
]